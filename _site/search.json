[
  {
    "objectID": "smoothing.html",
    "href": "smoothing.html",
    "title": "Smoothing",
    "section": "",
    "text": "Some example data, and the problem setting\nThe following code produces a function whose graphs shows several ups and downs. Don’t pay to much attention on how the function works; just look at its graph.\n\nlibrary( splines )\n\nspline_coefs = c( .1, .1, .1, .3, 1.3, 1.3, -.1, -.1, -.1, .3, .3  )\nspline_knots = c( .1, .1, .32, .35, .36, .48, .7 )\n  \ntrue_function &lt;- function(x)\n   bs( x, knots=spline_knots, intercept=TRUE ) %*% spline_coefs\n\nxg &lt;- seq( 0, 1, length.out=1000 )\nplot( xg, true_function( xg ), type=\"l\" )\n\n\n\n\nLet’s assume, we have some complicated apparatus or some complex system, which responds to some input or stimulus with an output or response governed by this function. Unfortunately, the measurement of the response is very noisy, and we have measurements only for a limited number of stimulus values.\nHere’s the 100 stimulus values:\n\nn &lt;- 100\nset.seed( 13245769 )\nx &lt;- runif( n )\n\nAnd here’s the measured responses:\n\ny &lt;- true_function( x ) + rnorm( n, sd=.1 )\n\nThis is how our data looks like:\n\nplot( x, y )\n\n\n\n\nCan we reconstruct the original function from this noisy data?\n\n\nBinned means\nThe simplest idea would be to bin the x-values and calculate for each bin of x values an average of the y values, e.g. one average of the y values corresponding to the x-values x from 0 to 0.1, one average for x between .1 and .2, etc.\n\nsuppressPackageStartupMessages( library( tidyverse ) )\n\ntibble( x, y ) %&gt;%\nmutate( xbin = cut_width( x, .1, center=0.05 ) ) %&gt;%\ngroup_by( xbin ) %&gt;%\nsummarise_all( mean ) %&gt;%\nggplot() + geom_point( aes( xbin, y ) )\n\n\n\n\n\n\nKernel smoothing\nThe hard cuts might introduce artefacts. An alternative is the following:\nTo get a smooth \\(y\\) value for a given value \\(x_0\\), calculate a weighted mean of the \\(y\\) values, where the weight depends on the distance \\(x-x_0\\) and is 0 for distance larger than some “smoothing bandwidth” \\(h\\):\n\\[ f_\\text{sm}(x_0) = \\frac{ \\sum_i y_i w_i }{\\sum_i w_i}, \\] where the weights depend on some “kernel function” \\(f_\\text{K}\\) as \\[ w_i = f_\\text{K}\\left(\\frac{x-x_0}{h}\\right).\\]\nThere are many choices for kernel functions. Wikipedia lists the popular ones.\nA kernel function should be symmetric \\(f_\\text{K}(x)=f_\\text{K}(-x)\\), have a single mode at 0, be continuous, perhaps also differentiable, and small or even zero for \\(|x|&gt;0\\). We use the tricube kernel \\[ f_\\text{tc}(u) = \\left\\{ \\begin{align}\n\\frac{70}{81} \\left(1-|u|^3\\right)^3 \\qquad & \\text{for } |u| \\le 1\n\\\\\n0 \\qquad & \\text{otherwise}\n\\end{align} \\right.\\]\nThe prefactor merely ensures that the function has a unit integral. As we divide by the weight sum anyway, we don’t need it:\n\ntricube &lt;- function(u)\n  ifelse( abs(u) &lt; 1, ( 1 - abs(u)^3 )^3, 0 )\n\nHere’s the smoothing function \\(f_\\text{sm}\\) from above, now in R:\n\nkernel_smooth &lt;- function( x0, x, y, h ) {\n  w &lt;- tricube( ( x - x0 ) / h )\n  sum( w * y ) / sum( w )\n}\n\nWe use it to draw a smoothed plot:\n\nxg &lt;- seq( 0, 1, length.out = 300 )\n\nplot( \n  xg, \n  sapply( xg, kernel_smooth, x, y, h=.1), \n  type=\"l\", col=\"red\", ylim=c( -.1, 1.5 ) )\n\nlines( xg, true_function( xg ), col=\"blue\" )\npoints( x, y )\n\n\n\n\nFor comparison, we have added to the smoothing curve (red) the true function (blue), from which we had sampled our data.\n\nBandwidth choice\nExperiment a bit with values for \\(h\\), the kernel width (also called the “smoothing bandwidth”).\nHow to choose a good value? What’s the trade-off?\n\n\n\nLocal regression\n(also known as “LOESS smoothing” or “LOWESS smoothing”, for “locally estimated/weighted scatterplot smoothing”)\nIn the curves above, the smoothed line has difficulties following the steep decent in the middle. This is because a kernel smoother cannot “sense slope”.\nBefore, we have calculated a weighted average to get a smooth \\(y\\) value for a given point \\(x_0\\). Now, we will perform a weighted regression at this point.\nLet’s choose \\(x_0=0.4\\) and look at the weights by making a scatter plot\nusing points with weight-proportional area:\n\nx0 &lt;- .4\n\nw &lt;- tricube( ( x - x0 ) / .1 )\n\nplot( x, y, cex=w )\n\n\n\n\nLet’s fit a regression in line into with plot. We use the fact that the lm function accepts weights.\n\nfit &lt;- lm( y ~ x, weights=w )\n\nfit\n\n\nCall:\nlm(formula = y ~ x, weights = w)\n\nCoefficients:\n(Intercept)            x  \n      4.201       -9.521  \n\n\nHere, lm has now maximized the weighted sum of squared residuals,\n\\[ \\frac{\\sum_i w_i ( \\hat y_i - y )^2}{\\sum_i w_i}, \\qquad \\text{with } \\hat y_i = \\hat a + \\hat b x_i, \\] where \\(\\hat a\\) and \\(\\hat b\\) are the fitetd coefficients (intercept and slope), reported by\n\ncoef(fit)\n\n(Intercept)           x \n   4.200663   -9.521193 \n\n\nand \\(w_i\\) are the weights, calculated as above.\nLet’s put the regression line into our plot, in orange, together fith the fitted value at point \\(x_0\\) (in red) :\n\nplot( x, y, cex=w )\nabline( a=coef(fit)[1], b=coef(fit)[2], col=\"orange\" )\npoints( x0, coef(fit)[1] + x0*coef(fit)[2], col=\"red\" )\nlines( xg, true_function(xg), col=\"lightblue\" )\n\n\n\n\nHere is a function that does all these steps:\n\nlocal_regression_smooth &lt;- function( x0, x, y, h ) {\n  w &lt;- tricube( ( x - x0 ) / h )\n  fit &lt;- lm( y ~ x, weights=w )\n  coef(fit)[1] + x0 * coef(fit)[2]\n}\n\nIt’s not vectorized, so we have to wrap it in an sapply to get the whole smoothed curve (as before):\n\nplot( \n  xg, \n  sapply( xg, local_regression_smooth, x, y, h=.1), \n  type=\"l\", col=\"red\", ylim=c( -.1, 1.5 ) )\n\nlines( xg, true_function( xg ), col=\"blue\" )\n\n\n\n\nHere, switching from simple kernel smoothing to local regression did not make that much of a difference but sometimes, it helps a lot.\n\nHigher-order local regression\nOf course, instead of fitting a regression line, we could have fitted a parabola. This is quickly done, by adding a quadratic term to the regression\n\nlocal_quadratic_regression_smooth &lt;- function( x0, x, y, h ) {\n  w &lt;- tricube( ( x - x0 ) / h )\n  fit &lt;- lm( y ~ x + I(x^2), weights=w )\n  coef(fit)[1] + x0 * coef(fit)[2] + x0^2 * coef(fit)[3]\n}\n\n\nplot( \n  xg, \n  sapply( xg, local_quadratic_regression_smooth, x, y, h=.1), \n  type=\"l\", col=\"red\", ylim=c( -.1, 1.5 ) )\n\nlines( xg, true_function( xg ), col=\"blue\" )\n\n\n\n\nThis did, in fact, improve the fit.\n\n\nAdaptive bandwidth\nWhat if the x values are not uniformly dstributed?\nThis time, we draw our x values from a non-uniform distribution:\n\nset.seed( 13245768 )\n\nx &lt;- sample( c( rbeta( n/2, 3, 7 ), rbeta( n/2, 9, 1 ) ) )\ny &lt;- true_function( x ) + rnorm( n, sd=.1 )\n\nplot( x, y )\nlines( xg, sapply( xg, local_quadratic_regression_smooth, x, y, h=.1 ), col=\"red\" )\nlines( xg, true_function( xg ), col=\"blue\" )\n\n\n\n\nThe bandwidth is too large where the points are dense and too narrow where they are sparse.\nAdaptive bandwidth: Always choose \\(h\\) such that a fixed number of x values are within the kernel window.\n\nlocal_quadratic_regression_adaptive_smooth &lt;- function( x0, x, y, hn ) {\n  ds &lt;- sort( abs( x - x0 ) )\n  h &lt;- ds[hn]\n  w &lt;- tricube( ( x - x0 ) / h )\n  fit &lt;- lm( y ~ x + I(x^2), weights=w )\n  coef(fit)[1] + x0 * coef(fit)[2] + x0^2 * coef(fit)[3]\n}\n\nplot( x, y )\nlines( xg, sapply( xg, local_quadratic_regression_adaptive_smooth, x, y, hn=30 ), col=\"red\" )\nlines( xg, true_function( xg ), col=\"blue\" )\n\n\n\n\n\n\nLocfit\nIn R, all this, and more, is available via the loess function (part of base R) or the locfit package. Our implementation above is, of course, very simple and slow, so better use these functions.\n\nplot( x, y )\nlines( xg, sapply( xg, local_quadratic_regression_adaptive_smooth, x, y, hn=30 ), col=\"red\" )\nlines( xg, true_function( xg ), col=\"blue\" )\n\nfit &lt;- loess( y ~ x, degree=2, span = 30/length(x) )\nlines( xg, predict( fit, xg ), col=\"orange\", lty=\"dashed\" )\n\n\n\n\nHere, we specified in the loess call that we want local regression with quadratic polynomials, with an adaptive bandwidth as given by span (which specified the number of points put under the kernel as fraction of the total number of data points).\nIt seems that the “loess” function (orange line) gives a slightly better result than our simple implementation (red line). Maybe it knows an additional trick?\n\n\n\nUncertainty estimation\n\nBootstrapping\nUsually, we do not know the “true” function. So, how can we judge how good it is?\nBootstrapping offers a way.\nBootstrapping means to replace the data with new data which is obtained by drawing observations, i.e., \\((x,y)\\) pairs, from the data, with replacement. Doing this many times provides a distribution of possible alternative fits.\nFirst, let’s do this for simple kernel smoothing:\n\nplot( x, y, xlim=c(0,1), ylim=c(-.2,1.6) )\n\nfor( i in 1:100 ) {\n  bss &lt;- sample.int( length(x), replace=TRUE )\n  lines( xg, sapply( xg, kernel_smooth, x[bss], y[bss], h=.1 ), \n     col = adjustcolor( \"red\", alpha=.1 ) ) }\n\nlines( xg, true_function(xg), col=\"blue\" )\n\n\n\n\nNow the same for local quadratic regression with the loess function:\n\nplot( x, y, xlim=c(0,1), ylim=c(-.5,1.5) )\n\nfor( i in 1:100 ) {\n  bss &lt;- sample.int( length(x), replace=TRUE )\n  lines( xg, predict( loess( y[bss] ~ x[bss], degree=2, span = 30/length(x) ), xg ),\n     col = adjustcolor( \"red\", alpha=.1 ) ) }\n\nlines( xg, true_function(xg), col=\"blue\" )\n\n\n\n\n\n\nLeave-one-out cross-validation\nAnother possibility is to use LOO-CV:\nCalculate for each data point its y value, using the y values of its neighbours, but not using the point’s own y value.\n\nyhat_loo &lt;- sapply( 1:length(x), function(i)\n  kernel_smooth( x[i], x[-i], y[-i], h=.1 ) ) \n\nplot( x, y )\npoints( x, yhat_loo, col=\"red\" )\n\n\n\n\nNow we can calculate a mean squared error (MSE):\n\nmean( ( y - yhat_loo )^2 )  # Mean squared error\n\n[1] 0.01629228\n\n\nIs the MSE lower with a more advanced smoother?\n\nyhat_loo &lt;- sapply( 1:length(x), function(i)\n  predict( loess( y[-i] ~ x[-i] ), x[i] ) ) \n\nmean( ( y - yhat_loo )^2, na.rm=TRUE )\n\n[1] 0.08926885\n\n\n\n\nStandard errors from regression\nUsing the math of ordinary least squares (OLS) regression, we can also get standard errors from a LOESS fit.\nHere, we multiply by 1.96 to get a 95% confidence band.\n\npred &lt;- predict( loess( y ~ x, span=.1 ), xg, se=TRUE )\n\nplot( x, y, xlim=c(0,1), ylim=c(-.5,1.5) )\nlines( xg, pred$fit, col=\"red\" )\nrect( xg, pred$fit - 1.96 * pred$se.fit, \n      lead(xg), pred$fit + 1.96 * pred$se.fit, col=alpha(\"red\",.3), lty=\"blank\" )\nlines( xg, true_function(xg), col=\"blue\" )\n\n\n\n\n\n\n\nExample with Poisson noise\nAbove, the noise was Gaussian (normal). In our single-cell data, it is Poissonian. Furthermore, we would like to calculate the curve on the log level, while properly dealing with zeroes.\nWe construct example count data from our curved function.\nLet’s use a few more data points this time:\n\nn &lt;- 300\n\nLet’s sample predictors. We call them x, as before, even though t might be appropriate, too, as in out real-data example, the x axis was pseudotime.\n\nset.seed( 13245768 )\nx &lt;- runif(n)\n\nFirst, we need cell sizes (count totals per cell). We draw them from a log normal:\n\ns = round( exp( rnorm( n, log(1e3), .5 ) ) )\n\nhist( log10(s) )\n\n\n\n\nNext, we get true fractions from our true_function, which we exponentiate. We have to rescale and shift a bit to get realistic values:\n\ntrue_fraction &lt;- function(x) exp( true_function(x) * 4 - 8 )\n\nq &lt;- true_fraction(x)\n\nplot( x, q, log=\"y\")\n\n\n\n\nNow, we add the Poisson noise:\n\nk &lt;- rpois( n, q * s )\n\nplot( x, log( k/s * 1e4 + 1 ) )\n\n\n\n\n\n\nKernel smoothing\nLet’s first use a simple kernel smoother. However, for the average, we use this time not \\[ f_\\text{sm}(x_0) = \\frac{ \\sum_i y_i w_i }{\\sum_i w_i}, \\] as before, but \\[ f_\\text{Psm}(x_0) = \\log \\frac{ \\sum_i k_i w_i }{\\sum_i s_i w_i}, \\] We first try it, then see why this makes sense.\n\nkernel_smooth_Poisson &lt;- function( x0, x, k, s, h ) {\n  w &lt;- tricube( ( x - x0 ) / h )\n  sum( w * k ) / sum( w * s )\n}\n\nWe use it to draw a smoothed plot:\n\nxg &lt;- seq( 0, 1, length.out = 300 )\n\nplot( xg, sapply( xg, kernel_smooth_Poisson, x, k, s, h=.1 ), \n  type=\"l\", col=\"red\", log=\"y\", ylim=c(1e-4,1e-1) )\n\nlines( xg, true_fraction( xg ), col=\"blue\" )\n\n\n\n\nTo understand the change in the last two equations, we need a short detour:\n\nInverse-variance weighting\nGiven \\(n\\) independent random variables \\(X_i\\) with variances \\(v_i=\\operatorname{v_i}\\), we want to estimate the expectation of their mean, \\(\\operatorname{E}\\left(\\frac{1}{n}\\sum_{i=1}^n X_i\\right)\\), by way of estimating a weighted mean, \\[ \\hat\\mu = \\frac{\\sum_iw_iX_i}{\\sum_i w_i}. \\] How should the weights be chosen such that the estimator’s sampling variance, \\(\\operatorname{Var}\\hat\\mu\\), is minimized?\nIf all the estimated variances are the same, \\(v_i=v\\), then the weights should all be the same, too: \\(w_i\\propto 1\\).\nIn general, however, the weights might differ. Then, one should choose \\(w_i\\propto \\frac{1}{v_i}\\).\nThis is easily proven with Lagrange multipliers; the proof can be found on the Wikipedia page on inverse-variance weighting.\n\n\nApplication to Poisson variables\nLet us now assume that the random variables we want to average over are fractions derived from Poisson counts. We have cells, indexed by \\(i\\), with counts for our gene of interest, given by \\(K_i\\sim \\operatorname{Pois}(s_i q)\\), where \\(s_i\\) is the “size”, i.e., the total count sum for the cell. We wish to estimate the common expected fraction \\(q\\) via teh weighted average \\[ \\hat q = \\frac{\\sum_iw_i\\frac{K_i}{s_i}}{\\sum_i w_i}. \\] What weights \\(w_i\\) should we use? Using \\(\\operatorname{Var} K_i=s_i q\\) together with the preceding result, we get \\[ w_i \\propto \\frac{1}{\\operatorname{Var}\\frac{K_i}{s_i}}=\\frac{1}{\\frac{1}{s_i^2}\\operatorname{Var}K_i}=\\frac{1}{\\frac{1}{s_i^2}s_iq}=\\frac{s_i}{q} \\propto s_i \\] Hence:\n\\[ \\hat q = \\frac{\\sum_iw_i\\frac{K_i}{s_i}}{\\sum_i w_i} = \\frac{\\sum_i s_i\\frac{K_i}{s_i}}{\\sum_i s_i} = \\frac{\\sum_i K_i}{\\sum_i s_i}. \\] This justifies our switching from \\(\\frac{1}{n}\\sum_i(k_i/s_i)\\) to \\((\\sum_i k_i)/(\\sum_i s_i)\\) in our smoothing function.\n\n\n\nGeneralized linear models\nBefore proceding further, we need another detour, this time to introduce generalized linear models (GLMs) as a generalization of OLS linear models.\n\nExample: Radioactive decay\nWe have measurements of the number of clicks per minute for a radioactive sample. Let’s simulate this: We count every 10 minutes for 1 minute, up to 200 minutes. The activite at t=0 is 1000 clicks/min, the half-life is 130 min.\n\nt &lt;- seq( from=0, by=10, length.out=20 )\nexpected_counts_per_min &lt;- 100* 2^( - t / 20 )\n\nk &lt;- rpois( length(t), expected_counts_per_min )\n\nplot( t, k )\n\n\n\n\nA simple approach is to plot on a semi-log plot:\n\nplot( t, k, log=\"y\")\n\nWarning in xy.coords(x, y, xlabel, ylabel, log): 6 y values &lt;= 0 omitted from\nlogarithmic plot\n\n\n\n\n\nand fit a regression line. However, the zeroes mess this up.\nHere’s a better way:\nWe may assume that \\[ k_i \\sim \\operatorname{Pois}( \\alpha e^{\\kappa t_i})\\] The true values are \\(\\alpha = 100\\) (the initial click rate) and \\(\\kappa = \\ln 2 / 20\\approx .035\\) (using the half life, 20, from above).\nWe can find maximum-likelihood estimates for \\(\\alpha\\) and \\(\\kappa\\). Here is the log-likelihood for a pair of candidate values \\(\\alpha\\) and \\(kappa\\):\n\nll &lt;- function( alpha, kappa )\n  sum( dpois( k, alpha * exp( -kappa * t ), log=TRUE ) )\n\nWe can find the parameters that maximize this function, using some guessed initital values:\n\noptim( \n  c( 50, 0.1 ),\n  function( x ) -ll( x[1], x[2] ) )\n\n$par\n[1] 92.39194421  0.03427986\n\n$value\n[1] 40.2579\n\n$counts\nfunction gradient \n     117       NA \n\n$convergence\n[1] 0\n\n$message\nNULL\n\n\n\n\nGLMs\nRewriting our model a bit, we recover the form of a “generalized linear model” (GLM). A GLM always has three components:\n\nThe response (in our case, the counts \\(K_i\\)) follows a distribution from the so-called exponential family (which includes the normal, the Poisson, the binomial, the gamma-Poisson, and others). Here, we have:\n\n\\[ K_i \\sim \\operatorname{Pois}( \\mu_i ). \\] (ii) The mean parameter \\(\\mu_i\\) in that distribution is coupled with teh so-called “linear predictir$ _i$ by a function, the so-called “link function”. Here: \\[ \\eta_i = \\log \\mu_i. \\] (iii) The linear predictor is a linear combination of known predictors \\(x_ij\\) with unknown coefficients \\(\\beta_j\\). In general \\[ \\eta_i = \\beta_0 + \\sum_j \\beta_j x_{ij} + o_i\\] and here simply \\[ \\eta_i = \\beta_0 + \\beta_1 t_i, \\] i.e. we have, besides the intercept \\(\\beta_0\\), only one further coefficient, \\(\\beta_1\\).\nThere are also no offsets \\(o_i\\). (If the time we had waited at each time point to count would not always have been the same but differed from measurement to measurement, we would have included the length these waiting times as “exposure values” \\(o_i\\).)\nWe can clearly identify how the coefficients of the GLM correspond to our parameters: \\(\\beta_1=-\\kappa=-\\ln2/T_{1/2}\\) and \\(\\beta_0=\\ln\\alpha\\).\nIf the model has this shape, the general optimizer optim that we have used above can be replaced by a GLM solver:\n\nfit &lt;- glm( k ~ t, family = poisson(link=\"log\") )\nfit\n\n\nCall:  glm(formula = k ~ t, family = poisson(link = \"log\"))\n\nCoefficients:\n(Intercept)            t  \n    4.52600     -0.03428  \n\nDegrees of Freedom: 19 Total (i.e. Null);  18 Residual\nNull Deviance:      612.2 \nResidual Deviance: 21.62    AIC: 84.52\n\n\nWe get the same result as with optim. We see this directly for the coefficient for \\(t\\) (i.e., \\(\\kappa\\)), but for \\(\\alpha\\), we have to exponentiate:\n\nexp(coef(fit)[1])\n\n(Intercept) \n   92.38863 \n\n\n\n\nIRLS\nThe glm function is faster than optim and more stable, because it uses a special algorithm known as “iteratively reweighted least squares” (IRLS) fitting.\nI was too lazy to write up how this works, so I asked ChatGPT to do my work:\nhttps://chatgpt.com/share/38554552-182e-45cf-9ea9-556a3592d6df\n\n\n\nLocal regression with GLMs\nNow, that we know GLMs, we can come back to our count data to be smoothed:\n\nset.seed( 13245768 )\nx &lt;- runif(n)\ns &lt;- round( exp( rnorm( n, log(1e3), .5 ) ) )\nk &lt;- rpois( n, q * s )\n\nplot( x, log( k/s * 1e4 + 1 ) )\n\n\n\n\nInstead of a simple kernel smoother, let’s to local regression again, but now with the glm function instead of the lm function:\n\nlocal_quadratic_regression_smooth_Poisson &lt;- function( x0, x, k, s, h ) {\n  w &lt;- tricube( ( x - x0 ) / h )\n  fit &lt;- glm( k ~ x + I(x^2), weights=w, offset=log(s), family=poisson(\"log\") )\n  unname( coef(fit)[1] + x0 * coef(fit)[2] + x0^2 * coef(fit)[3] )\n}\n\nCan you see why we pass the totals \\(s\\) as offsets? Why logarithmized? Have a careful look at the formula with \\(o_i\\) above.\nHere is the result. Smoothed curve in red, noisy data in gray, original function in blue.\n\nsuppressWarnings(\n  yhat &lt;- sapply( xg, local_quadratic_regression_smooth_Poisson, x, k, s, .15 ) )\n\nplot( x, log( k/s + 1e-4 ), col=\"gray\" )\nlines( xg, yhat, col=\"red\" )\nlines( xg, log( true_fraction( xg ) ), col=\"blue\" ) \n\n\n\n\nWe get a lot of warnings aboutv failure of IRLS to converge for some values.\nInstead of trying to debug this, we use the locfit package, where we have a ready-made function for this purpose:\n\nlibrary( locfit )\n\nlocfit 1.5-9.9   2024-03-01\n\n\n\nAttaching package: 'locfit'\n\n\nThe following object is masked from 'package:purrr':\n\n    none\n\nfit &lt;- locfit( k ~ lp( x, h=.15), weights=s, family=\"poisson\" )\n\nplot( x, log( k/s + 1e-4 ), col=\"gray\" )\nlines( xg, log( predict( fit, xg ) ), col=\"red\" )\nlines( xg, log( true_fraction( xg ) ), col=\"blue\" ) \n\n\n\n\n\n\nSpline regression\n\nSpline basis: first look\nAnother possibility is construct a smoothing curve as a linear combination of suitable basis function.\nThe function bs from the splines package produces a popular choice for a bsis function known as “B splines”.\nWe ask bs to provide a 7-dimensional basis and evaluate the basis functions at the points xg (our sequence of 300 numbers between 0 and 1):\n\nlibrary( splines )\n\nhead( cbind( x=xg,  bs( xg, df=7, intercept=TRUE ) ) )\n\n               x         1          2            3            4 5 6 7\n[1,] 0.000000000 1.0000000 0.00000000 0.0000000000 0.000000e+00 0 0 0\n[2,] 0.003344482 0.9604007 0.03933261 0.0002662587 3.990388e-07 0 0 0\n[3,] 0.006688963 0.9218609 0.07707964 0.0010562558 3.192311e-06 0 0 0\n[4,] 0.010033445 0.8843662 0.11326622 0.0023568231 1.077405e-05 0 0 0\n[5,] 0.013377926 0.8479022 0.14791751 0.0041547923 2.553849e-05 0 0 0\n[6,] 0.016722408 0.8124545 0.18105863 0.0064369951 4.987985e-05 0 0 0\n\n\nHere’s a plot\n\nknots &lt;- seq( 0, 1, length.out=8 )\nmatplot( xg, bs( xg, intercept=TRUE, Boundary.knots=knots[c(1,8)], knots=knots[1:7] ), \n    type=\"l\", lty=\"solid\" ) \n\nabline( v=knots, col=\"gray\" )\n\n\n\n\nIn a spline basis, the domain of the basis (here, the unit interval), is split into intervals, as indicated above by the gray lines. The boundaries of the intervals are marked with gray lines above and called knots. As we specified 7 degrees of freedom, we have \\(7-1=6\\) knots. The knots can be places arbitrarily, but here, we have spaced them uniformly.\nA B-spline basis, comprising basis functions \\(b_s\\) (here, $s=1,,10) is constructed to have the following properties:\n\nEach spline is a piecewise-polynomial function, i.e, between any two knots, it is a polynomial.\nThe degree of the polynomial can be chosen; for bs, the default is 3.\nThe basis peritions the unit, i.e., for every \\(x\\) within the range of knots, \\(\\sum_s b_s(x)=1\\).\n\nFor a B-spline basis made of 3rd-degree polynomials, we further have:\n\nEach basis has support on at most 4 segments of the domain, as split by the knots.\nThe basis functions are twice differentiable, but the third derivative is discontinuous at the knots.\n\n\n\nUnpenalized spline regression\nTo deomstrate spline regression, we go back to our original example with Gaussian, rather than Poisson, noise:\n\nn &lt;- 100\nset.seed( 13245769 )\nx &lt;- runif( n )\ny &lt;- true_function( x ) + rnorm( n, sd=.1 )\n\nWe seek a smoothing curve \\(f(x)=\\sum_s \\beta_s b_s(x)\\) that minimizes \\(\\sum_i\\left(y_i-f(x_i)\\right)^2\\).\nWe can find this by OLS regression:\n\nmy_bs &lt;- function(x) bs( x, intercept=TRUE, Boundary.knots=c(0,1), knots=seq(0,1,length.out=8)[2:7] )\n\nfit &lt;- lm.fit( my_bs(x), y ) \nfit$coefficients\n\n          1           2           3           4           5           6 \n-0.12240714  0.47448971 -0.38182562  2.12293953 -0.38211725 -0.01883465 \n          7           8           9          10 \n-0.19319187  0.35809313  0.09608862  0.40257549 \n\nplot( x, y )\nlines( xg, true_function(xg), col=\"blue\")\nlines( xg, my_bs(xg) %*% fit$coefficients, col=\"red\" )\n\n\n\n\nIf we increase the number of knots, the fit becomes better but also too “wiggly”\n\nmy_bs &lt;- function(x) bs( x, intercept=TRUE, Boundary.knots=c(0,1), knots=seq(0,1,length.out=20)[2:19] )\n\nfit &lt;- lm.fit( my_bs(x), y ) \nfit$coefficients\n\n           1            2            3            4            5            6 \n 0.009946524  0.058586095  0.258893913  0.137215507  0.334851555  0.851169376 \n           7            8            9           10           11           12 \n 1.121144587  1.511286792  0.773391525 -0.504725373  0.058186800 -0.194688673 \n          13           14           15           16           17           18 \n-0.056442763 -0.181762284 -0.030007379 -0.142877982  0.247319611  0.072789257 \n          19           20           21           22 \n 0.270731686  0.213996241  0.171709657  0.481918972 \n\nplot( x, y )\nlines( xg, true_function(xg), col=\"blue\")\nlines( xg, my_bs(xg) %*% fit$coefficients, col=\"red\" )\n\n\n\n\n\n\nCurvature-penalized spline regression\nWe can solve this issue by adding a penalty term on curvature to our least-square sum: \\[\\sum_i\\left(y_i-f(x_i)\\right)^2 + \\lambda\\int_0^1(f''(x))^2\\text{d}x=\\text{min!}\\]\nThe function `\n\nfit &lt;- smooth.spline( x, y, nknots=20 )\n\nplot( x, y )\nlines( xg, true_function(xg), col=\"blue\")\nlines( xg, predict( fit, xg )$y, col=\"red\")\n\n\n\n\n\n\nConstruction for the B-spline basis\nIn an iterative construction (de Boor construction), we increase the polynomial degree in each iteration.\nWe start with a 0th-degree basis, where \\(b_{s,0}\\) is simply 1 between the \\(s\\)-th and the \\((s+1)\\)th knot and 0 elsewhere.\n\nm &lt;- 13\nknots &lt;- seq( 0, 1, length.out=m+1 )\n\nbs0 &lt;- sapply( 1:m, function(i) as.numeric( xg &gt;= knots[i] & xg &lt; knots[i+1] ) )\n\nmatplot( xg, bs0, type=\"l\", lty=\"solid\" )\nabline( v=knots, col=\"gray\" )\n\n\n\n\nThe, we construct the 1st-degree basis as follows: \\(b_{s,1}\\) has support between the knot \\(s\\) and knot \\(s+2\\). It is a linear interpolation between \\(b_{s,0}\\) and \\(b_{s+1,0}\\), where the “mixing ratio” between the two 0th-degree basis function linearly goes from 1:0 to 0:1 while going along the support.\nThis yields triangles:\n\nbs1 &lt;- sapply( 1:(m-2), function(s) \n  ( xg - knots[s]   ) / ( knots[s+1] - knots[s]   ) * bs0[,s] +\n  ( knots[s+2] - xg ) / ( knots[s+2] - knots[s+1] ) * bs0[,s+1]  )\n\nmatplot( xg, bs1, type=\"l\", lty=\"solid\" )\nabline( v=knots, col=\"gray\" )\nlines( xg, rowSums(bs1), col=\"#00000030\" )\n\n\n\n\nThe vertical gray lines indicate the knots, the horizontal one shows that the sum of all basis function adds up to 1 in all the interior segments.\nWe repeat the process, using the same code, with changes to the indices: Now, the interpolation runs with over two segments of each of the previous splines. As we perform linear interpolation over linear functions we get piecewise quadratic polynomials, i.e., the following functions are pieced together from parabolas.\n\nbs2 &lt;- sapply( 1:(m-3), function(s) \n  ( xg - knots[s]   ) / ( knots[s+2] - knots[s]   ) * bs1[,s] +\n  ( knots[s+3] - xg ) / ( knots[s+3] - knots[s+1] ) * bs1[,s+1]  )\n\nmatplot( xg, bs2, type=\"l\", lty=\"solid\", ylim=c(0,1) )\nabline( v=knots, col=\"gray\" )\nlines( xg, rowSums(bs2), col=\"#00000030\" )\n\n\n\n\nAs we interpolated between pieces that added to one, the result adds to one again, as indicated by the gray line. Again, this only holds in the inner segments.\nOne more iteration to get to third degree polynomical pieces:\n\nbs3 &lt;- sapply( 1:(m-4), function(s) \n  ( xg - knots[s]   ) / ( knots[s+3] - knots[s]   ) * bs2[,s] +\n  ( knots[s+4] - xg ) / ( knots[s+4] - knots[s+1] ) * bs2[,s+1]  )\n\nmatplot( xg, bs3, type=\"l\", lty=\"solid\", ylim=c(0,1) )\nabline( v=knots, col=\"gray\" )\nlines( xg, rowSums(bs3), col=\"#00000030\" )\n\n\n\n\nThe basis still adds up to 1 in the inner segments.\nWe refactor our code to use a recursive function, taking the argument, x, the index of the basis function, s, the basis degree k, and the knots vector:\n\nbsf &lt;- function( x, s, k, knots ) {\n  if( k == 0 )\n    as.numeric( x &gt;= knots[s] & x &lt; knots[s+1] )\n  else\n    ( x - knots[s]     ) / ( knots[s+k]   - knots[s]   ) * bsf( x, s,   k-1, knots ) +\n    ( knots[s+k+1] - x ) / ( knots[s+k+1] - knots[s+1] ) * bsf( x, s+1, k-1, knots )\n}\n\nThis function is known as the Cox-de Beer formula.\nWith it, we can reconstruct our last plot:\n\nm &lt;- 13\nknots &lt;- seq( 0, 1, length.out=m+1 )\n\nbs3 &lt;- sapply( 1:(m-4), function(s) bsf( xg, s, 3, knots ) )\n\nmatplot( xg, bs3, type=\"l\", lty=\"solid\", ylim=c(0,1) )\nabline( v=knots, col=\"gray\" )\nlines( xg, rowSums(bs3), col=\"#00000030\" )\n\n\n\n\nThe basis produced by bs also adds up to 1 in the outer segments. This is achieved by moving the outer knots where the sum is not 1 very close together.\nWe rerun the code to show this, changing only the knot vector\n\nm &lt;- 13\nknots &lt;- c( -.003, -.002, -.001, seq( 0, 1, length.out=m-6 ), 1.001, 1.002, 1.003, 1.004 )\n\nbs3 &lt;- sapply( 1:(m-4), function(s) bsf( xg, s, 3, knots ) )\n\nmatplot( xg, bs3, type=\"l\", lty=\"solid\", ylim=c(0,1) )\nabline( v=knots, col=\"gray\" )\nlines( xg, rowSums(bs3), col=\"#00000030\" )\n\n\n\n\nOf course, we should form the limit of moving the outer knots exactly to 0 and 1, but that would require us to think very carefully about where to put \\(&lt;\\) and where \\(\\le\\) in the \\(k=0\\) case, and that is cumbersome. Luckily for us, the authors of bs have done that for us.\n\nbs3 &lt;- bs( xg, df=m-4, intercept=TRUE )\nmatplot( xg, bs3, type=\"l\", lty=\"solid\", ylim=c(0,1) )\nabline( v=knots, col=\"gray\" )\nlines( xg, rowSums(bs3), col=\"#00000030\" )\n\n\n\n\n\n\nCurvature of the spline basis\nFor the curvature penalization mentioned earlier, we need the second derivative of the spline basis. As these are piece-wise 3rd-degree polynomials, we expect the second derivative to be piecewise linear. We can calculate explicitely the second derivative of the Cox-de Beer function, or we can rely on other people’s work and believe the formula given, e.g., in Wikipedia.\nStill, we can quickly calculate the second derivative via finite differences. For the orginal, we just get a repeat of a V-shaped curve:\n\nm &lt;- 13\nknots &lt;- seq( 0, 1, length.out=m+1 )\n\nbs3 &lt;- sapply( 1:(m-4), function(s) bsf( xg, s, 3, knots ) )\nmatplot( xg, bs3, type=\"l\", lty=\"solid\", ylim=c(0,1), main=\"degree-3 spline basis\" )\n\n\n\nnr &lt;- nrow(bs3)\nbs3xx &lt;- bs3[1:(nr-2),] - 2*bs3[2:(nr-1),] + bs3[3:nr,]\n\nmatplot( xg[2:(nr-1)], bs3xx, type=\"l\", lty=\"solid\", main=\"2nd derivative\" )\n\n\n\n\nFor the pulled-in outer knots, we get this:\n\nbs3 &lt;- bs( xg, df=m-4, intercept=TRUE )\nmatplot( xg, bs3, type=\"l\", lty=\"solid\", ylim=c(0,1), main=\"degree-3 spline basis\" )\n\n\n\nnr &lt;- nrow(bs3)\nbs3xx &lt;- bs3[1:(nr-2),] - 2*bs3[2:(nr-1),] + bs3[3:nr,]\n\nmatplot( xg[2:(nr-1)], bs3xx, type=\"l\", lty=\"solid\", main=\"2nd derivative\" )\n\n\n\n\nFor a given linear combination \\(f(x) = \\sum_s \\beta_s b_{s,3}(x)\\), it is easy and cheap to calculate the integral of its squared curvature: \\[\\begin{align}\n\\int_0^1 \\left(f(x)\\right)^2\\text{d}x &=\n\\int_0^1\\left(\\sum_{s}\\beta_sb_{s,3}\\right)\\left(\\sum_{s'}\\beta_sb_{s',3}\\right)\\text{d}x\\\\\n&=\\sum_{ss'} \\beta_s\\beta_{s'}\\underbrace{\\int_0^1b_{s,3}(x)b_{s',3}(x)\\mathrm{d}x}_{=P_{ss'}}=\n\\vec\\beta^\\top P \\vec \\beta\n\\end{align}\\] The matrix \\(P\\) can be easily calculated ahead of time and so, the objective of our minimization for curvature-penalized spline regression becomes:\n\\[\\begin{align}\nL=&\\sum_i\\left(y_i-f(x_i)\\right)^2 + \\lambda\\int_0^1(f''(x))^2\\text{d}x\\\\\n=&(\\vec{y}-X\\vec\\beta)^\\top(\\vec{y}-X\\vec\\beta) + \\lambda \\vec{β}^\\top P \\vec\\beta\\\\\n=&\\vec y^\\top\\vec y - 2 \\vec\\beta^\\top X^\\top\\vec y+\\vec\\beta^\\top\\left(\nX^\\top X + \\lambda P\\right)\\vec\\beta\n\\end{align}\\]\nHere, the matrix \\(X\\) has matrix elements \\(X_{is}=b_{s,3}(x_i)\\).\nTo minimize this, we take the gradient w.r.t. \\(\\vec\\beta\\): \\[ \\nabla_{\\vec\\beta}L=-2X^\\top\\vec{y} + 2 \\left(X^\\top X + \\lambda P\\right)\\vec\\beta\\] Setting the gradient to zero, we obtain the OLS normal equation with the added penalty: \\[\\left(X^\\top X + \\lambda P\\right)\\vec\\beta = X^\\top\\vec{y} \\] As this is an equation of the form \\(A\\vec x=\\vec b\\), it describes a system of linear equations that can be solved with QR decomposition (i.e., Gauß elimination) in order to find \\(\\vec\\beta\\).\nThis describes the math behind the smooth.spline function except for one point: a clever heuristic to find a suitable value for the penalty strength parameter \\(\\lambda\\), which we will skip over. (In brief: It turns out that a scale-free smoothing strength can be defined, which one then multiplies with \\(\\operatorname{tr}X^\\top X / \\operatorname{tr} P\\) to obtain \\(\\lambda\\).)\n\n\nP-Splines\nAn alternative to spline regression with curvature penality is P-spline smoothing.\nHere, one uses a basis with rather very many basis functions (large \\(m\\) in our notation), lets all the basis functions keep the same shape (no “pulling in” of the boundary knots), and replaced the curvature penalty with a penalty on the differences between the coefficients for adjacent splines:\n\\[ \\|\\vec y - X\\vec\\beta\\|^2 - \\lambda \\sum_{s=1}^{m-1}\\left(\\beta_{s+1}-\\beta_s\\right)^2\\]\nIt’s easy to see that this penalty can be implemented using the same normal equation as before when setting \\(P\\) to \\[P=\\left(\n\\begin{array}{r}\n1  & -1 &    &    &  \\\\\n-1 &  2 & -1 &    &  \\\\\n   & -1 &  2 & -1 &  \\\\\n   &    & -1 &  2 & -1 & \\\\\n   &    &    & ⋱ &  ⋱ & ⋱ & \\\\\n   &    &    &    & -1 &  2 & -1 & \\\\\n   &    &    &    &    & -1 &  2 & -1 & \\\\\n   &    &    &    &    &    & -1 &  1    \n\\end{array}\n\\right).\\]\nTo demonstrate,w e first make a really large basis, which extends far out of the domain\n\nknots &lt;- seq( -1, 2, length.out=100 )\nm &lt;- length(knots)-4\nbs3 &lt;- sapply( 1:m, function(s) bsf( xg, s, 3, knots ) )\nmatplot( xg, bs3, type=\"l\", lty=\"solid\", ylim=c(0,1), main=\"degree-3 spline basis\" )\n\n\n\n\nWe remove the knots that have no influence inside the domain [0;1]:\n\nknots &lt;- knots[\n  min( which( sapply( 1:length(knots), function(l) bsf( 0, 1, 3, knots[l:length(knots)] ) ) &gt; 0 ) ):\n  max( which( sapply( 1:length(knots), function(l) bsf( 1, l-4, 3, knots[1:l] ) ) &gt; 0 ) ) ]\n\nm &lt;- length(knots)-4\n\nknots\n\n [1] -0.09090909 -0.06060606 -0.03030303  0.00000000  0.03030303  0.06060606\n [7]  0.09090909  0.12121212  0.15151515  0.18181818  0.21212121  0.24242424\n[13]  0.27272727  0.30303030  0.33333333  0.36363636  0.39393939  0.42424242\n[19]  0.45454545  0.48484848  0.51515152  0.54545455  0.57575758  0.60606061\n[25]  0.63636364  0.66666667  0.69696970  0.72727273  0.75757576  0.78787879\n[31]  0.81818182  0.84848485  0.87878788  0.90909091  0.93939394  0.96969697\n[37]  1.00000000  1.03030303  1.06060606  1.09090909\n\n\nNow, we calculate the values of the spline basis at the x coordinates of the data points, and, for later use, also at our grid of equidistant points\n\nspx &lt;- sapply( 1:m, function(s) bsf( x, s, 3, knots ) )\nspxg &lt;- sapply( 1:m, function(s) bsf( xg, s, 3, knots ) )\n\nWe construct the penalty matrix \\(P\\)\n\npty &lt;- diag(2,m)\npty[ row(pty) == col(pty)+1 ] &lt;- -1\npty[ row(pty) == col(pty)-1 ] &lt;- -1\npty[1,1] &lt;- 1\npty[m,m] &lt;- 1\nimage( 1:m, 1:m, pty, asp=1 )\n\n\n\n\nNow, we solve the normal equations for \\(\\lambda=1\\):\n\nlambda &lt;- 1\nbeta &lt;- solve( t(spx) %*% spx + lambda * pty , t(spx) %*% y )\n\nHere is the plot\n\nplot( x, y )\nlines( xg, spxg %*% beta, col=\"red\" )\nlines( xg, true_function(xg), col=\"blue\" )\n\n\n\n\nHere, for a few more values of lambda:\n\nplot( x, y )\nfor( lambda in c( .01, .1, 1, 10, 100 ) ) {\n  beta &lt;- solve( t(spx) %*% spx + lambda * pty , t(spx) %*% y )\n  lines( xg, spxg %*% beta, col=\"red\" )\n}  \nlines( xg, true_function(xg), col=\"blue\" )"
  },
  {
    "objectID": "laplacian_eigenmap.html",
    "href": "laplacian_eigenmap.html",
    "title": "Laplacian eigenmaps",
    "section": "",
    "text": "Laplacian eigenmaps were introduced by Belkin and Niyogi in ther 2003 paper Laplacian Eigenmaps for Dimensionality Reduction and Data Representation (doi:10.1162/089976603321780317)\nWe will try out this method here.\n\nLoad example data\nBefore getting into the topic, we load the usual example data and performing standard preprocessing\n\nsuppressPackageStartupMessages({\n  library( tidyverse )\n  library( Matrix )\n  library( sparseMatrixStats )\n  library( Seurat ) })\n\nReadMtx( \"~/Downloads/ifnagrko/ifnagrko_raw_counts.mtx.gz\",\n    \"~/Downloads/ifnagrko/ifnagrko_obs.csv\",\n    \"~/Downloads/ifnagrko/ifnagrko_var.csv\",\n    cell.sep=\",\", feature.sep=\",\", skip.cell=1, skip.feature=1, \n    mtx.transpose=TRUE) -&gt; count_matrix\n\n\ncount_matrix %&gt;%\nCreateSeuratObject() %&gt;%\nNormalizeData() %&gt;%\nFindVariableFeatures() %&gt;%\nScaleData() %&gt;%\nRunPCA( npcs=20 ) %&gt;%\nFindNeighbors( dims=1:20 ) %&gt;%\nFindClusters( resolution=0.5 ) %&gt;%\nRunUMAP( dims=1:20 ) -&gt; seu\n\nWarning: Feature names cannot have underscores ('_'), replacing with dashes\n('-')\n\n\nNormalizing layer: counts\n\n\nFinding variable features for layer counts\n\n\nCentering and scaling data matrix\n\n\nPC_ 1 \nPositive:  Apoe, Aldoc, Sparcl1, Sdc4, Ptn, Cmtm5, Glul, Gpr37l1, Fxyd1, Atp1b2 \n       S100a1, Slc4a4, Slc1a3, Prxl2a, F3, Itm2b, Mt1, Rgcc, Prdx6, Sfxn5 \n       Sat1, Scrg1, Dbi, Hes5, Luzp2, Plaat3, Pla2g7, Sash1, Plpp3, Sparc \nNegative:  Tubb5, Sox11, Tubb3, Stmn1, Jpt1, Hmgb3, Ptma, Sox4, Dlx2, Cd24a \n       Igfbpl1, Dlx6os1, Map1b, Stmn2, Abracl, Tmsb4x, Lmnb1, Cdca7, Ccnd2, Elavl4 \n       Cdk4, Dcx, Arx, Uchl1, EYFP, Celf4, Dlx5, Nrxn3, H1fx, Hmgn2 \nPC_ 2 \nPositive:  Ctss, C1qc, Laptm5, Csf1r, Trem2, C1qa, Cx3cr1, C1qb, Tyrobp, Ly86 \n       Fcer1g, Siglech, Selplg, Fcrls, Tmem119, Fcgr3, Apbb1ip, Unc93b1, Cd53, Lpcat2 \n       Spi1, Pld4, Olfml3, Irf8, Ctsh, Aif1, Cd300c2, Fyb, Otulinl, Mylip \nNegative:  Rorb, Cldn10, Clu, Mt3, Ntsr2, Mfge8, S1pr1, Id4, Slc1a2, Acsl6 \n       Plpp3, Sox9, Ddah1, Bcan, Cxcl14, Btbd17, Mlc1, Cspg5, Fjx1, Aqp4 \n       Ntm, Acsl3, Gabrb1, Tspan7, Lsamp, Chst2, Mt2, Lhx2, Slc39a12, Glud1 \nPC_ 3 \nPositive:  Atp1a3, Camk2b, Snhg11, Syt1, Nrip3, Kcnj4, Scg2, Snap25, Dnm1, Pcp4 \n       Icam5, Ndrg4, Eef1a2, Eno2, Ano3, Ryr2, Arpp21, Ptk2b, Gng4, Kcna4 \n       Penk, Slc4a10, Snca, Gad1, Rprml, Grin2a, C1qtnf4, Shisa8, Camk2a, Kcnb2 \nNegative:  Hmgb2, Top2a, Pbk, Birc5, Mki67, Cdk1, Cdca8, Spc24, Cenpf, Spc25 \n       Prc1, Rrm2, Mdk, Nusap1, Tpx2, Cdca3, Knl1, Ckap2l, Esco2, Aurkb \n       Cenpm, Ccna2, Bub1, Cks2, Kif11, Hist1h3c, Hist1h1b, Hmmr, Pclaf, Fbxo5 \nPC_ 4 \nPositive:  C1qc, C1qa, Ctss, Trem2, Csf1r, C1qb, Cx3cr1, Laptm5, Fcer1g, Tyrobp \n       Ly86, Siglech, Selplg, Fcrls, Fcgr3, Hexb, Spi1, Cd53, Itgb5, Pld4 \n       Ptgs1, Cd300c2, Aif1, Irf8, Fyb, Itgam, Cyth4, Ltc4s, Otulinl, Cd37 \nNegative:  Frzb, Apod, Npy, Plp1, Vtn, Foxd3, Wnt6, Nr2f2, Edil3, Sox10 \n       Gsn, Matn4, Fbln2, Aspa, Aqp1, Igf1, Plat, Lpar1, Igfbp4, Erbb3 \n       Fabp7, Plppr4, Ptgds, Col23a1, Alx3, Hey2, Cd59a, Fam3c, Scd1, Mybpc1 \nPC_ 5 \nPositive:  Stmn2, Igfbpl1, Cd24a, Nrep, Sox4, Map1b, Stmn4, Tubb3, Shtn1, Dlx6os1 \n       Dcx, Ly6h, Sox11, Jpt1, Mpped2, Stmn1, Plxna4, Pbx3, Elavl4, Uchl1 \n       Runx1t1, Cald1, Foxp2, Dlx2, Gad2, Celf4, Pfn2, Dlx5, Sp8, Tubb5 \nNegative:  Top2a, Pbk, Birc5, Mki67, Spc25, Cdk1, Prc1, Nusap1, Spc24, Esco2 \n       Tpx2, Knl1, Aurkb, Cenpf, Cdca8, Ckap2l, Kif11, Cdca3, Hist1h3c, Hmmr \n       Ccna2, Bub1, Incenp, Hist1h2af, Ndc80, Cit, Fbxo5, Kif4, Sgo1, Kif22 \n\n\nComputing nearest neighbor graph\n\n\nComputing SNN\n\n\nModularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck\n\nNumber of nodes: 18302\nNumber of edges: 616069\n\nRunning Louvain algorithm...\nMaximum modularity in 10 random starts: 0.9191\nNumber of communities: 19\nElapsed time: 4 seconds\n\n\nWarning: The default method for RunUMAP has changed from calling Python UMAP via reticulate to the R-native UWOT using the cosine metric\nTo use Python UMAP via reticulate, set umap.method to 'umap-learn' and metric to 'correlation'\nThis message will be shown once per session\n\n\n15:44:19 UMAP embedding parameters a = 0.9922 b = 1.112\n\n\n15:44:19 Read 18302 rows and found 20 numeric columns\n\n\n15:44:19 Using Annoy for neighbor search, n_neighbors = 30\n\n\n15:44:19 Building Annoy index with metric = cosine, n_trees = 50\n\n\n0%   10   20   30   40   50   60   70   80   90   100%\n\n\n[----|----|----|----|----|----|----|----|----|----|\n\n\n**************************************************|\n15:44:22 Writing NN index file to temp file /tmp/RtmpwAT4Yy/file50c1b7a618495\n15:44:22 Searching Annoy index using 1 thread, search_k = 3000\n15:44:29 Annoy recall = 100%\n15:44:29 Commencing smooth kNN distance calibration using 1 thread with target n_neighbors = 30\n15:44:31 Initializing from normalized Laplacian + noise (using RSpectra)\n15:44:34 Commencing optimization for 200 epochs, with 776086 positive edges\n15:44:44 Optimization finished\n\n\n\nUMAPPlot( seu, label=TRUE ) + coord_equal()\n\n\n\n\nWe subset the object to only the “lineage”:\n\nseu[ , seu$seurat_clusters %in% c( 0, 3, 5, 1, 2, 7, 6, 11 ) ] -&gt; seul\n\nseul\n\nAn object of class Seurat \n20830 features across 14303 samples within 1 assay \nActive assay: RNA (20830 features, 2000 variable features)\n 3 layers present: counts, data, scale.data\n 2 dimensional reductions calculated: pca, umap\n\n\n\n\nLaplacian eigenmaps\nThe idea of Laplacian eigenmaps is briefly as follwos: We assume that our data lives on a sub-manifold of the feature space, but is “lifted off” from it by random noise. Nevertheless, the graph formed by connecting each data point with its \\(k\\) nearest neighbors should recapitulate that manifold’s topology and also induce a metric of map on it.\nSpectral analysis of the neighborhood graph’s Laplacian matrix should reveal something about it, for the follwoing reason: The data points are sampled from the manifold. In the limit of infinitely many data points, the graph Laplacian matrix can be shown to converge to the manifold’s Laplace-Betrami operator.\nThere are, of course, many choices on how to put weights on the neighborhood graph. We try out one popular approach in the following.\n\n\nNeighborhood graph with Gaussian weights\nWe use a Gaussian distance kernel to obtain edge weights, i.e., for the edge from cell (vertex) \\(i\\) to cell \\(j\\), we chose \\[ a_{ij} = \\exp\\left(-\\frac{d_{ij}^2}{\\sigma_{ij}^2}\\right),\\] where \\(d_{ij}\\) is the distance between cells \\(i\\) and \\(j\\) in feature space and \\(\\sigma_{ij}\\) is a suitable kernel width.\nFor this to be a neighborhood graph’s adjacency matrix, we set \\(a_{ij}=0\\) if \\(i\\) and \\(j\\) are not neighbors. To make this concrete, we work with \\(k\\) nearest neighbors and consider two cells neighbors if at least on of them is among the other’s \\(k\\) nearest neighbors.\nAs we did for smoothing, we might chose that width in an “adaptive” manner, adaptiong to local density. An easy way to do so is to choose as kernel width, \\(\\signa_i\\), for cell \\(i\\) the cell’s distance to its \\(k'\\)-th neighbor, using some \\(k'&lt;k\\).\nIn order to make the adjancy matrix symmetric, Zelnik-Manor and Perona (2003) suggest to let \\(\\sigma_{ij}^2=\\sigma_i\\sigma_j\\), i.e., we set the squared kernel width used when calculating the weight for the edge from cell \\(i\\) to cell \\(j\\) to the product of the distances of both cells’ respective \\(k'\\)-th nearest neighbor.\n\n\nCalculating the neighborhood graph\nWe get for each cell its \\(k=50\\) nearest neighbors:\n\nFNN::get.knn( Embeddings(seul,\"pca\"), k=50 ) -&gt; nn\n\nWe set \\(k'=20\\) and hence take the \\(sigma_i\\) from the 20th column of the NN distance table.\n\nsigma &lt;- nn$nn.dist[,20]\n\nNow, we obtain the adjacency matrix as follows:\n\nFor each \\(i\\) from 1 to \\(k\\), make a list of edges, namely from each cell \\(j\\) to its \\(i\\)-th neighbor \\(j_i\\), setting the edge weight to \\(\\exp(-d(j,j_i)^2/(\\sigma(j)\\sigma{j_i}))\\), where \\(d(j,j')\\) is the distance of from cell \\(j\\) to its \\(i\\)-th neighbor and \\(\\sigma(j)\\) is the distance of cell \\(j\\) to its \\(k'\\)-th neighbor.\nWe concatenate these edge lists to one long one.\nThen, to properly symmetrize the matrix, we proceed as follows:\n\nFor each edge, we sort the cell indices, such that the “left” index is the numerically smaller and the “right” index is the larger one.\nIf two cells are mutual nearest neighbors, their edge appears twice (first with swapped indices, now with the same indices). We only keep one. Note that we should only check the vertex indices for equality, not the weights, to avoid falling for numerical inaccuricies (as floating point multiplication is not exactly commutative).\nWe pass the edgelist to the sparseMatrix function to form a sparse matrix. We request a symmetric matrix, causing the function to add the missing lower triangular part.\n\n\n\nHere is the code:\n\nncells &lt;- nrow(nn$nn.index)\n\nmap_dfr( 1:ncol(nn$nn.index), function(i) \n  tibble( \n    cell1 = 1:ncells, \n    cell2 = nn$nn.index[,i], \n    weight = exp( - nn$nn.dist[,i]^2 / ( sigma * sigma[nn$nn.index[,i]] ) ) ) ) %&gt;%\nmutate( \n  left = pmin( cell1, cell2 ),\n  right = pmax( cell1, cell2 ) ) %&gt;%\narrange( left, right ) %&gt;%\nselect( left, right, weight ) %&gt;%\ndistinct( left, right, .keep_all=TRUE ) %&gt;%\n{ sparseMatrix( i=.$left, j=.$right, x=.$weight, \n    symmetric=TRUE, dims=c(ncells,ncells) ) } -&gt; adjm\n\nWriting \\(A\\) for this adjacency matrix and \\(D\\) for the diagonal matrix of vertex degrees (\\(D_{ij}=\\delta_{ij}\\sum_{j'}A_{ij'}\\)), we obtain the scaled graph Laplacian as \\(L = I - D^{-1/2} A D^{-1/2}\\).\nWe get the smallest (by magnitude) eigenvalues and their eigenvectors.\n\ninvsqrtdegdiag &lt;- sparseMatrix( i=1:ncells, j=1:ncells, x=1/sqrt(rowSums(adjm)), symmetric=TRUE )\n\nscaled_laplacian &lt;- sparseMatrix( i=1:ncells, j=1:ncells, x=1, symmetric=TRUE ) - \n  invsqrtdegdiag %*% adjm %*% invsqrtdegdiag\n\nRSpectra::eigs_sym( scaled_laplacian, 5, which=\"SM\" ) -&gt; eig\n\nThe smallest eigenvalue is, as expected, 0:\n\neig$values\n\n[1] 6.819817e-03 2.641315e-03 2.175909e-03 4.455835e-04 4.656835e-16\n\n\nHere is a plot of the data points, using as 2D coordinates the eigenvectors corresponding to the two smallest non-zero eigenvalues. We colour by Leiden cluster.\n\nas_tibble(eig$vectors) %&gt;%\nadd_column( cluster=seul$seurat_clusters) %&gt;%\nggplot +\n  geom_point( aes( x=V4, y=V3, col=cluster), size=.1 ) + coord_equal()\n\nWarning: The `x` argument of `as_tibble.matrix()` must have unique column names if\n`.name_repair` is omitted as of tibble 2.0.0.\nℹ Using compatibility `.name_repair`.\n\n\n\n\n\nFor comparison, the UMAP, with the same colouring:\n\nEmbeddings(seul,\"umap\") %&gt;%\nas_tibble() %&gt;%\nadd_column( cluster=seul$seurat_clusters) %&gt;%\nggplot +\n  geom_point( aes( x=umap_1, y=umap_2, col=cluster), size=.1 ) + coord_equal()\n\n\n\n\n\n\nSwiss roll\nTo make a Swiss role, prepare a biscuit batter and bake it in a tray to obtain a spongy rectangular biscuit cake. Put a layer of jam, then a thick layer of cream on top, the roll up the layered cake.\nThe Swiss role has inspired a standard “test manifold” to study dimension reduction:\nFirst, we sample point from a 2D rectangle:\n\nset.seed( 1324 )\nn &lt;- 10000\n\nx0 &lt;- runif( n, 0, 50 )\ny0 &lt;- runif( n, 0, 6*pi )\n\nNow, roll up the rectangle, using \\(y_0\\) both as rolling angle and as radius. For the radius, add some noise to make the biscuit fluffy.\n\nr &lt;- y0 + runif( n, 0, 1 )\n\ncbind(\n  x0,\n  r * cos( y0 ),\n  r * sin( y0 ) ) -&gt; x3\n\nHere’s a plot of the roll, looking head-on:\n\nplot( x3[,2], x3[,3], cex=.1, asp=1 )\n\n\n\n\nand from the side:\n\nplot( x3[,1], x3[,2], cex=.1, asp=1 )\n\n\n\n\nNow, let’s embed this 3D object into a 7D space, by chosing three random but orthonormal basis vectors. To do so, we chose three random vectors\n\nrandom_vecs &lt;- matrix( rnorm(21), nrow = 7, ncol = 3 )\n\nthen orthogonalize them using QR decomposition (which is essentially a sophisticated variant of Gram-Schmidt)\n\nrandom_orthonormal_basis &lt;- qr.Q( qr( random_vecs ) )\n\nNow, let’s\n\nx3 %*% t(random_orthonormal_basis) -&gt; x\n\nhead(x)\n\n            [,1]       [,2]      [,3]       [,4]      [,5]      [,6]      [,7]\n[1,]   0.4144157  -8.778192 0.3285658  4.7389610 -5.612610 -4.126349  4.567517\n[2,]  -6.8567192 -20.994387 7.1659708 -0.1867122 12.491133 17.531947 -3.382384\n[3,] -15.0072735 -33.209732 8.2908585 14.7320429 15.170257 21.642549 -1.562077\n[4,] -12.0583660 -44.033499 8.4152476 18.5598476  5.050857 13.500057  5.503569\n[5,]   3.6573425  -7.930982 2.6781130 -7.5061441 -1.509872  1.010143  1.174632\n[6,]  -8.1042127 -28.569759 5.3217416 12.8346638  3.158864  8.563515  3.707611\n\n\nCan we recover the initial 2D sheet (x0, y0) using eigenmaps?\n\nFNN::get.knn( x, k=30 ) -&gt; nn\n\nnn$nn.dist[,18] -&gt; sigma\n\nmap_dfr( 1:ncol(nn$nn.index), function(i) \n  tibble( \n    cell1 = 1:n, \n    cell2 = nn$nn.index[,i], \n    weight = exp( - nn$nn.dist[,i]^2 / ( sigma * sigma[nn$nn.index[,i]] ) ) ) ) %&gt;%\nmutate( \n  left = pmin( cell1, cell2 ),\n  right = pmax( cell1, cell2 ) ) %&gt;%\narrange( left, right ) %&gt;%\nselect( left, right, weight ) %&gt;%\ndistinct( left, right, .keep_all=TRUE ) %&gt;%\n{ sparseMatrix( i=.$left, j=.$right, x=.$weight, \n    symmetric=TRUE, dims=c(n,n) ) } -&gt; adjm\n\ninvsqrtdegdiag &lt;- sparseMatrix( i=1:n, j=1:n, x=1/sqrt(rowSums(adjm)), symmetric=TRUE )\n\nscaled_laplacian &lt;- sparseMatrix( i=1:n, j=1:n, x=1, symmetric=TRUE ) - \n  invsqrtdegdiag %*% adjm %*% invsqrtdegdiag\n\nRSpectra::eigs_sym( scaled_laplacian, 5, which=\"SM\" ) -&gt; eig\n\neig$values\n\n[1]  2.495667e-03  1.544439e-03  1.290361e-03  2.784866e-04 -3.108038e-15\n\n\nThe eigenmap, coloured by y0:\n\nas_tibble(eig$vectors) %&gt;%\nadd_column( x0, y0 ) %&gt;%\nggplot +\n  geom_point( aes( x=V4, y=V3, col=y0), size=.1 ) + coord_equal()\n\n\n\n\nThe eigenmap, coloured by x0:\n\nas_tibble(eig$vectors) %&gt;%\nadd_column( x0, y0 ) %&gt;%\nggplot +\n  geom_point( aes( x=V4, y=V3, col=x0), size=.1 ) + coord_equal()\n\n\n\n\nHow does UMAP fare?\n\nuwot::umap(x) -&gt; ump\n\nColour by x0:\n\nas_tibble(ump) %&gt;%\nadd_column( x0, y0 ) %&gt;%\nggplot +\n  geom_point( aes( x=V1, y=V2, col=x0), size=.1 ) + coord_equal()\n\n\n\n\nand by y0:\n\nas_tibble(ump) %&gt;%\nadd_column( x0, y0 ) %&gt;%\nggplot +\n  geom_point( aes( x=V1, y=V2, col=y0), size=.1 ) + coord_equal()"
  },
  {
    "objectID": "seurat.html",
    "href": "seurat.html",
    "title": "A simple analysis with Seurat",
    "section": "",
    "text": "Seurat\nTo get a first feel for single-cell RNA-Seq data, we will perform a simple standard analysis using Seurat, an R package offering comprehensive functionality to analyse such data. Seurat has been developed by Rahul Satija and his research group at New York University and is described in multiple publications. The package is named for French pointilist painter Georges Seurat. The web site for Seurat is here.\nWe load the package in R. We will also need the Matrix package and the magrittr package.\n\nsuppressPackageStartupMessages({\n  library( Seurat )\n  library( Matrix )\n  library( magrittr ) })\n\n\n\nFirst example data: PBMCs\nOur first example data set is a single-cell RNA-Seq data set produced by 10X (the manufacturer of the leading microfluidics platform for single-cell sequencing) to demonstrate their product.\nThey took a sample of peripheral blood (i.e., blood taken from a vein) of a human donor and removed all red blood cells and platelets (which both have no nucleus) and all white blood cells with multiple nuclei, leaving us only those types of white blood cells that have a single nucleus, i.e., with “peripheral-blood mononuclear cells”: PBMC.\nA count matrix has been obtained from the sequencing reads, using 10X’s “Cellranger” software. The matrix is available from teh 10X web site, here.\nThe matrix is provided in 10X’s own format. Seurat has a function to load this:\n\ncount_matrix &lt;- Read10X( \"data/pbmc3k/filtered_gene_bc_matrices/hg19/\" )\n\n\nFirst look at the count matrix\nThe matrix is provided as a sparse matrix (as defined in the Matrix package):\n\nclass( count_matrix )\n\n[1] \"dgCMatrix\"\nattr(,\"package\")\n[1] \"Matrix\"\n\n\nSpecifically, it is a column-sparse matrix (one of three standard storage formats for sparse matrices).\nLet’s have a look at the top left corner of the matrix\n\ncount_matrix[ 1:10, 1:10 ]\n\n10 x 10 sparse Matrix of class \"dgCMatrix\"\n\n\n  [[ suppressing 10 column names 'AAACATACAACCAC-1', 'AAACATTGAGCTAC-1', 'AAACATTGATCAGC-1' ... ]]\n\n\n                                 \nMIR1302-10    . . . . . . . . . .\nFAM138A       . . . . . . . . . .\nOR4F5         . . . . . . . . . .\nRP11-34P13.7  . . . . . . . . . .\nRP11-34P13.8  . . . . . . . . . .\nAL627309.1    . . . . . . . . . .\nRP11-34P13.14 . . . . . . . . . .\nRP11-34P13.9  . . . . . . . . . .\nAP006222.2    . . . . . . . . . .\nRP4-669L17.10 . . . . . . . . . .\n\n\nAll entiries are zero (denoted as dot).\nWe have rows for the genes and columns for the cell barcodes:\n\ndim( count_matrix )\n\n[1] 32738  2700\n\n\nThe rows are labelled with gene symbols:\n\nrownames(count_matrix) %&gt;% head(20)\n\n [1] \"MIR1302-10\"    \"FAM138A\"       \"OR4F5\"         \"RP11-34P13.7\" \n [5] \"RP11-34P13.8\"  \"AL627309.1\"    \"RP11-34P13.14\" \"RP11-34P13.9\" \n [9] \"AP006222.2\"    \"RP4-669L17.10\" \"OR4F29\"        \"RP4-669L17.2\" \n[13] \"RP5-857K21.15\" \"RP5-857K21.1\"  \"RP5-857K21.2\"  \"RP5-857K21.3\" \n[17] \"RP5-857K21.4\"  \"RP5-857K21.5\"  \"OR4F16\"        \"RP11-206L10.3\"\n\n\nThe columns are labelled with cell barcodes:\n\ncolnames(count_matrix) %&gt;% head(20)\n\n [1] \"AAACATACAACCAC-1\" \"AAACATTGAGCTAC-1\" \"AAACATTGATCAGC-1\" \"AAACCGTGCTTCCG-1\"\n [5] \"AAACCGTGTATGCG-1\" \"AAACGCACTGGTAC-1\" \"AAACGCTGACCAGT-1\" \"AAACGCTGGTTCTT-1\"\n [9] \"AAACGCTGTAGCCA-1\" \"AAACGCTGTTTCTG-1\" \"AAACTTGAAAAACG-1\" \"AAACTTGATCCAGA-1\"\n[13] \"AAAGAGACGAGATA-1\" \"AAAGAGACGCGAGA-1\" \"AAAGAGACGGACTT-1\" \"AAAGAGACGGCATT-1\"\n[17] \"AAAGATCTGGGCAA-1\" \"AAAGCAGAAGCCAT-1\" \"AAAGCAGATATCGG-1\" \"AAAGCCTGTATGCG-1\"\n\n\nThe column sums of the matrix tell us how many reads we got per cell:\n\ncolSums(count_matrix) %&gt;% head(20)\n\nAAACATACAACCAC-1 AAACATTGAGCTAC-1 AAACATTGATCAGC-1 AAACCGTGCTTCCG-1 \n            2421             4903             3149             2639 \nAAACCGTGTATGCG-1 AAACGCACTGGTAC-1 AAACGCTGACCAGT-1 AAACGCTGGTTCTT-1 \n             981             2164             2176             2260 \nAAACGCTGTAGCCA-1 AAACGCTGTTTCTG-1 AAACTTGAAAAACG-1 AAACTTGATCCAGA-1 \n            1276             1103             3918             2392 \nAAAGAGACGAGATA-1 AAAGAGACGCGAGA-1 AAAGAGACGGACTT-1 AAAGAGACGGCATT-1 \n            2412             3034             1152              792 \nAAAGATCTGGGCAA-1 AAAGCAGAAGCCAT-1 AAAGCAGATATCGG-1 AAAGCCTGTATGCG-1 \n            1348             1158             4586             2929 \n\n\nHere is a histogram of the total read counts per cell, on a log10 scale\n\ncolSums(count_matrix) %&gt;% log10() %&gt;% hist() \n\n\n\n\nLet’s pick an arbitrary cell and ask what genes were expressed in this cell:\n\ncell &lt;- 1423\ncount_matrix[ , cell ] %&gt;% sort(decreasing=TRUE) %&gt;% head(50)\n\n     B2M   MALAT1   TMSB4X    RPL11    RPS18    RPL13    RPL10   RPL18A \n      72       65       46       25       23       20       19       19 \n  RPL13A   MT-CO1    RPS12   RPL23A     RPL3    RPS14     RPS6  PTPRCAP \n      19       19       18       18       18       17       17       17 \n    RPS3     RPS2   RPS15A   EEF1A1     RPL7    RPL19    RPL28     RPL9 \n      17       17       17       16       16       16       16       15 \n   RPS27    RPL32    RPS23    RPL15 HLA-DPB1     RPL6    RPL21     ACTB \n      14       14       14       13       13       13       13       12 \n    NKG7     RPS8    HLA-C    RPL12    RPLP1   RPS27A    RPL31    RPL34 \n      12       11       11       11       11       10       10       10 \n   RPS3A    RPS20    RPLP2     CCL5    RPS15    RPL36   MT-CO2     RPS7 \n      10       10       10       10       10        9        9        8 \n  RPL35A    RPS4X \n       8        8 \n\n\nWe can also ask how often each value appears:\n\ntable( count_matrix[ , cell] )\n\n\n    0     1     2     3     4     5     6     7     8     9    10    11    12 \n31919   594    89    30    12    10    15    11    11     2     8     4     2 \n   13    14    15    16    17    18    19    20    23    25    46    65    72 \n    4     3     1     4     6     3     4     1     1     1     1     1     1 \n\n\nWhat are the most strongly expressed genes? Let’s average over all cells:\n\nrowMeans(count_matrix) %&gt;% sort(decreasing=TRUE) %&gt;% head(30)\n\n  MALAT1   TMSB4X      B2M    RPL10    RPL13   RPL13A      FTL     RPS2 \n59.88333 46.00370 44.94926 32.78407 28.55963 28.46037 27.66741 24.13148 \n    RPS6     FTH1    RPS18    RPL11    RPL32     RPS3    RPL19    RPS12 \n23.16519 21.23741 20.52333 19.12370 19.10815 18.89815 18.15852 17.87259 \n   RPLP1     ACTB     RPL3    RPS27    RPS19    RPS14   EEF1A1   RPL18A \n17.57407 17.54185 17.48593 16.70148 16.24370 16.04000 15.52000 15.17741 \n  MT-CO1    RPL28   TMSB10    RPS4X    RPLP2    RPL21 \n14.51519 14.30741 13.81704 13.76704 13.21630 12.96333 \n\n\nHow similar are two arbitrarily picked cells?\n\ncell1 &lt;- 1352\ncell2 &lt;- 762\n\nplot( \n  jitter( count_matrix[,cell1] + 1 ), \n  jitter( count_matrix[,cell2] + 1), \n  cex=.3, log=\"xy\" )\n\n\n\n\n\n\n\nAnalysis with Seurat\n\ncount_matrix %&gt;%\nCreateSeuratObject() %&gt;%\nNormalizeData() %&gt;%\nFindVariableFeatures() %&gt;%\nScaleData() %&gt;%\nRunPCA( npcs=20 ) %&gt;%\nFindNeighbors( dims=1:20 ) %&gt;%\nFindClusters( resolution=0.5 ) %&gt;%\nRunUMAP( dims=1:20 ) -&gt; seu\n\nWarning: Feature names cannot have underscores ('_'), replacing with dashes\n('-')\n\n\nNormalizing layer: counts\n\n\nFinding variable features for layer counts\n\n\nCentering and scaling data matrix\n\n\nPC_ 1 \nPositive:  CST3, TYROBP, LST1, AIF1, FTL, FCN1, LYZ, FTH1, S100A9, FCER1G \n       TYMP, CFD, LGALS1, S100A8, CTSS, LGALS2, SERPINA1, SPI1, IFITM3, PSAP \n       CFP, SAT1, IFI30, COTL1, S100A11, NPC2, LGALS3, GSTP1, PYCARD, NCF2 \nNegative:  MALAT1, LTB, IL32, CD2, ACAP1, STK17A, CTSW, CD247, CCL5, GIMAP5 \n       AQP3, GZMA, CST7, TRAF3IP3, MAL, HOPX, ITM2A, GZMK, MYC, GIMAP7 \n       BEX2, ETS1, LDLRAP1, ZAP70, LYAR, RIC3, TNFAIP8, NKG7, KLRG1, SAMD3 \nPC_ 2 \nPositive:  NKG7, PRF1, CST7, GZMA, GZMB, FGFBP2, CTSW, GNLY, GZMH, SPON2 \n       CCL4, FCGR3A, CCL5, CD247, XCL2, CLIC3, AKR1C3, SRGN, HOPX, CTSC \n       TTC38, S100A4, ANXA1, IL32, IGFBP7, ID2, ACTB, XCL1, APOBEC3G, SAMD3 \nNegative:  CD79A, MS4A1, TCL1A, HLA-DQA1, HLA-DRA, HLA-DQB1, LINC00926, CD79B, HLA-DRB1, CD74 \n       HLA-DPB1, HLA-DMA, HLA-DQA2, HLA-DRB5, HLA-DPA1, HLA-DMB, FCRLA, HVCN1, LTB, BLNK \n       KIAA0125, P2RX5, IRF8, IGLL5, SWAP70, ARHGAP24, SMIM14, PPP1R14A, FCRL2, C16orf74 \nPC_ 3 \nPositive:  PPBP, PF4, SDPR, SPARC, GNG11, NRGN, GP9, RGS18, TUBB1, CLU \n       HIST1H2AC, AP001189.4, ITGA2B, CD9, TMEM40, CA2, PTCRA, ACRBP, MMD, NGFRAP1 \n       TREML1, F13A1, RUFY1, SEPT5, MPP1, TSC22D1, CMTM5, RP11-367G6.3, MYL9, GP1BA \nNegative:  HLA-DQA1, CD79A, CD79B, HLA-DQB1, HLA-DPB1, CD74, HLA-DPA1, MS4A1, HLA-DRB1, HLA-DRB5 \n       HLA-DRA, HLA-DQA2, TCL1A, LINC00926, HLA-DMB, HLA-DMA, HVCN1, FCRLA, IRF8, BLNK \n       KIAA0125, SMIM14, PLD4, P2RX5, IGLL5, SWAP70, LAT2, TMSB10, IGJ, MZB1 \nPC_ 4 \nPositive:  HLA-DQA1, HIST1H2AC, PF4, CD79A, SDPR, CD79B, PPBP, GNG11, HLA-DQB1, SPARC \n       MS4A1, CD74, GP9, HLA-DPB1, RGS18, NRGN, PTCRA, CD9, HLA-DQA2, AP001189.4 \n       CLU, TUBB1, CA2, HLA-DRB1, HLA-DPA1, ITGA2B, HLA-DRA, TCL1A, TMEM40, ACRBP \nNegative:  VIM, S100A8, S100A6, S100A4, TMSB10, S100A9, IL32, GIMAP7, S100A10, LGALS2 \n       RBP7, MAL, FCN1, LYZ, CD2, S100A12, MS4A6A, FYB, S100A11, AQP3 \n       GIMAP4, FOLR3, ANXA1, MALAT1, AIF1, GIMAP5, IL8, IFI6, TRABD2A, ASGR1 \nPC_ 5 \nPositive:  GZMB, FGFBP2, NKG7, GNLY, PRF1, CCL4, CST7, SPON2, GZMA, GZMH \n       CLIC3, XCL2, CTSW, TTC38, AKR1C3, CCL5, IGFBP7, XCL1, S100A8, CCL3 \n       TYROBP, HOPX, CD160, HAVCR2, S100A9, FCER1G, PTGDR, LGALS2, RBP7, S100A12 \nNegative:  LTB, VIM, AQP3, PPA1, MAL, KIAA0101, CD2, CORO1B, CYTIP, FYB \n       IL32, TRADD, ANXA5, TUBA1B, HN1, PTGES3, TYMS, ITM2A, COTL1, GPR183 \n       ACTG1, TNFAIP8, ATP5C1, TRAF3IP3, GIMAP4, PRDX1, ZWINT, ABRACL, NGFRAP1, LDLRAP1 \n\n\nComputing nearest neighbor graph\n\n\nComputing SNN\n\n\nModularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck\n\nNumber of nodes: 2700\nNumber of edges: 120276\n\nRunning Louvain algorithm...\nMaximum modularity in 10 random starts: 0.8640\nNumber of communities: 8\nElapsed time: 0 seconds\n\n\nWarning: The default method for RunUMAP has changed from calling Python UMAP via reticulate to the R-native UWOT using the cosine metric\nTo use Python UMAP via reticulate, set umap.method to 'umap-learn' and metric to 'correlation'\nThis message will be shown once per session\n\n\n15:17:26 UMAP embedding parameters a = 0.9922 b = 1.112\n\n\n15:17:26 Read 2700 rows and found 20 numeric columns\n\n\n15:17:26 Using Annoy for neighbor search, n_neighbors = 30\n\n\n15:17:26 Building Annoy index with metric = cosine, n_trees = 50\n\n\n0%   10   20   30   40   50   60   70   80   90   100%\n\n\n[----|----|----|----|----|----|----|----|----|----|\n\n\n**************************************************|\n15:17:26 Writing NN index file to temp file /tmp/RtmpPldfRL/file6aee1ff81808\n15:17:26 Searching Annoy index using 1 thread, search_k = 3000\n15:17:27 Annoy recall = 100%\n15:17:27 Commencing smooth kNN distance calibration using 1 thread with target n_neighbors = 30\n15:17:28 Initializing from normalized Laplacian + noise (using RSpectra)\n15:17:28 Commencing optimization for 500 epochs, with 111204 positive edges\n15:17:31 Optimization finished\n\n\n\nUMAPPlot( seu ) + ggplot2::coord_equal()\n\n\n\n\nIn this plot, each cell is represented by a point in a so-called dimension-reduced embedding. This means that the points have been arranged such that cells that are similar appear close to each other while cells that are very different are put far apart from each other.\nWe will discuss soon in detail how such dimension reduction works and, importantly, what is meant by “similar”.\nSeurat has also run a “clustering” algorithm that assigns the cells to different “clusters” of cells that are similar to each other. Colours are used here to indicate cluster membership.\nWe observe that the cells fall into three big groups that each split into a number of smaller clusters.\n\nIdentifying cell types\nWe suspect that these represent different types of white blood cells. There should be B-cells, T-cells and perhaps monocytes.\nT cells are defined as white blood cells that show a the T-cell receptor as their surface, a protein complex made up of various proteins, one of which is called the T-cell receptor epsilon chain. This protein is described for the gene CD3E. We can ask Seurat to indicate the read counts for this gene in the UMAP plot:\n\nFeaturePlot( seu, \"CD3E\")\n\n\n\n\nWe conclede that clusters 0 and 3 are probably the T cells.\nWe can also colour for CD79A, a marker for B cells:\n\nFeaturePlot( seu, \"CD79A\")\n\n\n\n\nTo find out what the group to the left is, we can go another way. Let’s ask Seurat to find genes that are expressed much mroe strongly in clusters 1 and 4 than in clusters 0, 2, 3, 5:\n\nFindMarkers( seu, ident.1=c(1,4), ident.2=c(0,2,3,5), test.use=\"t\" ) -&gt; m\nhead( m, 50 )\n\n                 p_val avg_log2FC pct.1 pct.2     p_val_adj\nLST1      0.000000e+00  5.2602174 0.969 0.147  0.000000e+00\nCST3      0.000000e+00  5.6816322 0.994 0.193  0.000000e+00\nTYROBP    0.000000e+00  4.5599105 0.995 0.194  0.000000e+00\nFCER1G    0.000000e+00  3.9303734 0.953 0.153  0.000000e+00\nAIF1      0.000000e+00  4.8394973 0.968 0.171  0.000000e+00\nPTPRCAP   0.000000e+00 -4.3390790 0.123 0.820  0.000000e+00\nLGALS1    0.000000e+00  3.5888431 0.982 0.303  0.000000e+00\nCTSS      0.000000e+00  3.3704116 0.956 0.370  0.000000e+00\nIL32      0.000000e+00 -4.5060681 0.123 0.703  0.000000e+00\nS100A11   0.000000e+00  2.9021375 0.959 0.381  0.000000e+00\nLYZ       0.000000e+00  5.5523830 0.995 0.471  0.000000e+00\nSAT1      0.000000e+00  3.1880331 0.972 0.454  0.000000e+00\nCOTL1     0.000000e+00  2.9140976 0.974 0.505  0.000000e+00\nS100A6    0.000000e+00  2.4265040 0.992 0.712  0.000000e+00\nS100A4    0.000000e+00  2.1051825 1.000 0.752  0.000000e+00\nOAZ1      0.000000e+00  1.9165328 0.995 0.877  0.000000e+00\nFTL       0.000000e+00  3.6241681 1.000 0.983  0.000000e+00\nFTH1      0.000000e+00  3.1675076 1.000 0.984  0.000000e+00\nCD3D     4.886112e-319 -4.3674643 0.092 0.670 1.599615e-314\nTYMP     3.882155e-306  4.2566370 0.926 0.151 1.270940e-301\nS100A9   1.783818e-297  7.0670428 0.962 0.154 5.839865e-293\nPSAP     1.902707e-294  2.9956639 0.934 0.359 6.229083e-290\nFCN1     9.535250e-274  5.5804410 0.896 0.092 3.121650e-269\nCYBA     8.453508e-272  1.5333488 0.991 0.797 2.767510e-267\nMALAT1   1.181579e-262 -1.5311747 1.000 1.000 3.868252e-258\nLTB      4.335583e-260 -3.5012014 0.348 0.824 1.419383e-255\nNPC2     1.360721e-240  3.2405179 0.896 0.252 4.454729e-236\nCD3E     8.066458e-236 -3.7395374 0.104 0.612 2.640797e-231\nCFD      7.012340e-210  5.9290434 0.822 0.036 2.295700e-205\nS100A8   1.234624e-205  7.2702939 0.855 0.084 4.041912e-201\nHLA-DRA  9.958375e-200  0.9548420 0.945 0.423 3.260173e-195\nGABARAP  3.036143e-190  2.4215683 0.881 0.351 9.939724e-186\nCD7      2.761808e-188 -4.2406042 0.058 0.475 9.041608e-184\nGSTP1    8.906341e-186  2.9200924 0.877 0.315 2.915758e-181\nRPS27    6.463844e-178 -1.2827741 0.988 0.998 2.116133e-173\nCD68     5.216417e-175  5.1623519 0.757 0.039 1.707751e-170\nGPX1     2.638599e-174  3.1465728 0.853 0.267 8.638245e-170\nSERPINA1 5.945946e-174  4.6390651 0.770 0.069 1.946584e-169\nLCK      2.819845e-170 -3.6083579 0.058 0.464 9.231609e-166\nNEAT1    1.968831e-169  1.8285530 0.928 0.540 6.445560e-165\nRPL3     5.794248e-169 -1.1390928 0.994 0.999 1.896921e-164\nPYCARD   8.652551e-167  2.7349426 0.824 0.215 2.832672e-162\nLGALS2   4.290216e-165  6.6287302 0.743 0.029 1.404531e-160\nRPL13A   9.270560e-165 -0.8866787 1.000 1.000 3.034996e-160\nRPS27A   2.750106e-158 -1.7498987 0.911 0.996 9.003298e-154\nCD2      8.578003e-155 -4.2838412 0.052 0.407 2.808267e-150\nRAC1     1.921305e-154  2.2617174 0.845 0.294 6.289968e-150\nCXCR4    2.275604e-153 -2.6822981 0.285 0.701 7.449873e-149\nRPL23A   2.157301e-152 -1.2329204 0.980 0.997 7.062571e-148\nTKT      2.978425e-152  2.8123604 0.793 0.200 9.750769e-148\n\n\nFrom this list, an immunologist would quickly see that these cells are monocytes.\n\n\nBack to math\nWhat is happening inside Seurat.\nA few questions we might have:\n\nHow do we define “similarity” of cells?\nEach cell is represented by a vector of count values. Can we simply define a metric or distance measure in that space to quantify similarity?\nIt will turn out that this does not work, due to the counting noise. Why?\nHow can we make cells with differing total read count comparable?\nWe will overcome the count-noise issue by performing a principal component analysis (a matrix decomposition based on the eigendecomposition). Why does that work?\nThe cells seem to be living in a high-dimensional space. Can this really be faithfully shown by a two-dimensional plot? How do we check the faithfulness? Here, we will get into a rabbit hole involving multi-variate optimization, metrics in distribution spaces, interactive visualizations and maybe GPU programming.\nHow to suitable define “clusters” of similar cells? This will lead us to applications of graph theory.\n\n\n\nThe manifold hypothesis\nA teaser to the core idea in single-cell analysis:\nCells “live” in a “state space” that is spanned by all the possible configurations of the cells in the organism. When a cell reacts to a stimulus or changes its state for another reason, this will be a continuous (maybe even smooth?) move in this statespace.\nHowever, we cannot observe the state space directly – but we assume that each state is associated with a transcriptome, i.e., a measure or distribution in the space of read count vectors spanned by the genes (i.e., of possible columns in the count matrix).\nWe assume that the distribution of the cells in our sample lives on a manifold in state space, and we wish to learn first the topology of this manifold, then gain a metric and an atlas for it, then infer the distribution/measure on this manifold, from which our cells have been sampled. And finally, we have to translate this mathematical description into a biological insights."
  },
  {
    "objectID": "cell_cycle.html",
    "href": "cell_cycle.html",
    "title": "Regressing out the cell cycle",
    "section": "",
    "text": "This document contains unfinished notes on that topic.\n\nExample data\nWe use the usual IFNAGRKO example data set\n\nsuppressPackageStartupMessages({\n  library( tidyverse )\n  library( Matrix )\n  library( sparseMatrixStats )\n  library( Seurat ) })\n\nReadMtx( \"~/Downloads/ifnagrko/ifnagrko_raw_counts.mtx.gz\",\n    \"~/Downloads/ifnagrko/ifnagrko_obs.csv\",\n    \"~/Downloads/ifnagrko/ifnagrko_var.csv\",\n    cell.sep=\",\", feature.sep=\",\", skip.cell=1, skip.feature=1, \n    mtx.transpose=TRUE) -&gt; count_matrix\n\ncount_matrix %&gt;%\nCreateSeuratObject() %&gt;%\nNormalizeData() %&gt;%\nFindVariableFeatures() %&gt;%\nScaleData() %&gt;%\nRunPCA( npcs=20 ) %&gt;%\nFindNeighbors( dims=1:20 ) %&gt;%\nFindClusters( resolution=0.5 ) %&gt;%\nRunUMAP( dims=1:20 ) -&gt; seu\n\nWarning: Feature names cannot have underscores ('_'), replacing with dashes\n('-')\n\n\nNormalizing layer: counts\n\n\nFinding variable features for layer counts\n\n\nCentering and scaling data matrix\n\n\nPC_ 1 \nPositive:  Apoe, Aldoc, Sparcl1, Sdc4, Ptn, Cmtm5, Glul, Gpr37l1, Fxyd1, Atp1b2 \n       S100a1, Slc4a4, Slc1a3, Prxl2a, F3, Itm2b, Mt1, Rgcc, Prdx6, Sfxn5 \n       Sat1, Scrg1, Dbi, Hes5, Luzp2, Plaat3, Pla2g7, Sash1, Plpp3, Sparc \nNegative:  Tubb5, Sox11, Tubb3, Stmn1, Jpt1, Hmgb3, Ptma, Sox4, Dlx2, Cd24a \n       Igfbpl1, Dlx6os1, Map1b, Stmn2, Abracl, Tmsb4x, Lmnb1, Cdca7, Ccnd2, Elavl4 \n       Cdk4, Dcx, Arx, Uchl1, EYFP, Celf4, Dlx5, Nrxn3, H1fx, Hmgn2 \nPC_ 2 \nPositive:  Ctss, C1qc, Laptm5, Csf1r, Trem2, C1qa, Cx3cr1, C1qb, Tyrobp, Ly86 \n       Fcer1g, Siglech, Selplg, Fcrls, Tmem119, Fcgr3, Apbb1ip, Unc93b1, Cd53, Lpcat2 \n       Spi1, Pld4, Olfml3, Irf8, Ctsh, Aif1, Cd300c2, Fyb, Otulinl, Mylip \nNegative:  Rorb, Cldn10, Clu, Mt3, Ntsr2, Mfge8, S1pr1, Id4, Slc1a2, Acsl6 \n       Plpp3, Sox9, Ddah1, Bcan, Cxcl14, Btbd17, Mlc1, Cspg5, Fjx1, Aqp4 \n       Ntm, Acsl3, Gabrb1, Tspan7, Lsamp, Chst2, Mt2, Lhx2, Slc39a12, Glud1 \nPC_ 3 \nPositive:  Atp1a3, Camk2b, Snhg11, Syt1, Nrip3, Kcnj4, Scg2, Snap25, Dnm1, Pcp4 \n       Icam5, Ndrg4, Eef1a2, Eno2, Ano3, Ryr2, Arpp21, Ptk2b, Gng4, Kcna4 \n       Penk, Slc4a10, Snca, Gad1, Rprml, Grin2a, C1qtnf4, Shisa8, Camk2a, Kcnb2 \nNegative:  Hmgb2, Top2a, Pbk, Birc5, Mki67, Cdk1, Cdca8, Spc24, Cenpf, Spc25 \n       Prc1, Rrm2, Mdk, Nusap1, Tpx2, Cdca3, Knl1, Ckap2l, Esco2, Aurkb \n       Cenpm, Ccna2, Bub1, Cks2, Kif11, Hist1h3c, Hist1h1b, Hmmr, Pclaf, Fbxo5 \nPC_ 4 \nPositive:  C1qc, C1qa, Ctss, Trem2, Csf1r, C1qb, Cx3cr1, Laptm5, Fcer1g, Tyrobp \n       Ly86, Siglech, Selplg, Fcrls, Fcgr3, Hexb, Spi1, Cd53, Itgb5, Pld4 \n       Ptgs1, Cd300c2, Aif1, Irf8, Fyb, Itgam, Cyth4, Ltc4s, Otulinl, Cd37 \nNegative:  Frzb, Apod, Npy, Plp1, Vtn, Foxd3, Wnt6, Nr2f2, Edil3, Sox10 \n       Gsn, Matn4, Fbln2, Aspa, Aqp1, Igf1, Plat, Lpar1, Igfbp4, Erbb3 \n       Fabp7, Plppr4, Ptgds, Col23a1, Alx3, Hey2, Cd59a, Fam3c, Scd1, Mybpc1 \nPC_ 5 \nPositive:  Stmn2, Igfbpl1, Cd24a, Nrep, Sox4, Map1b, Stmn4, Tubb3, Shtn1, Dlx6os1 \n       Dcx, Ly6h, Sox11, Jpt1, Mpped2, Stmn1, Plxna4, Pbx3, Elavl4, Uchl1 \n       Runx1t1, Cald1, Foxp2, Dlx2, Gad2, Celf4, Pfn2, Dlx5, Sp8, Tubb5 \nNegative:  Top2a, Pbk, Birc5, Mki67, Spc25, Cdk1, Prc1, Nusap1, Spc24, Esco2 \n       Tpx2, Knl1, Aurkb, Cenpf, Cdca8, Ckap2l, Kif11, Cdca3, Hist1h3c, Hmmr \n       Ccna2, Bub1, Incenp, Hist1h2af, Ndc80, Cit, Fbxo5, Kif4, Sgo1, Kif22 \n\n\nComputing nearest neighbor graph\n\n\nComputing SNN\n\n\nModularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck\n\nNumber of nodes: 18302\nNumber of edges: 616069\n\nRunning Louvain algorithm...\nMaximum modularity in 10 random starts: 0.9191\nNumber of communities: 19\nElapsed time: 4 seconds\n\n\nWarning: The default method for RunUMAP has changed from calling Python UMAP via reticulate to the R-native UWOT using the cosine metric\nTo use Python UMAP via reticulate, set umap.method to 'umap-learn' and metric to 'correlation'\nThis message will be shown once per session\n\n\n12:28:16 UMAP embedding parameters a = 0.9922 b = 1.112\n\n\n12:28:16 Read 18302 rows and found 20 numeric columns\n\n\n12:28:16 Using Annoy for neighbor search, n_neighbors = 30\n\n\n12:28:16 Building Annoy index with metric = cosine, n_trees = 50\n\n\n0%   10   20   30   40   50   60   70   80   90   100%\n\n\n[----|----|----|----|----|----|----|----|----|----|\n\n\n**************************************************|\n12:28:19 Writing NN index file to temp file /tmp/RtmpxRRIdr/filedecf6daee95\n12:28:19 Searching Annoy index using 1 thread, search_k = 3000\n12:28:27 Annoy recall = 100%\n12:28:28 Commencing smooth kNN distance calibration using 1 thread with target n_neighbors = 30\n12:28:29 Initializing from normalized Laplacian + noise (using RSpectra)\n12:28:33 Commencing optimization for 200 epochs, with 776086 positive edges\n12:28:43 Optimization finished\n\nUMAPPlot( seu, label=TRUE)\n\n\n\n\n\n\nCell-cycle scores\nThe cycling cells are very different from the non-cycling cells in terms of distance in PCA space. Hence, it is often desirable to regress out the cell cycle.\nAs a first step, we should find the cycling cells and find where they are in the cell cycle.\nTo help with this, Seurat comes with two list of genes that are strongly upregulated in all cells in the S phase and in the G2/M phase of the cell cycle.\n(The cell cycle in brief: G1 phase: first growth phase, after cell division; similar to a non-cycling cell’s rest state – S phase: synthesis phase, i.e. duplicating of the DNA; G2 phase: second growth phase, in preparation for cell division; M phase: mitosis, i.e., separation of the chomosomes, followed by cell division)\nHere’s the lists:\n\ncc.genes.updated.2019\n\n$s.genes\n [1] \"MCM5\"     \"PCNA\"     \"TYMS\"     \"FEN1\"     \"MCM7\"     \"MCM4\"    \n [7] \"RRM1\"     \"UNG\"      \"GINS2\"    \"MCM6\"     \"CDCA7\"    \"DTL\"     \n[13] \"PRIM1\"    \"UHRF1\"    \"CENPU\"    \"HELLS\"    \"RFC2\"     \"POLR1B\"  \n[19] \"NASP\"     \"RAD51AP1\" \"GMNN\"     \"WDR76\"    \"SLBP\"     \"CCNE2\"   \n[25] \"UBR7\"     \"POLD3\"    \"MSH2\"     \"ATAD2\"    \"RAD51\"    \"RRM2\"    \n[31] \"CDC45\"    \"CDC6\"     \"EXO1\"     \"TIPIN\"    \"DSCC1\"    \"BLM\"     \n[37] \"CASP8AP2\" \"USP1\"     \"CLSPN\"    \"POLA1\"    \"CHAF1B\"   \"MRPL36\"  \n[43] \"E2F8\"    \n\n$g2m.genes\n [1] \"HMGB2\"   \"CDK1\"    \"NUSAP1\"  \"UBE2C\"   \"BIRC5\"   \"TPX2\"    \"TOP2A\"  \n [8] \"NDC80\"   \"CKS2\"    \"NUF2\"    \"CKS1B\"   \"MKI67\"   \"TMPO\"    \"CENPF\"  \n[15] \"TACC3\"   \"PIMREG\"  \"SMC4\"    \"CCNB2\"   \"CKAP2L\"  \"CKAP2\"   \"AURKB\"  \n[22] \"BUB1\"    \"KIF11\"   \"ANP32E\"  \"TUBB4B\"  \"GTSE1\"   \"KIF20B\"  \"HJURP\"  \n[29] \"CDCA3\"   \"JPT1\"    \"CDC20\"   \"TTK\"     \"CDC25C\"  \"KIF2C\"   \"RANGAP1\"\n[36] \"NCAPD2\"  \"DLGAP5\"  \"CDCA2\"   \"CDCA8\"   \"ECT2\"    \"KIF23\"   \"HMMR\"   \n[43] \"AURKA\"   \"PSRC1\"   \"ANLN\"    \"LBR\"     \"CKAP5\"   \"CENPE\"   \"CTCF\"   \n[50] \"NEK2\"    \"G2E3\"    \"GAS2L3\"  \"CBX5\"    \"CENPA\"  \n\n\nUnfortunately, these are human gene symbols, but we can convert them to mouse symbols via Ensembl BioMart:\n\nread_tsv( \"data/biomart_export_human_mouse.tsv\", show_col_types=FALSE ) %&gt;% \n  select( human_gene_symbol = `Gene name`, mouse_gene_symbol = `Mouse gene name` ) -&gt; human_mouse_table\n\nhuman_mouse_table %&gt;% \nfilter( human_gene_symbol %in% cc.genes.updated.2019$s.genes, !is.na(mouse_gene_symbol) ) %&gt;%\npull( mouse_gene_symbol ) %&gt;% na.omit() -&gt; mouse_cc_genes_s\n\nhuman_mouse_table %&gt;% \nfilter( human_gene_symbol %in% cc.genes.updated.2019$g2m.genes, !is.na(mouse_gene_symbol) ) %&gt;% \npull( mouse_gene_symbol ) -&gt; mouse_cc_genes_g2m\n\nmouse_cc_genes_s\n\n [1] \"Chaf1b\"   \"Rad51\"    \"Cdc45\"    \"Mcm5\"     \"Pcna\"     \"Gins2\"   \n [7] \"Cdc6\"     \"E2f8\"     \"Dscc1\"    \"Ubr7\"     \"Clspn\"    \"Wdr76\"   \n[13] \"Tyms\"     \"Usp1\"     \"Casp8ap2\" \"Pola1\"    \"Slbp\"     \"Fen1\"    \n[19] \"Dtl\"      \"Blm\"      \"Cenpu\"    \"Ccne2\"    \"Gmnn\"     \"Rfc2\"    \n[25] \"Tipin\"    \"Rrm1\"     \"Mrpl36\"   \"Hells\"    \"Mcm4\"     \"Rrm2\"    \n[31] \"Nasp\"     \"Uhrf1\"    \"Mcm7\"     \"Exo1\"     \"Rad51ap1\" \"Ung\"     \n[37] \"Prim1\"    \"Cdca7\"    \"Polr1b\"   \"Mcm6\"     \"Msh2\"    \n\nmouse_cc_genes_s\n\n [1] \"Chaf1b\"   \"Rad51\"    \"Cdc45\"    \"Mcm5\"     \"Pcna\"     \"Gins2\"   \n [7] \"Cdc6\"     \"E2f8\"     \"Dscc1\"    \"Ubr7\"     \"Clspn\"    \"Wdr76\"   \n[13] \"Tyms\"     \"Usp1\"     \"Casp8ap2\" \"Pola1\"    \"Slbp\"     \"Fen1\"    \n[19] \"Dtl\"      \"Blm\"      \"Cenpu\"    \"Ccne2\"    \"Gmnn\"     \"Rfc2\"    \n[25] \"Tipin\"    \"Rrm1\"     \"Mrpl36\"   \"Hells\"    \"Mcm4\"     \"Rrm2\"    \n[31] \"Nasp\"     \"Uhrf1\"    \"Mcm7\"     \"Exo1\"     \"Rad51ap1\" \"Ung\"     \n[37] \"Prim1\"    \"Cdca7\"    \"Polr1b\"   \"Mcm6\"     \"Msh2\"    \n\n\nWe can simply add up the expression of these genes to get for each gene two “cell-cycle scores”:\n\nseu$cc_score_s   &lt;- colSums( LayerData(seu)[ mouse_cc_genes_s, ] )\nseu$cc_score_g2m &lt;- colSums( LayerData(seu)[ mouse_cc_genes_g2m, ] )\n\nHere, we have used LayerData, which returns the log-normalized expression data, i.e. \\(y=_{ij}\\log(k_{ij}/s_j\\cdot 10^4 + 1)\\).\nHere’s a plot, using blended colour. Red channel is S score, blue channel G2M score:\n\nEmbeddings(seu, \"umap\") %&gt;%\nas_tibble( rownames=\"cell\" ) %&gt;%\nadd_column( \n  s_score   = seu$cc_score_s,\n  g2m_score = seu$cc_score_g2m ) %&gt;% \nmutate( color = rgb( \n  red   = s_score / max(s_score),   \n  green = 0,\n  blue  = g2m_score / max(g2m_score ) ) ) %&gt;%\nggplot +\n  geom_point( aes( x=umap_1, y=umap_2, col=I(color) ), size=.3 ) +\n  coord_equal()\n\n\n\n\n\n\nRegressing out the cell cycle\nNow, we redo the PCA, with the following modification. Before, we only scaled and centered the genes, now we regress out the scores.\nWe demonstrate this with one gene:\n\nfit &lt;- lm( LayerData(seu)[\"Mcm3\",] ~ seu$cc_score_s + seu$cc_score_g2m )\nfit\n\n\nCall:\nlm(formula = LayerData(seu)[\"Mcm3\", ] ~ seu$cc_score_s + seu$cc_score_g2m)\n\nCoefficients:\n     (Intercept)    seu$cc_score_s  seu$cc_score_g2m  \n       -0.098891          0.042897         -0.003337  \n\nhead(residuals(fit))\n\nAAACCCAGTCTCCTGT-WT_20mo_2021_001 AAACGAAAGGTACTGG-WT_20mo_2021_001 \n                       0.05705544                       -0.19764212 \nAAACGAACATGGCTGC-WT_20mo_2021_001 AAACGAAGTAGCTGAG-WT_20mo_2021_001 \n                       0.05853826                       -0.16804377 \nAAACGAATCACCCTCA-WT_20mo_2021_001 AAACGCTAGGGCAGGA-WT_20mo_2021_001 \n                      -0.20602886                       -0.09113674 \n\n\nHere, we have fitted, for the gene \\(i=\\text{Mcm3}}\\), the linear model \\[ y_{ij} = \\beta_0 + \\beta_\\text{S} x^\\text{S}_i + \\beta_\\text{G2M} x^\\text{G2M}_i + \\epsilon_{ij} \\] and then extracted the residuals \\(r_{ij} = \\hat y_{ij} - y_{ij}\\). As residuals, they are already centered, but still need to be divided by their standard deviation before being given to the PCA.\nWe do this for each of the highly variable genes.\nUnfortunately, this code is quite slow:\nsapply( VariableFeatures(seu), function(gene) \n  lm.fit( cbind( 1, seu$cc_score_s, seu$cc_score_g2m ), LayerData(seu)[\"Mcm3\",] )$residuals ) -&gt; residuals\nHere’s faster code, using the looped linear model solver from the limma package\n\nfit &lt;- limma::lmFit( \n  LayerData(seu)[VariableFeatures(seu),], \n  cbind( 1, seu$cc_score_s, seu$cc_score_g2m ) ) \n\nyhat &lt;- cbind( 1, seu$cc_score_s, seu$cc_score_g2m ) %*% t(fit$coefficients)\n\nresiduals &lt;- as.matrix( LayerData(seu)[VariableFeatures(seu),] - t(yhat) )\n\nNow let’s feed this to the IRLBA PCA and calculate a new UMAP:\n\npca &lt;- irlba::prcomp_irlba( t(residuals), center=FALSE, scale.=TRUE, n=20 )\n\nump &lt;- uwot::umap( pca$x )\n\nThe cell cycle is still quite prominent in the new UMAP\n\nas_tibble( ump ) %&gt;%\nmutate( cluster = seu$seurat_clusters ) %&gt;%\nggplot +\n  geom_point( aes( x=V1, y=V2, col=cluster ), size=.2 ) +\n  coord_equal()\n\nWarning: The `x` argument of `as_tibble.matrix()` must have unique column names if\n`.name_repair` is omitted as of tibble 2.0.0.\nℹ Using compatibility `.name_repair`.\n\n\n\n\n\nHowever, the PCA distances are smaller, as can be seen with Sleepwalk\n\nsleepwalk::sleepwalk( ump, pca$x )\n\n\n\nThe same with Seurat\nWe can also let Seurat do all this regressing out:\n\nseu %&gt;%\nScaleData( vars.to.regress = c(\"cc_score_s\", \"cc_score_g2m\") ) %&gt;%\nRunPCA( npcs=20 ) %&gt;%\nRunUMAP( dims=1:20 ) -&gt; seu2\n\nRegressing out cc_score_s, cc_score_g2m\n\n\nCentering and scaling data matrix\n\n\nPC_ 1 \nPositive:  Apoe, Ptn, Sdc4, Aldoc, Dbi, Glul, Sparcl1, Cmtm5, Gpr37l1, Fxyd1 \n       Slc1a3, S100a1, Atp1b2, Prdx6, Prxl2a, Ptprz1, F3, Itm2b, Mt1, Slc4a4 \n       Rgcc, Sfxn5, Scrg1, Sat1, Hes5, Plpp3, Sash1, Plaat3, Psat1, Pla2g7 \nNegative:  Dlx6os1, Tubb3, Celf4, Sox4, Map1b, Nrxn3, Stmn2, Igfbpl1, Sox11, Cd24a \n       Gad2, Dcx, Jpt1, Tubb5, Nrep, Dlx2, Stmn1, Mpped2, Stmn4, Dlx5 \n       Ptma, Hmgb3, Sp8, Uchl1, Shtn1, Elavl4, Tmsb4x, Arx, Abracl, Calm2 \nPC_ 2 \nPositive:  Clu, Rorb, Cldn10, Mt3, S1pr1, Acsl6, Ntsr2, Fjx1, Cxcl14, Ntm \n       Mfge8, Id4, Bcan, Cspg5, Slc1a2, Ddah1, Plpp3, Mlc1, Btbd17, Aqp4 \n       Sox9, Gabrb1, Tspan7, Acsl3, Chst2, Lsamp, Slc39a12, Chchd10, Slc6a1, Gpc5 \nNegative:  Lpcat2, Ctsh, Tmem119, Apbb1ip, Laptm5, Ctss, C1qc, Csf1r, Trem2, C1qa \n       Hpgd, Cx3cr1, C1qb, Tyrobp, Ly86, Fcer1g, Siglech, Selplg, Fcrls, Kctd12 \n       Unc93b1, Fcgr3, Cd53, Olfml3, Spi1, Pld4, Irf8, Aif1, Cd300c2, Fyb \nPC_ 3 \nPositive:  Plppr4, Frzb, Apod, Npy, Plp1, Vtn, Foxd3, Wnt6, Edil3, Sox10 \n       Gria3, Nr2f2, Matn4, Gsn, Cntn1, Aspa, Cpne8, Aqp1, Fbln2, Igf1 \n       Plat, Lpar1, Snhg11, Fam3c, Gucy1b1, Erbb3, Scd1, Ptgds, Col23a1, Hs3st1 \nNegative:  C1qc, C1qa, Trem2, Ctss, Csf1r, C1qb, Cx3cr1, Laptm5, Fcer1g, Tyrobp \n       Ly86, Selplg, Siglech, Fcrls, Fcgr3, Spi1, Cd53, Pld4, Hexb, Ptgs1 \n       Cd300c2, Aif1, Irf8, Fyb, Itgam, Ltc4s, Cyth4, Cd37, Itgb5, Mylip \nPC_ 4 \nPositive:  Camk2b, Atp1a3, Snhg11, Kcnj4, Scg2, Dnm1, Ptk2b, Icam5, Nrip3, Ano3 \n       Hivep2, Eno2, Camk2n1, Ryr2, Shisa8, Camk2a, Eef1a2, Kcna4, Pcp4, Penk \n       Grin2a, Rprml, Slc4a10, Epha5, Atp2b1, Cx3cl1, Snca, Rasgef1a, Pacsin1, Mef2c \nNegative:  Stmn1, Ccnd2, Cd24a, Stmn2, Igfbpl1, Jpt1, Sox11, Tubb5, Sox4, Tubb3 \n       Elavl4, Map1b, Dlx2, Uchl1, Ptma, Cdk4, Nrep, Ddah2, Tmsb4x, Abracl \n       Cald1, H2afv, Lmo4, Hmgb3, Pfn2, Cdca7, EYFP, Shtn1, Stmn4, Dlx6os1 \nPC_ 5 \nPositive:  Pllp, Ndrg1, Cldn11, Mag, Ugt8a, Ppp1r14a, Ermn, Mbp, Mog, Mobp \n       Fa2h, Mal, Slc24a2, Hapln2, Pde8a, Sept4, Gng11, Opalin, Trf, Pls1 \n       Ttll7, Pdlim2, Gjc2, Bcas1, C030029H02Rik, Tppp, Tspan2, Spock3, Myrf, 1700047M11Rik \nNegative:  Lmo4, Kctd12, Frzb, Npy, Ralgps2, Plppr4, Igf1, Aqp1, Atp1b1, Slc4a4 \n       Foxd3, Hpgd, Vtn, Mybpc1, Wnt6, Fabp7, Col23a1, Hey2, Nr2f2, Pmepa1 \n       Notch2, Igfbp4, Fbln2, Fmo1, Il13ra2, Slc43a3, Gm12688, Mdk, Rgs2, Shisa2 \n\n\nWarning: The default method for RunUMAP has changed from calling Python UMAP via reticulate to the R-native UWOT using the cosine metric\nTo use Python UMAP via reticulate, set umap.method to 'umap-learn' and metric to 'correlation'\nThis message will be shown once per session\n\n\n12:40:39 UMAP embedding parameters a = 0.9922 b = 1.112\n\n\n12:40:39 Read 18302 rows and found 20 numeric columns\n\n\n12:40:39 Using Annoy for neighbor search, n_neighbors = 30\n\n\n12:40:39 Building Annoy index with metric = cosine, n_trees = 50\n\n\n0%   10   20   30   40   50   60   70   80   90   100%\n\n\n[----|----|----|----|----|----|----|----|----|----|\n\n\n**************************************************|\n12:40:42 Writing NN index file to temp file /tmp/RtmpnBnqat/filee32d360edae9\n12:40:42 Searching Annoy index using 1 thread, search_k = 3000\n12:40:49 Annoy recall = 100%\n12:40:50 Commencing smooth kNN distance calibration using 1 thread with target n_neighbors = 30\n12:40:51 Initializing from normalized Laplacian + noise (using RSpectra)\n12:40:56 Commencing optimization for 200 epochs, with 772124 positive edges\n12:41:05 Optimization finished\n\nUMAPPlot(seu2, label=TRUE)\n\n\n\n\nUnfortunately, it is hard to say whether Seurat does exactly the same as we have done."
  },
  {
    "objectID": "tsne_umap_math.html",
    "href": "tsne_umap_math.html",
    "title": "t-SNE and UMAP",
    "section": "",
    "text": "This document describes the mathematics behind the two dimension-reduction methdos, t-SNE and UMAP."
  },
  {
    "objectID": "tsne_umap_math.html#t-sne",
    "href": "tsne_umap_math.html#t-sne",
    "title": "t-SNE and UMAP",
    "section": "t-SNE",
    "text": "t-SNE\n\nNeighborhood relations\nWe consider the stochastic event that point \\(i\\) “choses” a point \\(j\\) to be considered as neighbour, with p.m.f.\n\\[ p_{j|i} = \\frac{e^{-d_{ij}^2/2\\sigma_i^2}}{\\sum_{k\\neq i}e^{-d_{ik}^2/2\\sigma_i^2}}\\]\nThe entropy of this probability distribution is given by\n\\[H_i = -\\sum_{j\\neq i}p_{j|i}\\log_2 p_{j|i}\\]\nThe exponentiated entropy, i.e., the value \\(2^{H_i}\\), is called the perplexity.\nHere, the perplexity turns out to give the “size” of the neighbourhood of point \\(i\\), i.e., the number of points that have a reasonable chance as being chosen as neighbours.\nIn, t-SNE, one choses a fixed target value for the perplexity, e.g., 30, and then choses the \\(\\sigma_i\\) such that the perplexity takes the desired value. This can be done by binary search (iterated bisections of a search interval).\n\n\nSymmetrizing neighborhood\nNext, we define\n\\[p_{ij}=\\frac{p_{j|i}+p_{i|j}}{2n}\\]\nwhich gives us a p.m.f. to chose pairs of points that are likely neighbours. The denominator ensures that this adds to 1 over all pairs of points.\n\n\nNeighborhood in the embedding\nWe define similar probabilities \\[q_{ij}=\\frac{q_{j|i}+q_{i|j}}{2n}\\] for the embedding.\nHowever, the kernel used in \\(q_{j|i}\\) will be different. (See below.)\n\n\nKL divergence\nWe now seek an embedding, i.e., an assignment of 2D coordinates, \\(\\mathbf{y}_{i}\\), to all the points such that the probability distributions given by the \\(p_{ij}\\) and the \\(q_{ij}\\) are similar.\nTo this end, we quantify the dissimilarity between the two distributions by their Kulbeck-Leibler divergence: \\[ \\text{KL}(p\\|q) = \\sum_{ij}p_{ij}\\log\\frac{p_{ij}}{q_{ij}}\\]\nNote that this is the difference between the entropy of \\(p_{\\cdot\\cdot}\\) and the cross-entropy of \\(q_{\\cdot\\cdot}\\) w.r.t \\(p_{\\cdot\\cdot}\\): \\[ \\text{KL}(p\\|q) = \\sum_{ij}p_{ij}\\log p_{ij} - \\sum_{ij}p_{ij}\\log q_{ij}\\]\nOnly the latter depends on the \\(\\mathbf{y}_i\\).\nWe find the optimal \\(\\mathbf{y}_i\\) by gradient descent for the KL divergence.\n\n\nKernel for embedding: first try\nIn the older “stochastic neighborhood embedding” method, a Gaussian kernel was also used on the low-dimensional side:\n\\[ q_{j|i} = \\frac{e^{-D_{ij}^2/2}}{\\sum_{k\\neq i}e^{-D_{ik}^2/2}}\\]\nNote that, here, we do not chose a bandwidth \\(\\sigma\\). It is desirable to have the same kernel width (and hence point density) throughout, and we can set this w.l.o.g. to 1.\nThis did not work well, presumably due to the following:\n\n\nThe crowding problem\nThe volume of a ball of radius \\(\\sigma_i\\) around \\(\\mathbf{x}_i\\) can contain many more points at a given density than a disk of radius 1 around \\(\\mathbf{y}_i\\), because the volume of a ball grows exponentially with the dimension \\(d\\). Therefore, the Gaussian in 2D embedding does not “offer enough space” for all the points of the neighborhood. Making the disk larger does not help as it only rescales the whole embedding.\n\n\nFat-tailed kernel\nThe solution, that t-SNE proposes, is to use a kernel with fatter tails (higher kurtosis).\nStudent’s t distribution can be considered a normal distribution with “fattened tails”, with the t distribution for just 1 degree of freedom having the fattest tails. Its pdf is \\[ f_1(t) = \\frac{1}{\\pi(1+t^2)}\\]\nWe use this for our \\(q_{ij}\\): \\[ q_{ij} = \\frac{(1+D_{ij}^2)^{-1}}{\\sum_{kl}(1+D_{kl}^2)^{-1}} \\]\n\n\nGradient\nFor any pair \\(i,j\\), the gradient \\(\\mathbf{\\nabla}_{\\mathbf{y}_i}\\left(-p_{ij}\\log q_{ij}\\right)\\) is colinear with \\(\\mathbf{y}_j-\\mathbf{y}_i\\). We can hence understand it as causing an attractive or repulsive force between \\(i\\) and \\(j\\).\nTherefore, we can use similar methods as used to simulate Newtonian dynamics of clouds of mass points, such as the Barnes-Hut algorithm.\nAnother important numerical trick to speed up computation is “initial exaggeration”: for the earlier iterations, we multiply the gradient with large values.\n\n\nNormalization\nNote the denominator of the formula for \\(q_{ij}\\). It depends on all the other \\(\\mathbf{y}_k\\). This makes gradient descent a bit cumbersome: We can calculate the whole gradient, but we cannot perform stochastic gradient descent (SGD), where we pick point pairs at random following a probability distribution that accelerates convergence. One of the advantages of UMAP is that it omits such global normalization."
  },
  {
    "objectID": "tsne_umap_math.html#umap",
    "href": "tsne_umap_math.html#umap",
    "title": "t-SNE and UMAP",
    "section": "UMAP",
    "text": "UMAP\n\nNeighborhood graph\nUMAP starts by establishing a graph of nearest neighbors. It uses “fuzzy” neighborhood sets: each data point \\(i\\) has a “fuzzy set” of neighbours \\(j\\); i.e., membership in the set is not deinite but given by a probability.\nThe probability that point \\(j\\) is in the set of neighbours of point \\(i\\) is given by $p_{ij}.\nWe always set \\(p_{i\\rightarrow j}=1\\) if \\(j\\) is the nearest neighbor to \\(i\\) and \\(p_{i\\rightarrow j}=0\\) if \\(j\\) is further from \\(i\\) that the \\(k\\)-th nearest neighbor (where \\(k\\) is a hyperparameter chosen by the user). The probability for the second to \\(k\\)-th neighbor decays exponentially with distance: \\[p_{i\\rightarrow j}=e^{-(d_{ij}-d_{ii_1})/\\sigma},\\] where \\(d_{ii_1}\\) is the distance between \\(i\\) and its nearest neighbor, and \\(\\sigma\\) is chosen such that \\[\\sum_{j=1}^k p_{i\\rightarrow j}=\\log k.\\]\n\n\nSymmetrization\nWe can consider the fuzzy neighborhood sets as fuzzy sets of point pairs, and take their fuzzy-set union. This union can be considered as a skeletton of the manifold (on the level of 1-simplices, in the parlance of the UMAP paper).\nThen, the probability of a point pair \\((i,j)\\) being in this fuzzy-set union is given by \\[ p_{ij} = p_{i\\rightarrow j} + p_{j\\rightarrow i} - p_{i\\rightarrow j}p_{j\\rightarrow i}.\\]\n\n\nThe embedding probability\nSimilarily, we define a probability \\(q_{ij}\\) that tells us whether a pair of points appears to be in the same neighborhood in the embedding. As before, we want a fat-tailed distribution. To obatin more flexibility, the UMAP authors propose to use \\[ q_{ij} = \\frac{1}{1+aD_{ij}^{2b}}.\\] Note that we recover the Student t distribution with 1 d.o.f. if we set \\(a=b=1\\).\n\n\nThe purpurted loss function\nIn t-SNE, we found the embedding by minimizing the Kullbeck-Leibler divergence between the highdimensional and the embedding neighborhood probability distributions. We noted that this can also be seen as minimizing cross-entropy between the two distributions.\nThe UMAP authors similarly aim to minimize a cross entropy. However, here, we do not have probabilities to pick a specific point pair when picking one pair of neighbours among all. Rather, the probabilities denote whether a given pair is a pair of neighbours. This changed interpretation justifies that we do not normalize our probabilities. (They do not sum to one when running over all pairs.)\nWe now write the cross entropy judging the events “\\(i\\) and \\(j\\) are neighbours” and “\\(i\\) and \\(j\\) are not neighbours” for the two distributions.\n\\[L=\\sum_{\\substack{i,j\\\\i\\neq j}} \\left( p_{ij}\\log\\frac{p_{ij}}{q_{ij}} +\n(1-p_{ij})\\log\\frac{1-p_{ij}}{1-q_{ij}}\\right).\\]\nAgain, only part of this depends on the embedding:\n\\[L=\\text{const}-\\sum_{\\substack{i,j\\\\i\\neq j}} \\left( p_{ij}\\log q_{ij} +\n(1-p_{ij})\\log(1-q_{ij})\\right).\\]\nWe can write down the derivative of the first of these two terms (the attractive force between neighbours), w.r.t. to the \\(l\\)-th component of \\(\\mathbf{y}_i\\) (\\(l=1,2\\)):\n\\[ \\frac{d}{d y_{il}}\\left(p_{ij}\\log q_{ij}\\right) = -2p_{ij}\\frac{ab}{d_{ij}^2(a+d_{ij}^{-2b})}y_{il} \\]\nFor \\(a=b=1\\), we get \\[ \\mathbf{\\nabla}_{\\mathbf{y}_i}\\left(p_{ij}\\log q_{ij}\\right)=-\\frac{2p_{ij}}{d_{ij}^2+1}(\\mathbf{y}_i-\\mathbf{y}_j),\\] where \\(d_{ij}^2=\\|\\mathbf{y}_{i}-\\mathbf{y}_j\\|^2\\).\nFor the second term (the repulsive force between non-neighbours), we get, for \\(a=b=1\\): \\[ \\mathbf{\\nabla}_{\\mathbf{y}_i}\\left((1-p_{ij})\\log (1-q_{ij})\\right)=\\frac{2(1-p_{ij})}{d_{ij}^2(d_{ij}^2+1)}(\\mathbf{y}_i-\\mathbf{y}_j)\\]\nFor other values of \\(a\\) and \\(b\\), the expressions get slightly more complicated.\nThe UMAP paper claims that the software minimizes \\(L\\). In fact, however, it mimized an loss there the relative weight of the repulsive term is greatly diminished relative to the attractive term.\n\n\nThe UMAP algorithm\n\nInitialize the \\(\\mathbf{y}_i\\) in asuitable way, e.g., with the first two non-constant eigenvectors of the weighted neighborhood graph’s Laplacian.\nRepeat \\(n_\\text{iter}\\) times:\n\nSet learning rate \\(\\alpha\\) according to iteration number (linearly decreasing from 1 to 0)\nFor each point \\(i\\) do:\n\nFor each of neighbor \\(k\\) of point \\(i\\)’s \\(k\\) nearest neighbors do:\n\nWith probability \\(1-p_{ij}\\) skip this neighbor; otherwise, proceed as follows\nCalculate the attractive gradient \\(\\mathbf{g}_\\text{a} = \\mathbf{\\nabla}_{\\mathbf{y}_i}\\left(p_{ij}\\log q_{ij}\\right)\\)\nChange \\(\\mathbf{y}_i\\) to \\(\\mathbf{y}_i + \\alpha \\mathbf{g}_\\text{a}\\)\nChange \\(\\mathbf{y}_j\\) to \\(\\mathbf{y}_j - \\alpha \\mathbf{g}_\\text{a}\\)\nPick \\(n_\\text{neg}\\) random other points \\(j\\), for these do:\n\nCalculate the repulsive gradient \\(\\mathbf{g}_\\text{r} = \\mathbf{\\nabla}_{\\mathbf{y}_i}\\left((1-p_{ij})(1-\\log q_{ij})\\right)\\)\nChange \\(\\mathbf{y}_i\\) to \\(\\mathbf{y}_i + \\alpha \\mathbf{g}_\\text{r}\\)\n\n\n\n\n\nClearly, the actual strength of the repulsion depends on the choice of the hyperparameter \\(n_\\text{neg}\\), which is set to 5 by default."
  },
  {
    "objectID": "graph_diffusion.html",
    "href": "graph_diffusion.html",
    "title": "Diffusion distances",
    "section": "",
    "text": "Load example data\nBefore getting into the topic, we load the usual example data and performing standard preprocessing\n\nsuppressPackageStartupMessages({\n  library( tidyverse )\n  library( Matrix )\n  library( sparseMatrixStats )\n  library( Seurat ) })\n\nReadMtx( \"~/Downloads/ifnagrko/ifnagrko_raw_counts.mtx.gz\",\n    \"~/Downloads/ifnagrko/ifnagrko_obs.csv\",\n    \"~/Downloads/ifnagrko/ifnagrko_var.csv\",\n    cell.sep=\",\", feature.sep=\",\", skip.cell=1, skip.feature=1, \n    mtx.transpose=TRUE) -&gt; count_matrix\n\n\ncount_matrix %&gt;%\nCreateSeuratObject() %&gt;%\nNormalizeData() %&gt;%\nFindVariableFeatures() %&gt;%\nScaleData() %&gt;%\nRunPCA( npcs=20 ) %&gt;%\nFindNeighbors( dims=1:20 ) %&gt;%\nFindClusters( resolution=0.5 ) %&gt;%\nRunUMAP( dims=1:20 ) -&gt; seu\n\nWarning: Feature names cannot have underscores ('_'), replacing with dashes\n('-')\n\n\nNormalizing layer: counts\n\n\nFinding variable features for layer counts\n\n\nCentering and scaling data matrix\n\n\nPC_ 1 \nPositive:  Apoe, Aldoc, Sparcl1, Sdc4, Ptn, Cmtm5, Glul, Gpr37l1, Fxyd1, Atp1b2 \n       S100a1, Slc4a4, Slc1a3, Prxl2a, F3, Itm2b, Mt1, Rgcc, Prdx6, Sfxn5 \n       Sat1, Scrg1, Dbi, Hes5, Luzp2, Plaat3, Pla2g7, Sash1, Plpp3, Sparc \nNegative:  Tubb5, Sox11, Tubb3, Stmn1, Jpt1, Hmgb3, Ptma, Sox4, Dlx2, Cd24a \n       Igfbpl1, Dlx6os1, Map1b, Stmn2, Abracl, Tmsb4x, Lmnb1, Cdca7, Ccnd2, Elavl4 \n       Cdk4, Dcx, Arx, Uchl1, EYFP, Celf4, Dlx5, Nrxn3, H1fx, Hmgn2 \nPC_ 2 \nPositive:  Ctss, C1qc, Laptm5, Csf1r, Trem2, C1qa, Cx3cr1, C1qb, Tyrobp, Ly86 \n       Fcer1g, Siglech, Selplg, Fcrls, Tmem119, Fcgr3, Apbb1ip, Unc93b1, Cd53, Lpcat2 \n       Spi1, Pld4, Olfml3, Irf8, Ctsh, Aif1, Cd300c2, Fyb, Otulinl, Mylip \nNegative:  Rorb, Cldn10, Clu, Mt3, Ntsr2, Mfge8, S1pr1, Id4, Slc1a2, Acsl6 \n       Plpp3, Sox9, Ddah1, Bcan, Cxcl14, Btbd17, Mlc1, Cspg5, Fjx1, Aqp4 \n       Ntm, Acsl3, Gabrb1, Tspan7, Lsamp, Chst2, Mt2, Lhx2, Slc39a12, Glud1 \nPC_ 3 \nPositive:  Atp1a3, Camk2b, Snhg11, Syt1, Nrip3, Kcnj4, Scg2, Snap25, Dnm1, Pcp4 \n       Icam5, Ndrg4, Eef1a2, Eno2, Ano3, Ryr2, Arpp21, Ptk2b, Gng4, Kcna4 \n       Penk, Slc4a10, Snca, Gad1, Rprml, Grin2a, C1qtnf4, Shisa8, Camk2a, Kcnb2 \nNegative:  Hmgb2, Top2a, Pbk, Birc5, Mki67, Cdk1, Cdca8, Spc24, Cenpf, Spc25 \n       Prc1, Rrm2, Mdk, Nusap1, Tpx2, Cdca3, Knl1, Ckap2l, Esco2, Aurkb \n       Cenpm, Ccna2, Bub1, Cks2, Kif11, Hist1h3c, Hist1h1b, Hmmr, Pclaf, Fbxo5 \nPC_ 4 \nPositive:  C1qc, C1qa, Ctss, Trem2, Csf1r, C1qb, Cx3cr1, Laptm5, Fcer1g, Tyrobp \n       Ly86, Siglech, Selplg, Fcrls, Fcgr3, Hexb, Spi1, Cd53, Itgb5, Pld4 \n       Ptgs1, Cd300c2, Aif1, Irf8, Fyb, Itgam, Cyth4, Ltc4s, Otulinl, Cd37 \nNegative:  Frzb, Apod, Npy, Plp1, Vtn, Foxd3, Wnt6, Nr2f2, Edil3, Sox10 \n       Gsn, Matn4, Fbln2, Aspa, Aqp1, Igf1, Plat, Lpar1, Igfbp4, Erbb3 \n       Fabp7, Plppr4, Ptgds, Col23a1, Alx3, Hey2, Cd59a, Fam3c, Scd1, Mybpc1 \nPC_ 5 \nPositive:  Stmn2, Igfbpl1, Cd24a, Nrep, Sox4, Map1b, Stmn4, Tubb3, Shtn1, Dlx6os1 \n       Dcx, Ly6h, Sox11, Jpt1, Mpped2, Stmn1, Plxna4, Pbx3, Elavl4, Uchl1 \n       Runx1t1, Cald1, Foxp2, Dlx2, Gad2, Celf4, Pfn2, Dlx5, Sp8, Tubb5 \nNegative:  Top2a, Pbk, Birc5, Mki67, Spc25, Cdk1, Prc1, Nusap1, Spc24, Esco2 \n       Tpx2, Knl1, Aurkb, Cenpf, Cdca8, Ckap2l, Kif11, Cdca3, Hist1h3c, Hmmr \n       Ccna2, Bub1, Incenp, Hist1h2af, Ndc80, Cit, Fbxo5, Kif4, Sgo1, Kif22 \n\n\nComputing nearest neighbor graph\n\n\nComputing SNN\n\n\nModularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck\n\nNumber of nodes: 18302\nNumber of edges: 616069\n\nRunning Louvain algorithm...\nMaximum modularity in 10 random starts: 0.9191\nNumber of communities: 19\nElapsed time: 4 seconds\n\n\nWarning: The default method for RunUMAP has changed from calling Python UMAP via reticulate to the R-native UWOT using the cosine metric\nTo use Python UMAP via reticulate, set umap.method to 'umap-learn' and metric to 'correlation'\nThis message will be shown once per session\n\n\n15:40:30 UMAP embedding parameters a = 0.9922 b = 1.112\n\n\n15:40:30 Read 18302 rows and found 20 numeric columns\n\n\n15:40:30 Using Annoy for neighbor search, n_neighbors = 30\n\n\n15:40:30 Building Annoy index with metric = cosine, n_trees = 50\n\n\n0%   10   20   30   40   50   60   70   80   90   100%\n\n\n[----|----|----|----|----|----|----|----|----|----|\n\n\n**************************************************|\n15:40:33 Writing NN index file to temp file /tmp/Rtmpj9yoNW/file5089569a3f4f5\n15:40:33 Searching Annoy index using 1 thread, search_k = 3000\n15:40:41 Annoy recall = 100%\n15:40:41 Commencing smooth kNN distance calibration using 1 thread with target n_neighbors = 30\n15:40:42 Initializing from normalized Laplacian + noise (using RSpectra)\n15:40:47 Commencing optimization for 200 epochs, with 776086 positive edges\n15:40:59 Optimization finished\n\n\n\nUMAPPlot( seu, label=TRUE ) + coord_equal()\n\n\n\n\n\n\nNearest neighbors\nIn this lesson, we will mainly work with the nearest neighbor data. Seurat has already calculated this but we do this again here:\n\nFNN::get.knn( Embeddings( seu, \"pca\" ), k=15 ) -&gt; nn\n\nhead( nn$nn.index)\n\n      [,1]  [,2]  [,3]  [,4]  [,5]  [,6]  [,7]  [,8]  [,9] [,10] [,11] [,12]\n[1,]  2504  4613  2817  2697  4423  3301 11993 17335   782  7322  6832   710\n[2,] 12412 11120  9817  6433 11238 13771  1477 11146 11275 16123 16751  5537\n[3,] 10073  9512  3943  7030  8300 10489  5189  7207  3050 10479  5624  9527\n[4,] 12407  2608 16034  8035  1662  4011  3937 10428 16823  5610 16173  3883\n[5,] 10060 10135  3874  5333  4318  4437  7573 16224 11594  6338  8306 17955\n[6,] 13639 11873 16237 12423 17155  2140  8348  1213  5423  2691 12754  5443\n     [,13] [,14] [,15]\n[1,]  4421  2209  5197\n[2,]  9427  1947  8633\n[3,]  3086  1516  8733\n[4,]  1858  4214 16949\n[5,] 14159  5662 13930\n[6,]   185  3376   273\n\n\n\n\nAdjacency matrix\nWe next construct the adjacency matrix of the undirected nearest neighbor graph. To connect each vertex to its \\(i\\)th nearest neighbor, we need the following edges:\n\nncells &lt;- ncol(seu)\n\ni &lt;- 3\ncbind( vertex_A=1:ncells, vertex_B=nn$nn.index[,i] ) %&gt;% head()\n\n     vertex_A vertex_B\n[1,]        1     2817\n[2,]        2     9817\n[3,]        3     3943\n[4,]        4    16034\n[5,]        5     3874\n[6,]        6    16237\n\n\nWe can use this as indices of the matrix cells we want to set to one and thus construct a sparse matrix\n\nsparseMatrix(  i=1:ncells, j=nn$nn.index[,i], x=1, dims=c(ncells,ncells) ) %&gt;% summary() %&gt;% head()\n\n18302 x 18302 sparse Matrix of class \"dgCMatrix\", with 18302 entries\n      i j x\n1  2697 1 1\n2  2817 1 1\n3  7322 1 1\n4 11993 1 1\n5  9427 2 1\n6  9817 2 1\n\n\nAdding up on such matrix for i running from 1 to 15 gives us the adjacency matrix\n\nadjm &lt;- sparseMatrix( i=integer(), j=integer(), x=numeric(), dims=c(ncells,ncells) ) # zero matrix\nfor( i in 1:ncol(nn$nn.index) ) {\n   adjm &lt;- adjm + sparseMatrix(  i=1:ncells, j=nn$nn.index[,i], x=1, dims=c(ncells,ncells) ) }\nsummary(adjm) %&gt;% head()\n\n18302 x 18302 sparse Matrix of class \"dgCMatrix\", with 274530 entries\n     i j x\n1  174 1 1\n2  710 1 1\n3  782 1 1\n4 1121 1 1\n5 1769 1 1\n6 2504 1 1\n\n\nWe make the matrix symmetric\n\nadjm &lt;-  adjm + t(adjm)\n\nNow, some matrix entries have become 2 rather than 1. We set everything back to 1:\n\nadjm@x[] &lt;- 1\n\nNow, we have an adjacency matrix for our nearest neighbor graph.\n\n\nRandom walk\nWe now define a random walk on our graph as follows: A “walker” (or: “token”) starts at a vertex \\(i\\). In each time step, it choses one of the vertex’s neighbors at random and moves there. What is the probability of the walker being on vertex \\(j\\) after \\(\\ell\\) steps?\nWe represent the walker being at vertex \\(i\\) with the unit vector in direction \\(i\\), i.e., the vector \\(\\vec e_i\\), with a 1 at component \\(i\\) and zero elsewhere. The transition matrix \\(T\\) with elements \\(T_{ij}\\) tells us the probability of the walker moving to vertex \\(j\\) in a step if it was before at vertex \\(i\\):\n\\[ T_{ij} = A_{ij} \\Big/ \\sum_{j'}{A_{ij'}}. \\] The division normalizes the probabiliities by dividing by the number of neighbors that the walker can chose from.\n\ntrm &lt;- adjm / rowSums(adjm)\n\nCheck normalization:\n\nrowSums(trm) %&gt;% head()\n\n[1] 1 1 1 1 1 1\n\n\nTo try this out, we pick a cell close to the point (-6,6) in the UMAP:\n\ncell &lt;- which.min( ( Embeddings(seu,\"umap\")[,1] + 6 )^2 + ( Embeddings(seu,\"umap\")[,2] - 6 )^2 )\ncell\n\nCGGGCATGTTGGGAAC-WT_4mo_2021_001 \n                           14741 \n\n\nHere’s a UMAP plot of this cell and it’s neighbors:\n\nEmbeddings(seu,\"umap\") %&gt;%\nas_tibble() %&gt;%\nmutate( w = case_when(\n  row_number() == cell ~ \"cell\",\n  adjm[cell,] == 1 ~ \"neighbor\",\n  TRUE ~ \"other\"\n)) %&gt;% \nggplot +\n  geom_point( aes( x=umap_1, y=umap_2, col=w ), size=.3 ) + coord_equal() +\n  scale_color_manual( values=c(\"darkgreen\",\"magenta\",\"#00000006\"))\n\n\n\n\nLet’s perform 10 steps. We start with a sparse vector with a single 1 at the chosen cell’s index and 0 elsewhere, then multiply this 10 times with \\(T\\):\n\nu &lt;- sparseVector( i=cell, x=1, length=ncells )\nfor( i in 1:10 )\n  u &lt;- u %*% trm\n\nWe first check whether u is still normalized:\n\nsum(u)\n\n[1] 1\n\n\nHere’s a plot of \\(\\vec{u}=\\vec{e}_i^\\top T^{10}\\).\n\nEmbeddings(seu,\"umap\") %&gt;%\nas_tibble() %&gt;%\nmutate( u = as.vector(u) ) %&gt;% \nggplot +\n  geom_point( aes( x=umap_1, y=umap_2, col=u ), size=.3 ) + coord_equal() +\n  scale_color_viridis_c(direction=-1)\n\n\n\n\n\n\nExponantiating the transition matrix\nCalculating \\(\\ell\\) steps by repeated multiplication is wasteful. We should use a matrix exponential.\nAs preparation for this, we define the diagonal “degree matrix” \\(D\\), that contains the vertex degrees: \\[ D_{ij} = \\delta_{ij} \\sum_{j'} A_{ij'}. \\]\nNow, we have: \\[ T = D^{-1}A.\\]\n\\(T\\) is a row-stochastic matrix, i.e., its values are all non-negative and its rows sum to 1.\nThe probability mass vector for a walker starting at vertex \\(i\\) after one step is \\(\\vec{e}_i^\\top T\\), and after \\(\\ell\\) steps, \\(\\vec{e}_i^\\top T^\\ell\\).\nTo calculate \\(T^\\ell\\), we will need the eigendecomposition of the symmetrized transition matrix \\(\\tilde T = D^{-1/2} T D^{-1/2}\\): \\[ \\tilde T = U\\Lambda U^\\top,\\] with the columns of \\(U\\) containing the eigenvectors of \\(\\tilde T\\) and the diagonal matrix \\(\\Lambda\\) containing the eigenvalues.\nWith this, we get \\[ \\begin{align}\nT^\\ell &= \\left(D^{-1} A\\right)^\\ell \\\\\n&= D^{-1/2} \\left(D^{-1/2} A D^{-1/2}\\right)^\\ell D^{1/2} \\\\\n&= D^{-1/2} \\left(U \\Lambda U^T\\right)^\\ell D^{1/2} \\\\\n&= \\underbrace{D^{-1/2} U \\Lambda^\\ell}_{=X_\\ell} U^T D^{1/2}.\n\\end{align} \\]\nWe construct \\(D\\)\n\ndegdiag &lt;- sparseMatrix( i=1:ncells, j=1:ncells, x=rowSums(adjm) )\n\nWe also write down \\(D^{-1}\\), \\(D^{1/2}\\) and \\(D^{-1/2}\\):\n\ninvdegdiag     &lt;- sparseMatrix( i=1:ncells, j=1:ncells, x=1/rowSums(adjm) )\nsqrtdegdiag    &lt;- sparseMatrix( i=1:ncells, j=1:ncells, x=sqrt(rowSums(adjm)) )\ninvsqrtdegdiag &lt;- sparseMatrix( i=1:ncells, j=1:ncells, x=1/sqrt(rowSums(adjm)) )\n\nNow we get the eigensystem of \\(\\tilde T\\), requesting the 100 eigenvalues that are largest by magnitude:\n\neigtrm &lt;- RSpectra::eigs_sym( invsqrtdegdiag %*% adjm %*% invsqrtdegdiag, k=100 )\n\nNow, we can calculate \\(\\vec e_i^\\top T^\\ell\\) as follows:\nWe calculate first \\(X_\\ell = D^{-1/2} U \\Lambda^\\ell\\):\n\ninvsqrtdegdiag %*% eigtrm$vectors %*% diag( eigtrm$values^10 ) %&gt;% as.matrix() -&gt; x10\n\ndim(x10)\n\n[1] 18302   100\n\n\nNote that the matrix \\(X_\\ell\\) has been trimmed to only the first 50 columns. That is ok because the factor \\(\\Lambda^\\ell\\) gets small quickly and therefore, the columns stay close to zero once we get past the first few on the left:\n\nplot( colSums(x10^2) )\n\n\n\n\nOf course, this only works for \\(\\ell \\gg 1\\) and with \\(\\ell=10\\) we may have only just enough steps for the approximation becoming valid.\nWe take the row of \\(X_\\ell\\) that corresponds to our cell and multiply this with \\(U^\\top D^{1/2}\\) to get \\(e_i^\\top X_\\ell U^\\top D^{1/2}=e_i^\\top T^\\ell\\):\n\nx10[cell,] %*% t(eigtrm$vectors) %*% sqrtdegdiag %&gt;% as.vector() -&gt; u10\n\nHere is a plot of that vector:\n\nEmbeddings(seu,\"umap\") %&gt;%\nas_tibble() %&gt;%\nmutate( u = u10 ) %&gt;% \nggplot +\n  geom_point( aes( x=umap_1, y=umap_2, col=u ), size=.3 ) + coord_equal() +\n  scale_color_viridis_c(direction=-1)\n\n\n\n\nThis looks quite similar as the plot we made before.\nHere’s a comparison of the two results\n\nplot( u, u10, asp=1, cex=.2, xlab=\"exact calculation\", ylab=\"using top 100 eigenvectors\" )\nabline( 0, 1, col=\"#00000020\" )\nabline( h=0, v=0, col=\"#00000020\" )\n\n\n\n\n\n\nDiffusion distances\nWe now define a new distance metrix for our cells. Intuitively: To quantify the distance between two cells \\(i\\) and \\(j\\), we start random walks at both cells, evolve them for \\(\\ell\\) steps, and then ask about the overlap between the resulting probability vectors.\nWe might therefore use \\[ \\left\\| e_i^\\top T^\\ell - e_j\n^\\top T^\\ell \\right\\|_2, \\] i.e., the Euclidean distance between rows \\(i\\) and \\(j\\) of \\(T^\\ell\\) as the distance between cells \\(i\\) and \\(j\\).\nNote that the number of steps, \\(\\ell\\), selects a “length scale” at which the that distance is informative.\nThere is a practical difficulty in using this definition, though: When multiplying the small \\(n\\times k\\) matrix \\(X_\\ell\\) with the transpose of the \\(n\\times k\\) eigenvector matrix \\(U\\) (with \\(n\\) being the number of cells and \\(k\\) being the number of eigenvectors that have been calculated) our data blows up to an unwieldy \\(n\\times n\\) matrix.\nWe can avoid this by using the rows of \\(X_\\ell\\) instead of the rows of \\(T^\\ell\\), and therefore define:\nThe \\(\\ell\\)-steps diffusion distance between cells \\(i\\) and \\(j\\) is \\[ d_{\\ell,ij} = \\left\\| e_i^\\top X_\\ell - e_j^\\top X_\\ell \\right\\|_2, \\]\nNote that this is also \\[ d_{\\ell,ij} = \\left\\| \\left( e_i^\\top T^\\ell  - e_i^\\top T^\\ell\\right) D^{-1/2} \\right\\|_2, \\] i.e., the components of the resulting probability vectors get reweighted by \\(D^{-1/2}\\) before calculating the norm of the difference. If we accept this (somewhat unmotivated) reweighting, because it does not change much (as the vertex degrees do not differ that much from each other), we have a computationally efficient way of calculating \\(d_{\\ell,ij}\\): All we need is \\(X_\\ell\\).\nBy calculating the Euclidean distance of every row of \\(X_\\ell\\) to the row for our selected cell, we get the \\(\\ell\\)-step diffusion distance of that cell to all other cells:\n\nEmbeddings(seu,\"umap\") %&gt;%\nas_tibble() %&gt;%\nmutate( d = sqrt( rowSums( t( t(x10) - x10[cell,] )^2 ) ) ) %&gt;% \narrange(-d) %&gt;%\nggplot +\n  geom_point( aes( x=umap_1, y=umap_2, col=d ), size=.3 ) + coord_equal() +\n  scale_color_viridis_c(direction=-1)\n\n\n\n\nBelow, this plot is repeated for several values of \\(\\ell\\). (But remember that our approximation error is larger for \\(\\ell \\lesssim 10\\).)\n\nfor( l in c(3, 10, 30, 100, 300, 1000 ) ) {\n  invsqrtdegdiag %*% eigtrm$vectors %*% diag( eigtrm$values^l ) %&gt;% as.matrix() -&gt; xm\n  print(\n    Embeddings(seu,\"umap\") %&gt;%\n    as_tibble() %&gt;%\n    mutate( d = sqrt( rowSums( t( t(xm) - xm[cell,] )^2 ) ) ) %&gt;% \n    arrange(-d) %&gt;%\n    ggplot +\n      geom_point( aes( x=umap_1, y=umap_2, col=d ), size=.3 ) + coord_equal() +\n      scale_color_viridis_c(direction=-1) + ggtitle( sprintf( \"%d steps\", l ) ) )\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPseudotime\nWe now want to define a pseudotime along the lineage, from cluster 0 to cluster 2 and on to 7.\nWe define a start cell and an end cell, by taking our cell (which is arguably somewhere in the middle) and find the cell with the largest distance to it within cluster 0 and 7, respectivelty.\nWe will work with \\(\\ell=300\\):\n\nl &lt;- 300\nxm &lt;- as.matrix( invsqrtdegdiag %*% eigtrm$vectors %*% diag( eigtrm$values^l ) )\n# distances to \"intermediate\" cell:\nd &lt;- sqrt( rowSums( t( t(xm) - xm[cell,] )^2 ) )\n\nHere is the distance of the cells in cluster 0 (the astrocyte / neuronal stem cell cluster, where the lineage starts) to our intermediate cell:\n\nhist( d[seu$seurat_clusters==0], 100 )\nabline(v=0.0013, col=\"orange\")\n\n\n\n\nIt seems reasonable to assume that the cells at the steep cliff are the actual start of the lineage and the cells further out or some outliers (perhaps cells that started into another direction)\n\nstart_cell &lt;- which.min( ( d * (seu$seurat_clusters==0) - 0.0013 )^2 )\n\nLet’s also find a reasonable “end cell” in the neuron cluster 7:\n\nhist( d[seu$seurat_clusters==7], 100 )\n\n\n\n\nHere’ let’s simply take the last cell:\n\nend_cell &lt;- which.max( d * (seu$seurat_clusters==7) )\n\nNow, get distances to these two cells:\n\ndist_to_start &lt;- sqrt( rowSums( t( t(xm) - xm[start_cell,] )^2 ) )\ndist_to_end &lt;- sqrt( rowSums( t( t(xm) - xm[end_cell,] )^2 ) )\n\n\ntibble( \n  dist_to_start, dist_to_end, \n  cluster=seu$seurat_clusters ) %&gt;%\nmutate(\n  type = case_when(\n    cluster %in% c( 0, 3, 5, 1, 2, 7 ) ~ \"lineage_straight\",\n    cluster %in% c( 6, 11 )  ~ \"lineage_cycle\",\n    TRUE ~ \"other\" ) ) %&gt;%\nggplot +\n  geom_point( aes( x=dist_to_end, y=dist_to_start, col=type ), size=.1 ) +\n  coord_equal()\n\n\n\n\nLet’s rotate this plot by 45°:\n\ntibble( \n  dist_to_start, dist_to_end, \n  cluster=seu$seurat_clusters ) %&gt;%\nmutate(\n  type = case_when(\n    cluster %in% c( 0, 3, 5, 1, 2, 7 ) ~ \"lineage_straight\",\n    cluster %in% c( 6, 11 )  ~ \"lineage_cycle\",\n    TRUE ~ \"other\" ) ) %&gt;%\nggplot +\n  geom_point( aes( \n    x = dist_to_start - dist_to_end, \n    y = dist_to_start + dist_to_end, col=type ), size=.1 )\n\n\n\n\nOur new x-axis should be suitable as pseudotime:\n\npseudotime &lt;- dist_to_start - dist_to_end\n\nLet’s plot this into the UMAP:\n\nEmbeddings(seu,\"umap\") %&gt;%\nas_tibble() %&gt;%\nadd_column( pseudotime ) %&gt;% \nggplot +\n  geom_point( aes( x=umap_1, y=umap_2, col=pseudotime ), size=.3 ) + coord_equal() +\n  scale_color_gradientn( colours=rje::cubeHelix(100,r=4) ) \n\n\n\n\nBefore we dive into this, let’s also plot the y axis ofdist+to+start+dfist+to_end`:\n\nEmbeddings(seu,\"umap\") %&gt;%\nas_tibble() %&gt;%\nadd_column( distsum = dist_to_start + dist_to_end ) %&gt;% \nggplot +\n  geom_point( aes( x=umap_1, y=umap_2, col=distsum ), size=.3 ) + coord_equal() +\n  scale_color_gradient2( midpoint = .01, limits = c(0,.02), oob=scales::oob_squish )\n\n\n\n\nComparing with the plot above, our pseudotime is valid for the red, white and perhaps the very faintly blue regions.\n\n\nComaprison to principal curve\nLet’s recreate the principal curve that we used before for pseudotime.\nAs before, we calculate the principal curve using the cells in the lineage as input, without the cells from the two cycling cluster, and use smoothing splines with 10 degrees of freedom.\n\nprincurve::principal_curve(\n  Embeddings(seu,\"pca\")[ seu$seurat_clusters %in% c( 0, 3, 5, 1, 2, 7 ), ],\n  df = 10, approx_points=1000 ) -&gt; prc\n\nWe again project the remaining cells onto outo the cells on the curve and assign to them the same pseudotime as the one of the nearest point on the curve:\n\nFNN::get.knnx( prc$s, Embeddings(seu,\"pca\"), k=1 ) -&gt; prc_nn\npseudotime_prc &lt;- prc$lambda[ prc_nn$nn.index ]\n\nHere is the principal-curve-based pseudotime:\n\nEmbeddings(seu,\"umap\") %&gt;%\nas_tibble() %&gt;%\nadd_column( pseudotime_prc ) %&gt;% \nggplot +\n  geom_point( aes( x=umap_1, y=umap_2, col=pseudotime_prc ), size=.3 ) + coord_equal() +\n  scale_color_gradientn( colours=rje::cubeHelix(100,r=4) ) \n\n\n\n\nWe can also compare the two:\n\ntibble(\n  pt_diffusion = pseudotime,\n  pt_prc = -pseudotime_prc,\n  cluster = seu$seurat_clusters\n) %&gt;%\nmutate(\n  type = case_when(\n    cluster %in% c( 0, 3, 5, 1, 2, 7 ) ~ \"lineage_straight\",\n    cluster %in% c( 6, 11 )  ~ \"lineage_cycle\",\n    TRUE ~ \"other\" ) ) %&gt;%\nggplot +\n  geom_point( aes( x=pt_diffusion, y=pt_prc, col=type ), size=.2 )\n\n\n\n\nHere, teh same, but coloured for cluster (using only the lineage cells). See below for a UMAP coloured in the same manner.\n\ntibble(\n  pt_diffusion = pseudotime,\n  pt_prc = -pseudotime_prc,\n  cluster = seu$seurat_clusters\n) %&gt;%\nfilter(\n  cluster %in% c( 0, 3, 5, 1, 2, 7, 6, 11 ) )  %&gt;%\nggplot +\n  geom_point( aes( x=pt_diffusion, y=pt_prc, col=cluster ), size=.2 )\n\n\n\n\n\n\nDiffusion space\nThe space of \\(X_\\ell\\) can also be interpreted as an alternative to the feature space, called “diffusion space”. Using the first few components provides a dimension redution, the “diffusion map”.\nFor this to work well, our neighborhood graph should be connected.\nOurs has two connection components, however, as is evident from the fact that our transition matrix has two unit eigenvalues:\n\nhead( eigtrm$values )\n\n[1] 1.0000000 1.0000000 0.9998821 0.9993076 0.9991653 0.9984226\n\n\nTo make our live easier, let’s reduce the data to only the lineage cells\n\nin_lineage &lt;- seu$seurat_clusters %in% c( 0, 3, 5, 1, 2, 7, 6, 11 )\n\nSubset the adjacency matrix to these and recalculate the transition matrix and its spectrum\n\nadjml &lt;- adjm[ in_lineage, ][ , in_lineage ]\nncells &lt;- nrow(adjml)\n\ninvsqrtdegdiag &lt;- sparseMatrix( i=1:ncells, j=1:ncells, x=1/sqrt(rowSums(adjml)) )\neigtrm &lt;- RSpectra::eigs_sym( invsqrtdegdiag %*% adjml %*% invsqrtdegdiag, k=10 )\n\nx300 &lt;- as.matrix( invsqrtdegdiag %*% eigtrm$vectors %*% diag( eigtrm$values^300 ) )\n\n\nas_tibble( x300[,2:3 ] ) %&gt;%\nadd_column( cluster = seu$seurat_clusters[in_lineage] ) %&gt;%\nggplot +\n  geom_point( aes( x=V1, y=V2, col=cluster ), size=.1 ) + coord_equal()\n\nWarning: The `x` argument of `as_tibble.matrix()` must have unique column names if\n`.name_repair` is omitted as of tibble 2.0.0.\nℹ Using compatibility `.name_repair`.\n\n\n\n\n\nFor comparison, the UMAP with the same c\n\nas_tibble( Embeddings(seu,\"umap\")[in_lineage,] ) %&gt;%\nadd_column( cluster = seu$seurat_clusters[in_lineage] ) %&gt;%\nggplot +\n  geom_point( aes( x=umap_1, y=umap_2, col=cluster ), size=.1 ) + coord_equal()\n\n\n\n\n\n\nReferences\nThe idea of diffusion distances and diffusion maps has been introduced in this paper:\n\nCoifman and Lafon (2006): Diffusion Maps. Applied and Computational Harmonic Analysis, Vol. 21, Pages 5-30. doi:10.1016/j.acha.2006.04.006\n\nApplying these ideas to single-cell data is explored in\n\nHaghverdi, Büttner, Theis (2015): Diffusion maps for high-dimensional single-cell analysis of differentiation data Bioinformatics, Vol. 31, Pages 2989–2998, doi:10.1093/bioinformatics/btv325\nHaghverdi, Büttner, Wolf, Buettner, Theis (2016): Diffusion pseudotime robustly reconstructs lineage branching Nature Methods, Vol. 13, Pages 845–848\nAngerer, Haghverdi, Büttner, Theis, Marr, Buettner: destiny: diffusion maps for large-scale single-cell data in R, Bioinformatic, Vol. 32, Pages 1241-1243, doi:10.1093/bioinformatics/btv715"
  },
  {
    "objectID": "pedestrian.html",
    "href": "pedestrian.html",
    "title": "Doing the Seurat analysis “on foot”",
    "section": "",
    "text": "We load our example data\n\nsuppressPackageStartupMessages( {\n  library( Seurat )\n  library( Matrix ) } )\n\n\ncount_matrix &lt;- Read10X( \"data/pbmc3k/filtered_gene_bc_matrices/hg19/\" )\n\nQu: Examine the sparse storage format of the matrix.\n\nNormalization\nThe total rad counts per cell (the column sums of the count matrix) differ noticeably.\nIn order to compare between cells, we should not look at the absolute counts but better at the fraction that each gene’s count contributes to the total. Hence, we divide the matrix by the column sum:\n\nfractions &lt;- t( t(count_matrix) / colSums(count_matrix) )\n\n\n\nVariance-mean dependence\nWe calculate for each gene mean and variance across all cells and plot them against each other:\n\nlibrary( sparseMatrixStats )\n\nLoading required package: MatrixGenerics\n\n\nLoading required package: matrixStats\n\n\n\nAttaching package: 'MatrixGenerics'\n\n\nThe following objects are masked from 'package:matrixStats':\n\n    colAlls, colAnyNAs, colAnys, colAvgsPerRowSet, colCollapse,\n    colCounts, colCummaxs, colCummins, colCumprods, colCumsums,\n    colDiffs, colIQRDiffs, colIQRs, colLogSumExps, colMadDiffs,\n    colMads, colMaxs, colMeans2, colMedians, colMins, colOrderStats,\n    colProds, colQuantiles, colRanges, colRanks, colSdDiffs, colSds,\n    colSums2, colTabulates, colVarDiffs, colVars, colWeightedMads,\n    colWeightedMeans, colWeightedMedians, colWeightedSds,\n    colWeightedVars, rowAlls, rowAnyNAs, rowAnys, rowAvgsPerColSet,\n    rowCollapse, rowCounts, rowCummaxs, rowCummins, rowCumprods,\n    rowCumsums, rowDiffs, rowIQRDiffs, rowIQRs, rowLogSumExps,\n    rowMadDiffs, rowMads, rowMaxs, rowMeans2, rowMedians, rowMins,\n    rowOrderStats, rowProds, rowQuantiles, rowRanges, rowRanks,\n    rowSdDiffs, rowSds, rowSums2, rowTabulates, rowVarDiffs, rowVars,\n    rowWeightedMads, rowWeightedMeans, rowWeightedMedians,\n    rowWeightedSds, rowWeightedVars\n\nplot( rowMeans(fractions), rowVars(fractions), cex=.3 )\n\n\n\n\nQu: The function rowVars is here taken from the “sparseMatrixStats”. How would you calculate the row variances of a matrix given in one of the sparse storage formats?\nIt is helpful to make the plot logarithmic\n\nplot( rowMeans(fractions), rowVars(fractions), cex=.3, log=\"xy\", col=scales::alpha( \"black\", .3 ) )\n\nWarning in xy.coords(x, y, xlabel, ylabel, log): 16104 x values &lt;= 0 omitted\nfrom logarithmic plot\n\n\nWarning in xy.coords(x, y, xlabel, ylabel, log): 16104 y values &lt;= 0 omitted\nfrom logarithmic plot\n\nsegments( 1e-6, 1e-10, 1e-2, 1e-6 )   # line with slope 1 on log-log plot   --&gt; v ∝ µ\nsegments( 1e-7, 1e-10, 1e-4, 1e-4 )   # line with slope 2 on log-log plot   --&gt; v ∝ µ²\n\n\n\n\nWe have a look at the squared coefficient of variation (CV²):\n\nplot( rowMeans(fractions), rowVars(fractions) / rowMeans(fractions), \n      cex=.3, log=\"xy\", col=scales::alpha( \"black\", .3 ) )\n\nWarning in xy.coords(x, y, xlabel, ylabel, log): 16104 x values &lt;= 0 omitted\nfrom logarithmic plot\n\nabline( h = mean( 1/colSums(count_matrix)), col=\"orange\")\n\n\n\n\nFor later use, we keep a list of the 1000 genes with the highest CV²:\n\nhvg &lt;- names( head( sort( rowVars(fractions) / rowMeans(fractions), decreasing=TRUE ), 1000 ) )\n\nWe call these the “highly variable genes” (HVG).\n\n\nLog-transformation\nFor the more strongly expressed (and hence more informative) genes, SD seems to be proportional to mean, i.e., we have multiplicative noise. TO make this homoskedastic, we should logarithmize our fractions.\nHowever, \\(\\log(0)=-\\infty\\). As a “hack” to avoid this, let us as a small value to each faction before taking the log. Seurat used \\(10^{-4}\\).\nSo, if \\(k_{ij}\\) is the read count for gene \\(i\\) in cell \\(j\\) and \\(s_j=\\sum_i k_{ij}\\) the total read count for cell \\(j\\), we might use \\(\\log_{10}\\left(\\frac{k_{ij}}{s_j}+10^{-4}\\right)\\). However, is seems convenient to use a transformation that maps 0 to 0. Therefore, Seurat (and many other work flows use):\n\\[ y_{ij} = \\log_{10}\\left(\\frac{k_{ij}}{s_j}\\cdot 10^4 + 1\\right)\\]\nThe ``+1’’ is often referred to as the “pseudocount”, because it is roughly one extra read count – if \\(s_j\\) is around \\(10^4\\).\n\nexpr &lt;- log1p( fractions * 1e4 + 1 )\n\nTask: Compare with Seurat and check whether it uses natural or decadic logarithm.\nNote: The function log1p preserves the matrix’s sparse storage format. Why does this not work with log( 1 + . )?\n\n\nDistances\nLet’s pick a random cell and check its distance to all other cells, using Euclidean distance on expr.\n\ncell &lt;- sample.int( ncol(expr), 1 )\n\nhist( sqrt( colSums( ( expr - expr[,cell] )^2 ) ), 100 )\n\n\n\n\nRemembering that the cells fall into three “clusters”, we might have hoped to get a bimodal distribution, with the cells from the chosen cell’s own cluster being closer and the other being farther. This is not the case, even if we try many cells.\nPCA will save us, however.\n\n\nPCA\nWe perform a principal component analysis (PCA) on the expr matrix. To save time, we - calculate only the top 20 PCs, and use a PCA function that can take advantage of this and of the fact that our matrix is sparse - use only the 1000 most variable genes (as seen above)\n\npca &lt;- irlba::prcomp_irlba( t( expr[hvg,] ), n=20, center=TRUE, scale.=TRUE )\n\nrownames(pca$rotation) &lt;- hvg\nrownames(pca$x) &lt;- colnames(expr)\n\n\n\nDistances again\nNow, let’s try again with the distances:\n\ncell &lt;- sample.int( ncol(pca$x), 1 )\n\nhist( sqrt( rowSums( ( pca$x - pca$x[cell,] )^2 ) ), 100 )\n\n\n\n\nNow, for at least some cells, we get a clearly bimodal distribution.\n\n\nNeighbor graph\nAs we only have a small data set, we can calculate the full distance matrix:\n\ndm &lt;- as.matrix( dist( pca$x ) )\n\nQu: Pick two cells, calculate the Euclidean distance of the their PCA scores “manually” and compare with the matrix entry. It should agree.\nFor a given cell, find its 20 nearest neighbors:\n\ncell &lt;- 134\norder( dm[134,] )[1:20]\n\n [1]  134  878  933  237  590 1198  787 1873 1506 1306 1743 1024  965 1124 1713\n[16] 1726 1084  610  515 2438\n\n\nDo so for all cells:\n\nt(sapply( 1:ncol(expr), function(cell) \n  order( dm[134,] )[1:20] )) -&gt; nn\n\nMake a graph out of this\n\nlibrary( igraph )\n\n\nAttaching package: 'igraph'\n\n\nThe following object is masked from 'package:Seurat':\n\n    components\n\n\nThe following objects are masked from 'package:stats':\n\n    decompose, spectrum\n\n\nThe following object is masked from 'package:base':\n\n    union\n\n# ...\n\nApply a clustering algorithm onto it\n…"
  },
  {
    "objectID": "trajectory.html",
    "href": "trajectory.html",
    "title": "Trajectories",
    "section": "",
    "text": "Standard analysis\nWe load our usual example data\n\nsuppressPackageStartupMessages({\n  library( tidyverse )\n  library( Matrix )\n  library( sparseMatrixStats )\n  library( Seurat ) })\n\nReadMtx( \"~/Downloads/ifnagrko/ifnagrko_raw_counts.mtx.gz\",\n    \"~/Downloads/ifnagrko/ifnagrko_obs.csv\",\n    \"~/Downloads/ifnagrko/ifnagrko_var.csv\",\n    cell.sep=\",\", feature.sep=\",\", skip.cell=1, skip.feature=1, \n    mtx.transpose=TRUE) -&gt; count_matrix\n\n\ncount_matrix %&gt;%\nCreateSeuratObject() %&gt;%\nNormalizeData() %&gt;%\nFindVariableFeatures() %&gt;%\nScaleData() %&gt;%\nRunPCA( npcs=20 ) %&gt;%\nFindNeighbors( dims=1:20 ) %&gt;%\nFindClusters( resolution=0.5 ) %&gt;%\nRunUMAP( dims=1:20 ) -&gt; seu\n\nWarning: Feature names cannot have underscores ('_'), replacing with dashes\n('-')\n\n\nNormalizing layer: counts\n\n\nFinding variable features for layer counts\n\n\nCentering and scaling data matrix\n\n\nPC_ 1 \nPositive:  Apoe, Aldoc, Sparcl1, Sdc4, Ptn, Cmtm5, Glul, Gpr37l1, Fxyd1, Atp1b2 \n       S100a1, Slc4a4, Slc1a3, Prxl2a, F3, Itm2b, Mt1, Rgcc, Prdx6, Sfxn5 \n       Sat1, Scrg1, Dbi, Hes5, Luzp2, Plaat3, Pla2g7, Sash1, Plpp3, Sparc \nNegative:  Tubb5, Sox11, Tubb3, Stmn1, Jpt1, Hmgb3, Ptma, Sox4, Dlx2, Cd24a \n       Igfbpl1, Dlx6os1, Map1b, Stmn2, Abracl, Tmsb4x, Lmnb1, Cdca7, Ccnd2, Elavl4 \n       Cdk4, Dcx, Arx, Uchl1, EYFP, Celf4, Dlx5, Nrxn3, H1fx, Hmgn2 \nPC_ 2 \nPositive:  Ctss, C1qc, Laptm5, Csf1r, Trem2, C1qa, Cx3cr1, C1qb, Tyrobp, Ly86 \n       Fcer1g, Siglech, Selplg, Fcrls, Tmem119, Fcgr3, Apbb1ip, Unc93b1, Cd53, Lpcat2 \n       Spi1, Pld4, Olfml3, Irf8, Ctsh, Aif1, Cd300c2, Fyb, Otulinl, Mylip \nNegative:  Rorb, Cldn10, Clu, Mt3, Ntsr2, Mfge8, S1pr1, Id4, Slc1a2, Acsl6 \n       Plpp3, Sox9, Ddah1, Bcan, Cxcl14, Btbd17, Mlc1, Cspg5, Fjx1, Aqp4 \n       Ntm, Acsl3, Gabrb1, Tspan7, Lsamp, Chst2, Mt2, Lhx2, Slc39a12, Glud1 \nPC_ 3 \nPositive:  Atp1a3, Camk2b, Snhg11, Syt1, Nrip3, Kcnj4, Scg2, Snap25, Dnm1, Pcp4 \n       Icam5, Ndrg4, Eef1a2, Eno2, Ano3, Ryr2, Arpp21, Ptk2b, Gng4, Kcna4 \n       Penk, Slc4a10, Snca, Gad1, Rprml, Grin2a, C1qtnf4, Shisa8, Camk2a, Kcnb2 \nNegative:  Hmgb2, Top2a, Pbk, Birc5, Mki67, Cdk1, Cdca8, Spc24, Cenpf, Spc25 \n       Prc1, Rrm2, Mdk, Nusap1, Tpx2, Cdca3, Knl1, Ckap2l, Esco2, Aurkb \n       Cenpm, Ccna2, Bub1, Cks2, Kif11, Hist1h3c, Hist1h1b, Hmmr, Pclaf, Fbxo5 \nPC_ 4 \nPositive:  C1qc, C1qa, Ctss, Trem2, Csf1r, C1qb, Cx3cr1, Laptm5, Fcer1g, Tyrobp \n       Ly86, Siglech, Selplg, Fcrls, Fcgr3, Hexb, Spi1, Cd53, Itgb5, Pld4 \n       Ptgs1, Cd300c2, Aif1, Irf8, Fyb, Itgam, Cyth4, Ltc4s, Otulinl, Cd37 \nNegative:  Frzb, Apod, Npy, Plp1, Vtn, Foxd3, Wnt6, Nr2f2, Edil3, Sox10 \n       Gsn, Matn4, Fbln2, Aspa, Aqp1, Igf1, Plat, Lpar1, Igfbp4, Erbb3 \n       Fabp7, Plppr4, Ptgds, Col23a1, Alx3, Hey2, Cd59a, Fam3c, Scd1, Mybpc1 \nPC_ 5 \nPositive:  Stmn2, Igfbpl1, Cd24a, Nrep, Sox4, Map1b, Stmn4, Tubb3, Shtn1, Dlx6os1 \n       Dcx, Ly6h, Sox11, Jpt1, Mpped2, Stmn1, Plxna4, Pbx3, Elavl4, Uchl1 \n       Runx1t1, Cald1, Foxp2, Dlx2, Gad2, Celf4, Pfn2, Dlx5, Sp8, Tubb5 \nNegative:  Top2a, Pbk, Birc5, Mki67, Spc25, Cdk1, Prc1, Nusap1, Spc24, Esco2 \n       Tpx2, Knl1, Aurkb, Cenpf, Cdca8, Ckap2l, Kif11, Cdca3, Hist1h3c, Hmmr \n       Ccna2, Bub1, Incenp, Hist1h2af, Ndc80, Cit, Fbxo5, Kif4, Sgo1, Kif22 \n\n\nComputing nearest neighbor graph\n\n\nComputing SNN\n\n\nModularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck\n\nNumber of nodes: 18302\nNumber of edges: 616069\n\nRunning Louvain algorithm...\nMaximum modularity in 10 random starts: 0.9191\nNumber of communities: 19\nElapsed time: 5 seconds\n\n\nWarning: The default method for RunUMAP has changed from calling Python UMAP via reticulate to the R-native UWOT using the cosine metric\nTo use Python UMAP via reticulate, set umap.method to 'umap-learn' and metric to 'correlation'\nThis message will be shown once per session\n\n\n12:04:48 UMAP embedding parameters a = 0.9922 b = 1.112\n\n\n12:04:48 Read 18302 rows and found 20 numeric columns\n\n\n12:04:48 Using Annoy for neighbor search, n_neighbors = 30\n\n\n12:04:48 Building Annoy index with metric = cosine, n_trees = 50\n\n\n0%   10   20   30   40   50   60   70   80   90   100%\n\n\n[----|----|----|----|----|----|----|----|----|----|\n\n\n**************************************************|\n12:04:51 Writing NN index file to temp file /tmp/Rtmp4gTY5z/file33b7e39258597\n12:04:51 Searching Annoy index using 1 thread, search_k = 3000\n12:05:01 Annoy recall = 100%\n12:05:01 Commencing smooth kNN distance calibration using 1 thread with target n_neighbors = 30\n12:05:02 Initializing from normalized Laplacian + noise (using RSpectra)\n12:05:07 Commencing optimization for 200 epochs, with 776086 positive edges\n12:05:18 Optimization finished\n\n\n\nUMAPPlot( seu, label=TRUE ) + coord_equal()\n\n\n\n\nThis time, we will concetrate on the long elongated main structure, which we will call the “lineage” in the following. It is a snapshot of the development of astrocytes that act as neural stem cells and become transient amplifying progenitors (TAPs) which undergo cell cycle, i.e., divide and multiply, and the turn into neuroblasts and finally neurons.\nTo orient us in the plot, we highlight the expression of Aqp4 (aquaporin-4, a marker for astrocytes), Mki67 (a marker for prliferating, i.e., dividing cells), Dcx (doublecortin, a marker for neuroblasts) and Gria1 (Glutamate ionotropic receptor, AMPA type, subunit 1; a marker for mature neurons)\n\nFeaturePlot( seu, c( \"Aqp4\", \"Mki67\", \"Dcx\", \"Gria1\" ) )\n\n\n\n\nWe conclude that the lineage is well covered by the following clusters\n\nlineage_clusters &lt;-  c( 10, 9, 0, 13, 14, 3, 5, 6, 11, 1, 2, 7 ) \n\nJust out of curiosity, we also try to identify clusters 4 and 8:\n\npresto::wilcoxauc(\n  LayerData(seu),\n  factor(case_when(\n    seu$seurat_clusters %in% lineage_clusters ~ \"lineage\",\n    seu$seurat_clusters %in% c( 4, 8 ) ~ \"4_or_8\",\n    TRUE ~ \"other\" )) ) -&gt; wa\n\nhead(wa)\n\n  feature  group     avgExpr         logFC statistic       auc         pval\n1    Xkr4 4_or_8 0.003235569 -0.0303111155  16421626 0.4862780 1.501567e-12\n2     Rp1 4_or_8 0.000000000 -0.0004121176  16877733 0.4997842 3.431328e-01\n3   Sox17 4_or_8 0.000000000 -0.0098443771  16794453 0.4973181 8.092744e-04\n4 Gm37323 4_or_8 0.000000000 -0.0006945437  16872528 0.4996301 2.144507e-01\n5  Mrpl15 4_or_8 0.080757542 -0.0771071674  15531646 0.4599238 2.285892e-20\n6  Lypla1 4_or_8 0.023977097  0.0007956678  16912116 0.5008024 6.802492e-01\n          padj    pct_in     pct_out\n1 5.070133e-12 0.4322767  3.16892725\n2 4.356080e-01 0.0000000  0.04315660\n3 1.635191e-03 0.0000000  0.53637485\n4 2.968308e-01 0.0000000  0.07398274\n5 9.783259e-20 9.4140250 17.29963009\n6 7.320138e-01 3.0259366  2.86066584\n\n\n\npresto::top_markers( wa )\n\n# A tibble: 10 × 4\n    rank `4_or_8` lineage other  \n   &lt;int&gt; &lt;chr&gt;    &lt;chr&gt;   &lt;chr&gt;  \n 1     1 Fabp7    Tubb2b  Rhob   \n 2     2 Apod     Meis2   Bin1   \n 3     3 Npy      Fabp5   Trf    \n 4     4 Ptn      Pfn2    Sgk1   \n 5     5 Frzb     Gpm6a   Serinc3\n 6     6 Plp1     Ccdc88a Abcg1  \n 7     7 Gsn      Pantr1  Jund   \n 8     8 Nr2f2    Pou3f2  Jun    \n 9     9 Matn4    Foxg1   Smad7  \n10    10 Itm2b    Gnao1   H2-D1  \n\n\nAs a try, I’ve asked ChatGPT what these genes point to and it replied that the cells in our clusters 4 and 8 are oligondendrocyte precursor cells (OPCs). This matches my expectation.\n\n\nAim: Trajectory\nOur first aim for today is to fit a “pseudotime trejectory” to the lineage. This means thatw e want to assign to each cell in the lineage a real number, which we call it “pseudotime” that monotonally increases along the putative developmental trajectory from astrocytic neural stem cells via TAPs and neuroblasts to neurons.\nWe will do this by fitting a “principal curve”, i.e. a curve in PCA space that tracks along the lineage and is fitted such that the squared sum of the cells’ distance to their respectively closest point on the curve (their projection image) is minimal. The distance of this projection image to the curve start (measured along the curve) will be used as pseudotime.\nThe “principal curve” method is described in detail in this section of the lecture notes.\nHere, we will use the function from the princurve package.\nAs preparation, we first explore distances with sleepwalk:\n\nsleepwalk::sleepwalk( Embeddings(seu,\"umap\"), Embeddings(seu,\"pca\") )\n\nWe notice that the cycling cells have a lot of distance to the non-cycling lineage cells. This will cause problems because the principal curve alorithm cannot deal with loops, i.e., the curve should pass besides the cell-cycle loop. However, the distances to the curve will then become large right in the middle, deflecting the curve.\nTherefore, let’s exclude clusters 6 and 11:\n\nlineage_clusters_2 &lt;- setdiff( lineage_clusters, c( 6, 11 ) )\n\n\n\nFitting the principal curve\nNow, we could the princomp package to fit the principal curve\n\nprincurve::principal_curve( \n  Embeddings(seu,\"pca\")[ seu$seurat_clusters %in% lineage_clusters_2, ], \n  df=10, trace=TRUE, approx_points=1000 ) -&gt; prc\n\nStarting curve---distance^2: 38216203191\nIteration 1---distance^2: 777432.5\nIteration 2---distance^2: 595846\nIteration 3---distance^2: 569788.5\nIteration 4---distance^2: 558439.6\nIteration 5---distance^2: 549200.9\nIteration 6---distance^2: 544509.5\nIteration 7---distance^2: 542890.9\nIteration 8---distance^2: 541627.2\nIteration 9---distance^2: 538015.4\nIteration 10---distance^2: 524569.8\n\n\nThis function returns for each cell a pseudotime value lambda and a projected position on the curve in PCA space, s.\n\nEmbeddings(seu,\"umap\") %&gt;%\nas_tibble( rownames=\"cell\" ) %&gt;%\nleft_join( enframe( prc$lambda, \"cell\", \"lambda\" ) ) %&gt;%\nggplot +\n  geom_point( aes( x=umap_1, y=umap_2, col=lambda ), size=.3 ) +\n  coord_equal() + scale_color_viridis_c(option=\"D\")\n\nJoining with `by = join_by(cell)`\n\n\n\n\n\nWe can assign a pseudotime to the remaining cells by finding the closest curve point:\n\nFNN::get.knnx( prc$s, Embeddings(seu,\"pca\"), 1 ) -&gt; nnres\n\nprc$lambda[ nnres$nn.index[,1] ] %&gt;%\n  { ( max(.) - . ) / max(.) } %&gt;%\n  set_names( rownames(Embeddings(seu,\"pca\")) ) -&gt; seu$pt\n\nHer we have rescaled the pseudotime to [0;1] and also reversed the dirction, so thjat it now increases from stem cells towards neuroblasts.\n\nEmbeddings(seu,\"umap\") %&gt;%\nas_tibble( rownames=\"cell\" ) %&gt;%\nleft_join( enframe( seu$pt, \"cell\", \"pt\" ) ) %&gt;%\nggplot +\n  geom_point( aes( x=umap_1, y=umap_2, col=pt ), size=.3 ) +\n  coord_equal() + scale_color_viridis_c(option=\"D\")\n\nJoining with `by = join_by(cell)`\n\n\n\n\n\nWe should also check how for each cell is from the curve\n\nnnres$nn.dist[,1] %&gt;%\n  set_names( rownames(Embeddings(seu,\"pca\")) ) -&gt; seu$dist_to_curve\n  \nEmbeddings(seu,\"umap\") %&gt;%\nas_tibble( rownames=\"cell\" ) %&gt;%\nleft_join( enframe( seu$dist_to_curve, \"cell\", \"dist\" ) ) %&gt;%\nggplot +\n  geom_point( aes( x=umap_1, y=umap_2, col=dist ), size=.3 ) +\n  coord_equal() + scale_color_viridis_c( option=\"D\", trans=\"log10\", direction=-1 )  \n\nJoining with `by = join_by(cell)`\n\n\n\n\n\n\n\nExpression dynamics\nHere is a plot showing the expression of one gene, Slc1a3 (Glast), along the pseudotime:\n\ntibble(\n  pt = seu$pt, \n  dist = seu$dist_to_curve,\n  in_lineage = seu$seurat_clusters %in% lineage_clusters,\n  expr = LayerData(seu)[\"Slc1a3\",] ) %&gt;%\nmutate( expr = ifelse( expr&gt;0, expr, runif( n(), -.2, 0 ) ) ) -&gt; tbl\n\ntbl %&gt;%\nfilter( in_lineage ) %&gt;%\nggplot +\n  geom_point( aes( x=pt, y=expr, col=dist ), size=.3 ) +\n  scale_color_viridis_c()\n\n\n\n\nIn order to make more apparent how many point are on the zero line, this line has been broadened.\nWe now fit a smooth curve through this scatter plot. As we want to do this properly, we use locfit with Poisson GLM, i.e., wo don’t use the log-normalized values but the raw counts. (Details here.)\nFirst we assemble the data\n\nlibrary( locfit )\n\ntibble(\n  pt = seu$pt, \n  dist = seu$dist_to_curve,\n  in_lineage = seu$seurat_clusters %in% lineage_clusters,\n  count = LayerData(seu,\"count\")[\"Slc1a3\",],\n  total = colSums( LayerData(seu,\"count\") ),\n  expr = LayerData(seu)[\"Slc1a3\",] ) %&gt;%\nmutate( expr = ifelse( expr&gt;0, expr, runif( n(), -.2, 0 ) ) ) -&gt; tbl\n\nhead(tbl)\n\n# A tibble: 6 × 6\n      pt  dist in_lineage count total   expr\n   &lt;dbl&gt; &lt;dbl&gt; &lt;lgl&gt;      &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;\n1 0.143  37.5  FALSE         11  8934  2.59 \n2 0.432   2.05 TRUE           0  7672 -0.126\n3 0.0468  7.45 TRUE          11  6889  2.83 \n4 0.0946  2.99 TRUE          24  5131  3.87 \n5 0.470   4.34 TRUE           0  5988 -0.136\n6 0.0355  3.98 TRUE          24  9866  3.23 \n\n\nThe we run lucfit:\n\nfit &lt;- locfit( count ~ pt, tbl, weight=total, family=\"poisson\" )\n\nfit\n\nCall:\nlocfit(formula = count ~ pt, data = tbl, weights = total, family = \"poisson\")\n\nNumber of observations:          18302 \nFamily:  Poisson \nFitted Degrees of freedom:       5.033 \nResidual scale:                  1 \n\n\nWe evaluate the fitted curve along a value grid:\n\ntibble( pt = seq( 0, 1, length.out=1000 ) ) %&gt;%\nmutate( y = predict( fit, pt ) ) -&gt; tbl_fit\n\nhead(tbl_fit)\n\n# A tibble: 6 × 2\n       pt       y\n    &lt;dbl&gt;   &lt;dbl&gt;\n1 0       0.00562\n2 0.00100 0.00556\n3 0.00200 0.00550\n4 0.00300 0.00544\n5 0.00400 0.00539\n6 0.00501 0.00533\n\n\nNow we can do the plot:\n\ntbl %&gt;%\nfilter( in_lineage ) %&gt;%\nggplot( aes( x=pt ) ) +\n  geom_point( aes( y = count/total + 1e-4, col=dist ), size=.3 ) +\n  geom_line( aes( y = y ), data=tbl_fit, col=\"magenta\" ) +\n  scale_color_viridis_c() + scale_y_log10()\n\n\n\n\n\nMany genes\nWe can run this for several genes. We pick the 10 genes with the highest variance of expression along the lineage:\n\nLayerData(seu)[ , seu$seurat_clusters %in% lineage_clusters ] %&gt;%\nrowVars() %&gt;%\nsort( decreasing=TRUE ) %&gt;%\nhead(10) %&gt;% names() -&gt; genes\n\ntg2 &lt;- seq( 0, 1, length.out=300 )\n\nsapply( genes, function(gene) {\n  fit &lt;- locfit( LayerData(seu,\"count\")[gene,] ~ seu$pt, \n          weight=seu$nCount_RNA, family=\"poisson\" )\n  cat(\".\") \n  predict( fit, tg2 )\n} ) %&gt;% t() -&gt; fits\n\n..........\n\nfits[1:5,1:5]\n\n              [,1]        [,2]        [,3]        [,4]        [,5]\nCst3   0.035855217 0.036309867 0.036712272 0.037061176 0.037355581\nSlc1a2 0.012262572 0.012061551 0.011850005 0.011628884 0.011399137\nMt3    0.008338254 0.008389786 0.008422263 0.008435714 0.008430298\nClu    0.004685951 0.005009726 0.005326528 0.005632580 0.005924104\nMt1    0.009045342 0.008951637 0.008849940 0.008740681 0.008624301\n\n\nThis time, we have evaluated the smoothed curve at a grid of 300 values and got a matrix with one row per gene and one column for each of the 300 time points.\nTo visualize this, we use a heatmap:\n\nimage( t(fits) )\n\n\n\n\nThe genes have different dynamic range. Hence, we should divide each row by its maximum:\n\nfitsz &lt;- fits / rowMaxs(fits)\nimage( t(fitsz), yaxt=\"n\" )\naxis( 2, seq( 0, 1, length.out=nrow(fitsz) ), rownames(fitsz), las=2, cex.axis=.5 )\n\n\n\n\nNow, let’s also sort the rows by the positions of these maxima, and replace the colour scale:\n\nfitszs &lt;- fitsz[ order( -apply( fitsz, 1, which.max ) ), ]\nimage( t(fitszs), yaxt=\"n\", col=viridisLite::viridis(300) )\naxis( 2, seq( 0, 1, length.out=nrow(fitszs) ), rownames(fitszs), las=2, cex.axis=.5 )\n\n\n\n\nThe same now with the top hundred genes:\n\nLayerData(seu)[ , seu$seurat_clusters %in% lineage_clusters ] %&gt;%\nrowVars() %&gt;%\nsort( decreasing=TRUE ) %&gt;%\nhead(100) %&gt;% names() -&gt; genes\n\nsapply( genes, function(gene) {\n  fit &lt;- locfit( LayerData(seu,\"count\")[gene,] ~ seu$pt, \n          weight=seu$nCount_RNA, family=\"poisson\" )\n  cat(\".\") \n  predict( fit, tg2 )\n} ) %&gt;% t() -&gt; fits\n\n....................................................................................................\n\n\n\nfitsz &lt;- fits / rowMaxs(fits)\nfitszs &lt;- fitsz[ order( -apply( fitsz, 1, which.max ) ), ]\nimage( t(fitszs), yaxt=\"n\", col=viridisLite::viridis(300) )\naxis( 2, seq( 0, 1, length.out=nrow(fitszs) ), rownames(fitszs), las=2, cex.axis=.5 )"
  },
  {
    "objectID": "overview_hts.html",
    "href": "overview_hts.html",
    "title": "Overview High-throughput Sequencing",
    "section": "",
    "text": "DNA Sequencing\n\nSanger sequencing\n\nWith Sanger’s invention of what is now called Sanger sequencing (1977) it became possible to read off the sequence of DNA molecules. Typically, one can read several hundreds of bases from one end towards the other end.\nFor Sanger sequence, one needs a huge amount of copies of the same DNA fragments.\nFortunately, it is easy to exponentially amplify DNA with the polymerase-chain reaction (PCR) which is able to duplicate DNA molecules and so doubles the number of molecules in each reaction cycle.\nAvailability of commercial Sanger sequencers (from 1984 on) with read-out via fluorescent light (in 4 colours) made it possible to sequence, e.g., the entire human genome (“completed” 2003).\nSanger sequencing works in solution. The liquid solution must contain copies of only one sequence; as one otherwise gets an unreadable mixture of sequencing signals from the different sequences.\n\n\n\nHigh-throughput sequencing\n\nIn the early 2000s, ideas came up to fix the DNA fragments to a surface and perfrom the DNA such that the copies attach to the surface in clsoe proximity.\nThus, one can spread many different DNA fragments over the surface and amplify each fragment into a “cluster” of copies. As the surface offers space for millions of spatially separated clusters, one can obtain the sequences of millions of different DNA fragments in parallel.\nSuch high-throughput sequencing (HTS) machines became available in the 2000s and have sense continuously improved in throughput and cost effectiveness.\nThe method described above has been commercialized by Solexa, which was then bought by Illumina. It was not the first, but one of the first HTS methods. Illumina is still market leader for HTS machines.\nNow, it is possible to obtain a human subject’s (nearly) complete genome within two days for a few hundred euro.\nThe approach is to obtain DNA from many cells and fragment it into many pieces of a few hundred base-pairs (bp) length.\nThe number of sequencing reads that overlap a give base pair in the genome is Poisson distributed.\nThe expected number of fragments (the “coverage” rate) depends on the total number of sequencing reads obtained.\nTherefore, a trade-off has to be made between cost-effectiveness and completeness.\n\n\n\nTranscriptomics / RNA sequencing\n\nAll cells of an individual have the same DNA, but they differ vastly in shape and function. (Compare a blood cell with a skin cell.)\nThis is because different cells express (i.e., transcribe) different genes, because they need different proteins.\nWhich genes a cell expresses and to what extent is regulated by complicated biochemical reactions.\nHence, a cell’s type and state is reflected to a good extent by its RNA content, also called its “transcriptome”.\nTherefore, a comparably simple way to get a large amount of information about what is goin on in a biological sample is to extract the RNA from all the cells and sequence it.\nRNA can be readily transformed into complimentary DNA (using a process called reverse transcription, that can easily performed in vitro), and this DNA is the sequenced using HTS.\n\n\n\nAnalysis of RNA-Seq data\n\nWhen performin RNA sequencing, one obtains a very long list with sequences of the RNA fragments (the “reads”), typically as text file in FASTQ format.\nOne then aligns the reads to the genome: A special program, called a short-read aligner is used to search for the sequence of each read in the genome (i.e., in a reference assembly). Of course, the aligner has to search through the chromosome sequences and their reverse complements.\nThe aligner should be splice-aware, i.e., expect that a read might strecth over an intron and hence align to two places with a gap in between.\nThe aligner produces a file (typically in SAM format) that give for each read the position in the genome where the sequence matched. Typically, the chromosome name is given, the position in the chromosome (as an integer) where the read’s match starts, the strand (“+” for match to the sequence as given, “-” for match to the reverse complement), followed by information on skipped parts (introns), descripancies between reference and read (mismatched bases) etc.\nA portion of the reads will stay “unmapped” (i.e., the aligner could not find their sequence in the genome), and some reads might match several loci (positions) in the genome.\nUsing a genome annotation file (which contains the genetic coordinates of all genes with their transcripts and exons), another software then determines for each read which gene it is from.\nIn the end, we get for each gene a count: a number telling us how many sequencing reads were seen that mapped to this gene.\n\n\n\nBulk RNA-Seq\n\nUsually one performs RNA-Seq in order to compare the transcriptome of differend types of samples.\nFor example, one might compare tumor samples with samples from adjacent normal tissues. In order to make sure that results are general and not specific to on subject, one needs sample pairs from several, or, ideally, many, patients. Genes whose expression is constistently stronger in the tumor samples than in the corresponding normal samples might be the genes that cause the tumour’s malignancy.\nOther useful comparisons might be\n\nCompare tissue samples from mice that have been treated with some drug with “control mice” which have received a placebo, to see how the drug influences the cells’ function.\nCompare samples from different tissues, to understand the difference between them.\nand many more\n\nIn most cases, the goal is to find differentiaklly expressed genes (DGEs), i.e., genes whose expression strength differs in a consistent (i.e., statistically significant) manner between the sample groups\n\n\n\nSingle-cell RNA-Seq\n\nTissues comprise many cell types.\nFor example, skin contain keratinocyte (which make up the skin’s sturdy outer layer), other epithelial cells (comprising e.g. the soft lower layer), cells making up the hair follicles, even muscle cells that can raise the hairs and, of course, the endothelial cells that line the blood capillaries and the various blood cells inside these, as well as receptor and nerve cells so that we can sense touch, heat, cold and pain etc.\nIf we find genes that are differentially expressed between, say, healthy skin and skin affected by a disease – which of these cell types is affected? Is the gene upregulated (i.e., expressed more strongly) in all cell types or only in some.\nWe would need to know which of the sequencing reads come from which cell.\n\nIn single-cell RNA-Seq we can tell whether two reads come from the same cell or from two different cells.\nThere are at least three possible ways to achieve this. - Plate-based methods: A microtiter plate is used (a grid-like arrangement of many miniature “test tubes” called “wells”) and a flow cytometer is used to place exactly one cell into each well. - Microfluidic methods: An emulsion of water droplets in oil is produced using microfluidics such that each water-in-oil droplet contains (ideally) at most one cell. - Combinatorial indexing: We skip the explanation for these.\nEach compartment (well or droplet) gets a “DNA barcode oligo”: a short piece of DNA with a random sequence that gets incorporated into the cDNA during reverse transcription. Thus, each sequenced fragment contains teh sequence of the RNA fragment, together with this “cell barcode” that identifies the compartment (and hence the cell) that the read came from.\nWe will get back to details on how this works.\n\n\nPreprocessing of single-cell RNA-Seq data\n\nAs before, each reads gets aligned to the genome. Afterwards, the gene that the read maps to is identified.\nAdditionally, the cell barcode is analysed. A list of all cell barcodes that appear in the sample is generated, and each read is assigned to one element in this list.\nThe final result is a count matrix:\n\nThe rows of the matrix correspond to genes.\nThe columns correspond to cell barcodes and hence cells.\nThe matrix entries tell how many reads have been found that mapped to this gene and seemed to originated from the cell with this barcode.\n\n\nThere are a number of complications that we will need to discuss: - A barcode may be corrupted by a read error, causing a read to be assigned to the wrong cell. - A compartment may not have contained a cell but still contained a few RNA molecules that were present in the solution, stemming from destroyed cells with broken cell membrane. Such barcode will have very few reads assigned to them, and we have to recognize them as not being cells. - A compartment might have contained more than one cell, and thus a mixture of RNA from several cells of possibly different type. This is called a “doublet”.\nThe main issue, however, is: The process is very lossy. A typical mammalian cell contains a several hundred thousands of mRNA molecules, but we usually only get a few thousand (microfluidics methods) or at best up to around 20,000 reads (plate-based methods).\nWhich molecules get sequenced is a random process, and we need to take care of the “counting noise” thus produced.\nMany genes are produced by the cells at very low copy numbers, and with the selection during sequencing, we will very frequently end up with a zero count. The count matrix is therefore very sparse (i.e., a large fraction of the matrix elements have the value 0)."
  },
  {
    "objectID": "biology_primer.html",
    "href": "biology_primer.html",
    "title": "Biology Primer",
    "section": "",
    "text": "This document lists some basic facts on molecular biology for the non-biologists in the audience – even though you should remember these points from high school.\n\nDNA\n\nA cell’s genetic information is stored in its DNA (desoxyrobonucleic acids). DNA is a polymer, i.e., it is made as a long chain of repeating elements, the nucleotides, which are linked by phosphate bonds.\nThere are four nucleotides: adenine (A), cytosine (C), guanine (G) and thymine (T). The information stored in the DNA is represented by the sequence of these elements.\nDNA is a double-helix, comprising two strands running in opposite direction whose bases are paired up (base pairing). Adenine always pairs with thymine (AT), cytosine with guanine (CG.\nTherefore, the sequences of the two strands are related to each othe by the operation of reverse complementation, i.e., reversing the sequence, and replacing each base by its complementary base (i.e., swapping A↔︎Tv and G↔︎T). Example:\n\n&gt;&gt;&gt;&gt; AGGCTCAGT &gt;&gt;&gt;&gt;   (first strand, read from left to right)\n&lt;&lt;&lt;&lt; TCCGAGTCA &lt;&lt;&lt;&lt;   (second strand, read from right to left)\n\nEach base pair (bp) in the genome contains 2 bit of information.\nTo make copies of DNA, the cell uses enzymes called polymerases which seperate the two strands and use one of the strands as “template” to assemble a new strand by base-pairing.\nPolymerases are used to duplicate the DNA for cell division, and to make RNA (see below).\nIn eukaryotes (cells with proper cellular nucleus), DNA is organized in chromosomes: long linear chains. In procaryotes (bacteria and archae, which do not have a nucleus), DNA forms a loop. Eukaryotes also contain mitochondriae (abbreviated MT) which contain a DNA loop like prokaryotes.\nThe chromosomes are numbered (for humans: from 1 to 22) except for the sex chromosomes, which are denoted X and Y.\nA reference assembly is a set of sequences for a species’ chromosomes that is used to describe a “typical” or “average” individual’s DNA.\nThere are databases that describe which parts of the DNA sequence is the same in (nearly) all individuals and which parts tend to vary between individuals (polymorphisms).\n\n\n\nRNA\n\nIn order to “make use of”work” with DNA, the cell can make a copy of a defined stretch of the DNA. This copy is made as RNA, a chemical variant of DNA, and is single-stranded, i.e. not a double helix.\nIn RNA, the base thymine (T) is replaced by uracil (U).\nThe process of making an RNA copy of DNA is called transcription, the produced RNA is called a transcript.\nA region of DNA that is regularly transcribed to RNA is called a gene.\nAn important class of transcripts are those that conatin “blueprints” for proteins. The genes producing these are called protein-coding genes.\n\n\n\nDirections\n\nChromosomes have a special region in the middle called the centromer that divides the chromsome into two arms. By convention, the shorter arm (p arm) is on the left, and the base pairs are numbered from left to right, starting either with 1 or 0.\nIn RNA, sequences are written in the same order in which they are chained by the polymerase and read by the ribosome. The start is called the 5’ end, the end (in reading direction) is called the 3’ end.\n\n\n\nProteins\n\nProteins are polymeric macromolecules formed from chains of amino acids.\nProteins that catalyze chemical reactions are called enzymes. They are the molecular machines that make living cells possible.\nStructural proteins, in contrast, are building blocks for the cells structure.\nProteins are polymers of basic building blocks, the amino acids (AAs), that are connected via the so-called peptide bond.\nThere are 20 proteinogenic amino acids (+2 special ones).\nA protein is defined by the sequence of these amino acids.\nA special molecular machine, the ribosome, assembles proteins by chaining together individual amino acids. It reads of the requried sequence of the amino acids from an RNA transcript called a messenger RNA.\nThis process is called translation\nWhile the linear AA chain is assembled the nascent protein folds into a complicated 3D shape that is crucial for its function. This happens due to chemical attractions and repulsions between the amino acids in the chain and between an amino acid and the surrounding water molecules.\nThe amino acids all differ in their chemical properties, thus making a wide variety of such interactions possible.\n\n\n\nThe genetic code\n\nAn RNA transcript that can be processed by a ribosome to build a protein is called “messenger RNA” (mRNA).\nIt contains a sequence of groups of three bases each, called codons. Each of the \\(4^3\\) possible codons codes for an amino acid, except for the stop codon that instructs the ribosome to finish the translation and release the finished protein.\nAs there are 20 amino acids (and the stop signal), the code is redundant: For each meaning there are 2 to 4 codons.\nHere is the genetic code.\n\n\n\nTranscript types\nThere are several types of genes/transcripts:\n\nProtein-coding genes are transcribed to messenger RNA (mRNA), which are read by ribosomes and serve as “blueprint” for assembling proteins.\n\nAn mRNA transcript has three parts: The part in the middle is called the coding sequence (CDS), which contains the sequence of codons, always starting with AUG (the codon for methionine, that also serves as start signal).\nThe part before the transcription start signal is called the 5’ untranslated region (5’-UTR).\nThe part after the stop codon is called the 3’ untranslated region (3’ UTR).\nIn most cases, the 3’ UTR is followed by a multiple adenines, called the poly-A tail.\n\nOther transcripts are called non-coding. There are several:\n\nRibosomal genes are transcribed to ribosomal RNA (rRNA). These fold into a special shape that can catalyze reactions (a ribozyme) and form the core of the ribosome. The vast majority of a cell’s RNA is rRNA.\nTransfer RNA (tRNA) are short pieces of RNA that hold individual amino acids and supply them to the ribosomes.\nsmall nucleolar RNAs (snoRNAs) have a role in splicing (see below).\nmicro-RNAs (miRNAs) and long non-coding RNAs (lncRNAs) are various other RNA that have regulatory roles, e.g., they influence how often a messenger transcript gets translated before it gets degraded.\n\n\n\n\nSplicing and isoforms\n\nWhile a (protein coding or a long non-coding) gene is transcribed, a machinery called the spliceosome cuts out large parts of the produced transcripts, reducing the initial “pre-mRNA” to a much shorter “mature mRNA”. The removed parts are called introns, the remaining parts (that are chained together) are called exons. The places wher the RNA is cut are called splice sites.\nDepending on many factors, one gene can give rise to different transcripts (transcript isoforms) that differ in where the transcription starts, where is terminates (or: where the poly-A tail is attached) and which splice sites are used.\nA “gene model” is teh information what isoforms have been observed to be produced by a gene. A collection of models for all genes, togetehr with the transcript types (see above) is called a “gene annotation” for a reference assembly."
  },
  {
    "objectID": "principal_curves.html",
    "href": "principal_curves.html",
    "title": "Principal Curves",
    "section": "",
    "text": "Motivation\nOften, objects in feature space form point clouds that are elongated in one direction, which, however, is typically not shaped. Think of a long, curved, banana, or a pool noodle bent into a complex shape: draw random points from its volume and you have an example for such a point cloud.\nOur aim is to find a curve that describes the “center line” through such a point cloud.\n\n\nExample data\nIn practice, the problem usually arises with high-dimensional data, but to discuss approaches to solve it, it might be better to use example data that lives in a 2D space, as this is easy to visualize.\nThe following code uses splines to construct a curve that will serve as example.\nWe first set a number of control points:\n\nknots &lt;- cbind(\n  x = c( 0.1, 1.0, 1.7, 2.5, 2.8, 2.4, 2.2, 3.2, 4.0, 5.2 ),\n  y = c( 1.0, 1.2, 1.7, 1.9, 1.5, 1.1, 0.2, 0.6, 1.1, 1.2 ) )\n\nplot( knots, type=\"b\", asp=1 )\n\n\n\n\nNext, we use these points as guides to get a smooth (continuous and differentiable) curve:\n\nspline_basis &lt;- splines::bs( seq( 0, 1, l=1000), df=nrow(knots), intercept=TRUE )\n\nplot( knots, asp=1 )\nlines( spline_basis %*% knots, col=\"blue\" )\n\n\n\n\nWe will skip over an explanation how the bs function is used in this example to construct x and y coordinates, as out goal is just to get some non-trivial curve.\nNow we select random points along this curve (sampling the curve uniformly), and add some Gaussian noise to the 2D coordinates.\n\nset.seed( 13245768 )\nt &lt;- runif( 1000 )\n\nx &lt;- splines::bs( t, df=nrow(knots), intercept=TRUE ) %*% knots +\n  matrix( rnorm( 2000, 0 , .1), ncol=2 )\n\nThis will be our data. We will use it instead of our usual PCA scores. Here’s a plot of the data, with the original curve as dahsed line.\n\nplot( x, col=\"gray\", asp=1 )\nlines( spline_basis %*% knots, col=\"blue\", lty=\"dashed\" )\n\n\n\n\n\n\nFirst try with princurve\nCan we reconstruct the curve from the data? Let’s try, using the “princurve” package, which implements the method we will discuss below:\n\nprc &lt;- princurve::principal_curve( x )\n\nHere’s the curve that we got (in brown):\n\nplot( x, col=\"gray\", asp=1 )\nlines( prc$s[ prc$ord, ], col=\"brown\" )\nlines( spline_basis %*% knots, col=\"blue\", lty=\"dashed\" )\n\n\n\n\nThe principal curve algorithm tries to find a curve \\(\\mathbf{f}:[0,1]\\rightarrow\\mathbb{R}^n\\)\n\nstart with an initial guess \\(\\mathbf{f}^{(0)}\\) for the curve. The standard heuristic here is to perform a PCA on the data, and take a line through the origin, in the direction of the first PC, as \\(\\mathbf{f}^{(0)}\\).\nRepeat until convergence, using \\(i\\) as iteration counter, starting with \\(i=0\\):\n\nExtend the curve by linear extrapolation at both ends.\nProject each data point \\(\\mathbf{x}_i\\) onto the curve, i.e. find the argument \\(t\\) for the curve point closest to the data point: \\[ t_k^{(i)} = \\operatorname{arg min}_t \\|\\mathbf{x}_k - \\mathbf{f}^{(i)}(t)\\| \\] This gives us an ordering of the data points.\nFit a new curve \\(\\mathbf{f}^{(i+1)}\\) by regresing each of the coodinates of the \\(\\mathbf{x}_k\\) onto the \\(t_k^{(i)}\\) using either spline regression or local regression.\n\n\nBy default, princurve uses spline regression (as provided by the R basis function stats::smooth.spline). (Again, we unfortunately don’t have the time to discuss spline regression.)\nTo get a better result than what we just saw, we should increase the number of degrees of freedom (i.e., number of knots) for the spline smoother:\n\nprc &lt;- princurve::principal_curve( x, df=10 )\n\nplot( x, col=\"gray\", asp=1 )\nlines( prc$s[ prc$ord, ], col=\"brown\" )\nlines( spline_basis %*% knots, col=\"blue\", lty=\"dashed\" )\n\n\n\n\n\n\nReimplementing princurve\nNow, let’s try to reimplement this by hand to understand what princurve does.\n\nInitialization\nWe first need an initial guess for an assignment of points to pseudotime values.\nTo this end, we perform a PCA on the data\n\npca &lt;- prcomp( x )\n\nHere’s the direction of the first PC:\n\nplot( x, col=\"gray\", asp=1 )\nabline( a = 1.5, b = pca$rotation[\"y\",\"PC1\"] / pca$rotation[\"x\",\"PC1\"] )\n\n\n\n  # abline draws a line with intercept a (here chosen arbitrarily ) and\n  #    slope b (here taken from principal component 1)\n\nThe scores along PC1 are the orthogonal projections of the data points onto thie line. This will be our initial guess for the pseudotime, i.e., serve as a first rough ordering of the data points:\n\npt &lt;- pca$x[,\"PC1\"]\n\n\nscale_colors &lt;- function(t) \n  rje::cubeHelix(130,r=4)[ ceiling( ( t - min(t) ) / ( max(t) - min(t) ) * 99 ) + 1 ]\n\nplot( x, col=scale_colors(pt), asp=1, cex=.5 )\n\n\n\n\n\n\nRegression step\nNow, consider each coordinate dimension \\(i\\) of the data separately, and perform a smoothing spline regression of the \\(i\\)-th component of the data vectors onto the pseudotime:\n\nfits &lt;- lapply( 1:2, function(i) smooth.spline( pt, x[,i], df=10 ) )\n\nHere’s a plot of the fits:\n\nfor( i in 1:2 ) {\n  plot( pt, x[,i], asp=1, cex=.2, main=i )\n  lines( fits[[i]], col=\"red\" )\n}\n\n\n\n\n\n\n\nWe construct a fine grid of equispace pseudotime values, that extends a bit outwards the interval covered by our current pseudotime values:\n\ntg &lt;- seq(\n  from = min(pt) - .3 * ( max(pt) - min(pt) ),\n  to   = max(pt) + .3 * ( max(pt) - min(pt) ),\n  length.out = 10000 )\n\nNow, we calculate the curve points at these pseudotime points\n\ncurve &lt;- sapply( fits, function(fit)\n  predict( fit, tg )$y )\n\nhead(curve)\n\n          [,1]      [,2]\n[1,] -1.578154 0.5461749\n[2,] -1.577285 0.5464051\n[3,] -1.576416 0.5466354\n[4,] -1.575548 0.5468657\n[5,] -1.574679 0.5470960\n[6,] -1.573810 0.5473263\n\n\nHere’s\n\nplot( x, col=\"gray\", asp=1, cex=.5 )\nlines( curve, col=\"red\" )\n\n\n\n\n\n\nProjection step\nNow, we project each data point onto the curve, i.e., we find the curve point closest to the data point.\nWe use the fast nearest neighbors (FNN) package for this. Its function get.knnx takes two matrices, denoted “data” and “query” and considers the rows of these matrices as data points. Then, it searches for each query point its nearest neighbors among the data points.\n\nnn &lt;- FNN::get.knnx( data=curve, query=x, k=1 )\n\nstr(nn)\n\nList of 2\n $ nn.index: int [1:1000, 1] 4235 3473 3464 4794 4058 3316 5389 5706 2973 5287 ...\n $ nn.dist : num [1:1000, 1] 0.3878 0.1768 0.0412 0.2738 0.1139 ...\n\n\nNow, each data point has an index into our 3000 curve points that shows us where it is projected to.\nTo find pseudotime, we need to find out how away far the data point’s projection image is along the curve. Hence, we calculate the distance from each curve point to the next:\n\ncurve_segment_lengths &lt;- sqrt( \n  rowSums( ( curve[ 2:nrow(curve), ] - curve[ 1:(nrow(curve)-1), ] )^2 ) )\n                               \nhead( curve_segment_lengths )\n\n[1] 0.0008986183 0.0008986183 0.0008986183 0.0008986183 0.0008986183\n[6] 0.0008986183\n\n\nThe cumulative sum of this vector gives us the distance of erach curve point to the start of the curve, measured along the curve:\n\ndistance_from_start &lt;- c( 0, cumsum(curve_segment_lengths) ) \n\nhead( distance_from_start )\n\n[1] 0.0000000000 0.0008986183 0.0017972366 0.0026958549 0.0035944733\n[6] 0.0044930916\n\n\nNow, we can assign a pseudotime to each data point\n\npt &lt;- distance_from_start[ nn$nn.index ]\n\nHere is now the result of this first iteration, with our fitted curve in red, the true curve in blue, and the data points coloured by pseudotime:\n\nplot( x, col=scale_colors(pt), asp=1, cex=.5 )\nlines( curve, col=\"red\" )\nlines( spline_basis %*% knots, col=\"blue\", lty=\"dashed\" )\n\n\n\n\n\n\nNext iteration\nWe rerun the two steps to get the next iteration\n\n### Regression step:\n\n# Spline smoothing of individual coordinates\nfits &lt;- lapply( 1:2, function(i) smooth.spline( pt, x[,i], df=10 ) )\n\nfor( i in 1:2 ) {\n  plot( pt, x[,i], asp=1, cex=.2, main=i )\n  lines( fits[[i]], col=\"red\" )\n}\n\n\n\n\n\n\n# Calculate curve along fine grid\ntg &lt;- seq(\n  from = min(pt) - .3 * ( max(pt) - min(pt) ),\n  to   = max(pt) + .3 * ( max(pt) - min(pt) ),\n  length.out = 10000 )\n\ncurve &lt;- sapply( fits, function(fit)\n  predict( fit, tg )$y )\n\n\n### Projection step\n\n# Project data points onto curve with nearest-neighbor search:\nnn &lt;- FNN::get.knnx( data=curve, query=x, k=1 )\n\n# Calculate distances along curve\ncurve_segment_lengths &lt;- sqrt( \n  rowSums( ( curve[ 2:nrow(curve), ] - curve[ 1:(nrow(curve)-1), ] )^2 ) )\n\ndistance_from_start &lt;- c( 0, cumsum(curve_segment_lengths) ) \n\n# Assign pseudotime\npt &lt;- distance_from_start[ nn$nn.index ]\n\n# New plot\nplot( x, col=scale_colors(pt), asp=1, cex=.5 )\nlines( curve, col=\"red\" )\nlines( spline_basis %*% knots, col=\"blue\", lty=\"dashed\" )\n\n\n\n\n\n\nPutting it all together\n\nprincipal_curve_iteration &lt;- function( x, pt=NULL, curve=NULL ) {\n  \n  if( is.null(pt) ) {\n     # initialization step\n     pt &lt;- prcomp(x)$x[,\"PC1\"]\n  }\n  \n  # Spline smoothing of individual coordinates\n  fits &lt;- lapply( 1:ncol(x), function(i) smooth.spline( pt, x[,i], df=10 ) )\n\n  # Calculate curve along fine grid\n  tg &lt;- seq(\n    from = min(pt) - .3 * ( max(pt) - min(pt) ),\n    to   = max(pt) + .3 * ( max(pt) - min(pt) ),\n    length.out = 10*nrow(x) )\n\n  curve &lt;- sapply( fits, function(fit)\n    predict( fit, tg )$y )\n\n  # Project data points onto curve with nearest-neighbor search:\n  nn &lt;- FNN::get.knnx( data=curve, query=x, k=1 )\n\n  # Calculate distances along curve\n  curve_segment_lengths &lt;- sqrt( \n    rowSums( ( curve[ 2:nrow(curve), ] - curve[ 1:(nrow(curve)-1), ] )^2 ) )\n\n  distance_from_start &lt;- c( 0, cumsum(curve_segment_lengths) ) \n\n  # Assign pseudotime\n  pt &lt;- distance_from_start[ nn$nn.index ]\n\n  list( pt=pt, curve=curve )\n}\n\n\nl = list( pt=NULL, curve=NULL )\nfor( iter in 1:6 ) {\n  \n  l &lt;- principal_curve_iteration( x, l$pt, l$curve )\n  \n  plot( x, col=scale_colors(l$pt), asp=1, cex=.5, main=sprintf( \"Iteration %d\", iter ) )\n  lines( l$curve, col=\"red\" )\n  lines( spline_basis %*% knots, col=\"blue\", lty=\"dashed\" )\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBetter projection\nOur projection step is wasteful, as we need to calculate a very fine grid in order to make sure that we don’t get discretization errors. If we stick to the idea of representing the curve as a chain of linear segments, it should be sufficient to only use as much segments that the angle between two adjacent segments does not deviate too much from straight. Instead of projecting only on segment boundaries, we should also consider projecting at inner points of segments.\nCan you come up with an approach to do so?\nOn the other hand: Is this worthwhile, given that computers are fast?\n\n\n\nVariants\nIn the regression steps, we can replace the spline regression with any other smoothing method. The princurve package, for example, gives the option to use both spline regression and local (LOESS) regression."
  },
  {
    "objectID": "UMAP_pedestrian.html",
    "href": "UMAP_pedestrian.html",
    "title": "UMAP for pedestrians",
    "section": "",
    "text": "Here, we reimplement UMAP\n\nimport math\nimport numpy as np\nimport scipy.sparse\nimport h5py\nfrom matplotlib import pyplot as plt\nfrom matplotlib import colormaps\nfrom numba import *\nfrom tqdm.notebook import tnrange, tqdm\nimport umap\nimport igraph\nimport leidenalg\n\n/home/anders/pyenv_torch/lib/python3.11/site-packages/umap/distances.py:1063: NumbaDeprecationWarning: The 'nopython' keyword argument was not supplied to the 'numba.jit' decorator. The implicit default value for this argument is currently False, but it will be changed to True in Numba 0.59.0. See https://numba.readthedocs.io/en/stable/reference/deprecation.html#deprecation-of-object-mode-fall-back-behaviour-when-using-jit for details.\n  @numba.jit()\n/home/anders/pyenv_torch/lib/python3.11/site-packages/umap/distances.py:1071: NumbaDeprecationWarning: The 'nopython' keyword argument was not supplied to the 'numba.jit' decorator. The implicit default value for this argument is currently False, but it will be changed to True in Numba 0.59.0. See https://numba.readthedocs.io/en/stable/reference/deprecation.html#deprecation-of-object-mode-fall-back-behaviour-when-using-jit for details.\n  @numba.jit()\n/home/anders/pyenv_torch/lib/python3.11/site-packages/umap/distances.py:1086: NumbaDeprecationWarning: The 'nopython' keyword argument was not supplied to the 'numba.jit' decorator. The implicit default value for this argument is currently False, but it will be changed to True in Numba 0.59.0. See https://numba.readthedocs.io/en/stable/reference/deprecation.html#deprecation-of-object-mode-fall-back-behaviour-when-using-jit for details.\n  @numba.jit()\n/home/anders/pyenv_torch/lib/python3.11/site-packages/umap/umap_.py:660: NumbaDeprecationWarning: The 'nopython' keyword argument was not supplied to the 'numba.jit' decorator. The implicit default value for this argument is currently False, but it will be changed to True in Numba 0.59.0. See https://numba.readthedocs.io/en/stable/reference/deprecation.html#deprecation-of-object-mode-fall-back-behaviour-when-using-jit for details.\n  @numba.jit()\n\n\n\nExample data\nWe use again the IFNAGRKO dataset. Log-normalization and PCA has already been performed.\nHere is the result of the PCA:\n\nwith h5py.File(\"../ifnagrko_pca.h5\") as f:\n    pca = f['pca'][:].transpose()\n\nncells = pca.shape[0]\n\npca[:5,:5]\n\narray([[ 16.28623584, -12.28097802,  -5.47207594, -21.76252769,\n         -1.77129431],\n       [-10.83887971,   0.33993333,   2.08093385,   0.69148338,\n         -7.08986989],\n       [ 12.58293331,   7.58620352,  -1.90409793,   7.65700522,\n          3.03268977],\n       [ 10.06454811,   6.13142251,  -2.11701715,   4.04206773,\n          2.279775  ],\n       [-10.0199706 ,  -0.89696176,   6.20651074,  -0.53720203,\n         -6.59578868]])\n\n\n\n\nStandard UMAP\nWe use the UMAP package to perform the transformation.\nNote that we stick to default values except for one thing: We have fixed the hyperparameters \\(a\\) and \\(b\\) both to 1.\n\nump0 = umap.UMAP( a=1, b=1, verbose=True ).fit( pca )\n\nUMAP(a=1, b=1, verbose=True)\nMon Jun 24 12:15:13 2024 Construct fuzzy simplicial set\nMon Jun 24 12:15:13 2024 Finding Nearest Neighbors\nMon Jun 24 12:15:13 2024 Building RP forest with 12 trees\nMon Jun 24 12:15:18 2024 NN descent for 14 iterations\n     1  /  14\n     2  /  14\n     3  /  14\n     4  /  14\n    Stopping threshold met -- exiting after 4 iterations\nMon Jun 24 12:15:36 2024 Finished Nearest Neighbor Search\nMon Jun 24 12:15:39 2024 Construct embedding\nMon Jun 24 12:15:51 2024 Finished embedding\n\n\n\n\n\nHere’s a scatter plot of the result\n\nplt.scatter( ump0.embedding_[:,0], ump0.embedding_[:,1], s=.1 )\nplt.gca().set_aspect('equal')\n\n\n\n\n\nNext, we will recreate this “on foot”.\n\n\nFind nearest-neighbors\nWe use a kd tree to find the 15 nearest neighbors:\n\nnnbgs = 14\nnndist, nnidx = scipy.spatial.KDTree( pca ).query( pca, k=nnbgs+1 )\n\nnnidx is now an array of shape ncells by nnbgs+1, giving for each cell the indices of its nearest neighbours:\n\nnnidx[:5,:5]\n\narray([[    0,  2503,  4612,  2816,  2696],\n       [    1, 12411, 11119,  9816,  6432],\n       [    2, 10072,  9511,  3942,  7029],\n       [    3, 12406,  2607, 16033,  8034],\n       [    4, 10059, 10134,  3873,  5332]])\n\n\n\nnndist[:5,:5]\n\narray([[0.        , 2.91554959, 3.87197945, 3.94469136, 4.04883681],\n       [0.        , 1.74307066, 1.8722435 , 1.90254414, 1.94840715],\n       [0.        , 2.3056303 , 2.36507558, 2.40163638, 2.56152625],\n       [0.        , 2.21332819, 2.88892446, 2.91914098, 2.93972125],\n       [0.        , 2.8192931 , 3.05565062, 3.12995438, 3.15387043]])\n\n\nAs each cell is listed as its own nearest neighbor, we remove the first column, leaving us with nnbgs columns.\n\nnnidx = nnidx[:,1:]\n\nThe array nndist contains the distances of the neighbours to the respective cell. The array has the same shape. We also remove the first column.\n\nnndist = nndist[:,1:]\n\n\n\nSimilarity score\nThe UMAP algorithm suggests to convert these distances (we write \\(d_{ij}\\) for the distance from cerll \\(i\\) to cell \\(j\\)) into similarity scores \\(\\mu_{ij}\\) using an exponential: For the similarity of a cell \\(i\\) to another cell \\(j\\) that is among its \\(k\\) nearest neighbors, we set \\[\\mu_{i\\rightarrow j} = a_i e^{-d_{ij}/\\sigma_i}.\\] The similarity score of cell \\(i\\) to any cell further away is set to 0.\nThe UMAP paper argues that the metric in the high-dimensional space should be locally re-adjusted such that the point density becomes roughly uniform, because only then does the algorithm’s theoretical justification hold.\nThey suggest to set \\(a_i=e^{d_{ii_1}/\\sigma_i}\\), where \\(d_{ii_1}\\) is the distance of cell \\(i\\) to its nearest neighbor. This means that the similarity score from any cell to its nearest neighbor is 1: \\[\\mu_{i\\rightarrow j} =e^{-(d_{ij}-d_{i,i_1})/\\sigma_i}.\\]\nFurthermore, the decay constant \\(\\sigma_i\\) is chosen such that \\[\\sum_{j=1}^k \\mu_{i\\rightarrow j} = \\log_2 k,\\] where \\(k\\) is the numebr of nearest neighbors.\nNote that these values are not symmetric under exchange of \\(i\\) and \\(j\\). We therefore call these numbers the “directed” similarity scores.\nTo calculate them, we find the decay constants \\(\\sigma_i\\) using a simple root-finding approach:\n\nmu_dir = np.zeros_like( nndist )\n\nfor i in range(mu_dir.shape[0]):\n    res = scipy.optimize.root( \n        lambda sigma: np.exp( -( nndist[i,:] - nndist[i,0] ) / sigma ).sum() - math.log2(nnbgs+1), \n        nndist[i,1]-nndist[i,0] )\n    assert res.success\n    mu_dir[i,:] = np.exp( -( nndist[i,:] - nndist[i,0] ) / res.x )\n\nmu_dir[:5,:5]\n\narray([[1.        , 0.38127649, 0.35432688, 0.31901082, 0.22263436],\n       [1.        , 0.4790331 , 0.40307648, 0.31038503, 0.24439773],\n       [1.        , 0.78010108, 0.66960721, 0.34335116, 0.21518077],\n       [1.        , 0.34741612, 0.33137074, 0.3208687 , 0.25827415],\n       [1.        , 0.47652488, 0.37747247, 0.35019673, 0.34993508]])\n\n\n\n( np.abs( mu_dir.sum(1) - math.log2(nnbgs+1) ).max(),\n  np.abs( mu_dir[:,0] - 1. ).max() )\n\n(8.72191208145523e-13, 0.0)\n\n\n\n\nSymmetrizing the similarity scores\nThe UMAP papers’ author suggest to consider the rows of this matrix as neighborhood fuzzy sets: Each cell gets a neighborhood, which is a fuzzy set, containing the cell’s nearest neighbor with probability one and the next \\(k-1\\) neighbours with a probability that decays exponentially with distance. The union of all these forms a “skeleton” or backbone, building a fuzzy simplical complex that covers the manifold.\nFor this to make sense, we need a symmetric neighborhood relationship. Therefore, we make the union of the reciprocal fuzzy membership probabilities. Given two events \\(A\\) and \\(B\\) with probabilities \\(p_A\\) and \\(p_B\\), the probability of at least one of the two happening is \\(p_A+p_B-p_Ap_B\\).\nTherefore, we set \\[ \\mu_{ij} = \\mu_{i\\rightarrow j}+\\mu_{j\\rightarrow i}- \\mu_{i\\rightarrow j}\\mu_{j\\rightarrow i}.\\]\nTo calculate this, we first set up a sparse matrix whose entries are given by the \\(\\mu_{i\\rightarrow j}\\):\n\nadj_dir = scipy.sparse.coo_array( (ncells,ncells) )\nfor i in range(nnbgs):\n    adj_dir += scipy.sparse.coo_array( (mu_dir[:,i], (np.arange(ncells), nnidx[:,i]) ), shape=(ncells,ncells) )\nadj_dir\n\n&lt;18302x18302 sparse array of type '&lt;class 'numpy.float64'&gt;'\n    with 256228 stored elements in Compressed Sparse Row format&gt;\n\n\nThis code works as follows: A sparse matrix in COOrdinate form takes three vectors, provided as (data, (row,col)), that indicate that positions and values of all non-zero matrix entries. The i-the iteration of the for-loop constructs such a matrix for the symmetry score of each cell to its i-th nearest neighbor. Adding up these matrices yields the matrix formed by the \\(\\mu_{i \\rightarrow j}\\). We call the matrix adj_dir, because it can be understood as the adjacency matrix of a weighted directed nearest-neighbours graph.\nThe values \\(\\mu_{j \\rightarrow i}\\) are the matrix elements of the transpsoe of that matrix. The symmetrization is hence calculated with:\n\nadj_symm = adj_dir + adj_dir.transpose() - adj_dir.multiply( adj_dir.transpose() )\nadj_symm\n\n&lt;18302x18302 sparse array of type '&lt;class 'numpy.float64'&gt;'\n    with 379018 stored elements in Compressed Sparse Row format&gt;\n\n\nNote that the multiply method used here performs element-wise multiplication, not matrix multiplication, which is waht we need here.\n\nHistograms\nHere are histograms of the nonzero matrix elements of the directed and the symmetrized similarity-score matrix:\n\nplt.hist( adj_dir.data, 100 );\n\n\n\n\n\nplt.hist( adj_symm.data, 100 );\n\n\n\n\n\n\n\nCompare with UMAP package’s graph\nWe compare the weighted, symmetrized adjency matrix that we have just manually generated with one generated by the UMAP software. That one can be found here:\n\nump0.graph_\n\n&lt;18302x18302 sparse matrix of type '&lt;class 'numpy.float32'&gt;'\n    with 378972 stored elements in Compressed Sparse Row format&gt;\n\n\nNumber of edges in our graph, and in theirs?\n\n( (adj_symm&gt;0).sum(),  (ump0.graph_&gt;0).sum() )\n\n(379018, 378972)\n\n\nTO DO: There is a discrepancy here. Check the above code and find the mistake.\nFor how many of the edges does the edge weight differ from the one computed by the UMAP package by more than .01?\n\n( np.abs( adj_symm - ump0.graph_ ) &gt; .01 ).sum()\n\n3788\n\n\nThe matrices seem to nearly agree. However, the seemingly minor differences do mess up something, because the code below produces good results only with the ump0.graph_. I will have to search the mistake.\nUntil I find it, I replace our matrix with the one from the package:\n\nadj_symm = scipy.sparse.csr_array( ump0.graph_ )\n\n\n\nInitialization for UMAP\nBefore we can come to the actual UMAP algorithm, we have to discuss vice/v1”, “action”: “get”, “path”: . This is done via the graph Laplacianb, and teh approach only works for connected graphs. Hence, let’s first check whether our graph is connected:\n\n\nConnected components\nThe symmetrized matrix can also be interpreted as an adjacency matrix of an undirected weighted graph.\nIf we binarize the matrix, i.e., set all non-zero weights to 1, we get the point cloud’s unweighted \\(k\\)-nearest-neighbors graph.\nWe ask whether this graph is connected:\n\nncc, ccidx = scipy.sparse.csgraph.connected_components( adj_symm&gt;0 )\nncc\n\n3\n\n\nNo, it is not. We have two connection components that are not connected with each other.\nHow many cells fall into each component?\n\nnp.bincount(ccidx)\n\narray([17820,   137,   345])\n\n\nTo make our life easier, we remove that small components and only keep the “main component” (mc), which has index 0.\n\nadj_mc = adj_symm[ ccidx==0, :][:, ccidx==0 ]\nadj_mc.shape\n\n(17820, 17820)\n\n\n\n\nLeiden clustering\nMerely so that we have a way of colouring our cells in subsequent plots, we perform a Leiden clustering.\nTo this end, we binarize the adjacency matrix (i.e., set all non-zero entries to 1) and form a graph from that.\n\nnngraph = igraph.Graph.Adjacency( adj_mc&gt;0 )\n\nThen, we run the Leiden algorithm.\n\nclm = leidenalg.find_partition( nngraph, leidenalg.ModularityVertexPartition ).membership\n\nNow, we have a vector of cluster memberships. Here, for the first 10 cells:\n\nclm[:10]\n\n[10, 1, 15, 4, 0, 2, 3, 0, 5, 0]\n\n\nWe can colour the UMAP from before using this:\n\npalette = plt.colormaps['tab20'](range( max(clm)+1 ))\n\nplt.scatter( ump0.embedding_[ ccidx==0, 0 ], ump0.embedding_[ ccidx==0, 1 ], s=.1, c=palette[clm] )\nplt.gca().set_aspect('equal')\n\n\n\n\n\n\nSpectral clustering\nWe are still not ready to perform the actual UMAP algorithm, because we need an initial configuration. In the UMAP package, this is obtained via spectral clustering, so we do the same here:\nWe start by constructing the graph Laplacian of our weighted adjacency matrix. To this end, we first get a diagonal matrix D of the degrees of the graph vertices, i.e. \\[D_{ij}=\\delta_{ij}\\sum_{j'}\\mu_{ij'}.\\]\n\ndegdiag = scipy.sparse.diags( adj_symm.sum(0) )\n\nThe standard graph Laplacian is given by \\(L_0=D-A\\), where \\(A\\) is the adjacency matrix formed by the \\(\\mu_{ij}\\). Spectral clustering, however, works better, if one scales the Laplacian by dividing rows and columns by the square roots of the degrees, obtaining \\[L=D^{-1/2}L_0 D^{-1/2} = I - D^{-1/2} A D^{-1/2}.\\]\nWe get this scaled Laplacian,\n\ninvsqrtdegdiag = scipy.sparse.diags( 1 / np.sqrt( adj_mc.sum(0) ) )\n\nscaled_laplacian = scipy.sparse.identity(adj_mc.shape[0]) - invsqrtdegdiag * adj_mc * invsqrtdegdiag\n\nand get its 10 smallest (by magnitude) eigenvalues and their eigenvectors\n\nevals, evecs = scipy.sparse.linalg.eigsh( scaled_laplacian, k=10, which='SM' )\n\nHere are the eigenvalues:\n\nevals\n\narray([-1.10779340e-09,  4.51068171e-04,  5.63650240e-04,  8.16247925e-04,\n        1.12456990e-03,  1.27949653e-03,  2.42148730e-03,  2.75061424e-03,\n        4.12631309e-03,  5.92756770e-03])\n\n\nAs expected, the lowest eigenvalue is 0. There is only one eigenvalue because our graph is connected. Had we kept the other connection component, we would have obtained a multi-dimensional eigenspace to the zero eigenvalue. This is, why we removed it above – so that we do not have to deal with this issue here.\nThe eigenvector corresponding to the 0 eigenvalue would be constant for the usncaled Laplacian. Due to the scaling, it is now proportional to the square roots of the vertex degrees:\n\nplt.scatter( evecs[:,0], np.sqrt(adj_mc.sum(0)), s=.1 )\nplt.gcf().set_size_inches(2,2)\n\n\n\n\nThis vector is hence not of interest. The next two eigenvectors, however, are. We plot them here:\n\nplt.scatter( evecs[:,1], evecs[:,2], s=.1, c=palette[clm] )\nplt.gca().set_aspect('equal')\n\n\n\n\nThis is what we will use as initial configuration for the UMAP algorithm.\n\n\nUMAP\nFor a description of the UMAP algorithm, see here.\nHere is an implementation.\n\n@njit\ndef squared_distance_2d( v1, v2 ):\n    dx = v2[0] - v1[0]\n    dy = v2[1] - v1[1]\n    return dx*dx + dy*dy\n\n@njit\ndef clip( x ):\n    if x &lt; -4.:\n        return -4.\n    elif x &gt; 4.:\n        return 4.\n    else:\n        return x\n        \n@njit(parallel=True,fastmath=True)\ndef run_epoch( ump, edgefr, edgeto, edgewt, lr ):\n    if ump.shape[1] != 2:\n        raise ValueError( \"Must be 2D embedding\" )\n    n_vertices = ump.shape[0]\n    ump2 = ump.copy()\n    for i in prange(edgefr.shape[0]):\n        \n        if np.random.rand() &gt; edgewt[i]: \n            continue\n        \n        # Choose edge\n        v1 = edgefr[i]\n        v2 = edgeto[i]\n                \n        # squared distance\n        d2 = squared_distance_2d( ump[v1,], ump[v2,] )\n               \n        # attractive force\n        grad_coef = -2. / ( d2 + 1. ) * edgewt[i]\n        for k in range(2):\n            grad = grad_coef * ( ump[v1,k] - ump[v2,k] )\n            grad = clip( grad )\n            ump2[v1,k] += lr * grad\n            ump2[v2,k] -= lr * grad\n        \n        \n        # Choose 5 rejection partners\n        for j in range(5):\n            v2 = np.random.randint(n_vertices)\n        \n            d2 = squared_distance_2d( ump[v1,], ump[v2,] )\n            grad_coef = 2. / ( ( d2 + 1. ) * ( d2 + .001 ) ) * (1-edgewt[i])\n            for k in range(2):\n                grad = grad_coef * ( ump[v1,k] - ump[v2,k] )\n                grad = clip( grad )\n                ump2[v1,k] += lr * grad * .1   # &lt;- strangly low gamma here\n    return ump2\n\nThe function run_epoch goes once through all points. It expects a current UMAP configuration (as 2D array with 2 columns, ump), and the edges of the neighborhood graph given by two vector with the vertex indices of the connected vertices (edgefr, edgeto) and the edge-weights (edgewt) with the rescaled exponentially decaying similarity scores. The last parametyer, lr, is the learning rate.\nIn the code above, I have hard-coded a few hyperparameters: - The values for \\(a\\) and \\(b\\) are fixed to 1 and hence do not appear in the expressions for the gradient - The number of repulsive gradient applications per application of the attractive gradient, called negative_sampling_rate in the UMAP documentation, is fixed to its default value, 5. - The repulsive gradient is multiplied with the value 0.1 before it is applied. This parameter, called repulsion_strength in the UMAP documentation or \\(\\gamma\\) in the UMAP paper, is normally set to 1 – but with 1, the code below does not produce a good UMAP. I am not sure why the default value does not work. This might indicate that my code deviates from the default hyperparameters somewhere else, too, requiring this change to compensate.\nNow, we initialize the 2D UMAP coordinated with the eigenvectors corresponding to the two lowest non-zero eigenvalues of the graph Laplacian.\nWe also change the adjacency graph from CSR to COO sparse format, as this is needed by our code, and we initialize the learning rate \\(\\alpha\\) to 1.\n\nump = evecs[:,1:3].copy()\nadj_mc_coo = adj_mc.tocoo()\nlr = 1.\n\n\n\nNow we run through the points 1300 times, each time reducing the learning rate a bit.\n\nfor i in tnrange(1300):\n    ump = run_epoch( ump, adj_mc_coo.row, adj_mc_coo.col, adj_mc_coo.data, lr )\n    #ump = run_epoch( ump, adj_mc_coo.row, adj_mc_coo.col, np.ones_like(adj_mc_coo.data), lr )\n    lr = .997*lr\n\n\n\n\n\nplt.scatter( ump[:,0], ump[:,1], s=.1, c=palette[clm] )\nplt.gca().set_aspect('equal')"
  },
  {
    "objectID": "pca.html",
    "href": "pca.html",
    "title": "Principal Component Analysis",
    "section": "",
    "text": "Load example data\n\nsuppressPackageStartupMessages( {\n  library( Seurat )\n  library( Matrix )\n  library( sparseMatrixStats ) \n  library( tidyverse ) } )\n\ncount_matrix &lt;- Read10X( \"data/pbmc3k/filtered_gene_bc_matrices/hg19/\" )\n\nLog-normalize\n\nfractions &lt;- t( t(count_matrix) / colSums(count_matrix) )\nexpr &lt;- log1p( fractions * 1e4 )\n\nHighly variable genes:\n\nhvg &lt;- names( head( sort( rowVars(fractions) / rowMeans(fractions), decreasing=TRUE ), 1000 ) )\n\nAs a preparation for PCA, subset expression to HVGs, then center:\n\nexpr_centered &lt;- as.matrix( expr[hvg,] - rowMeans( expr[hvg,] ) )\n\nCentering means that all genes now have mean 0:\n\nrowMeans( expr_centered ) %&gt;% head()\n\n         PPBP         FCRL2        CEP128          DOK3         ARVCF \n-8.115936e-18  5.247860e-18 -1.151342e-18  4.476872e-18 -1.214306e-19 \n        YPEL2 \n-7.072532e-18 \n\n\nOptionally, we can also standardize the genes (i.e., divide by the standard deviation) so that they all have the same chance to influence the PCA. This point is optional in the sense that it is not required for the validity of the points we make below.\n\nexpr_centered / rowSds( expr_centered ) -&gt; expr_stdd\n\nThe centered expression matrix is what we supply to the PCA:\n\npca &lt;- irlba::prcomp_irlba( t( expr_stdd ), 20, scale.=FALSE, center=FALSE )\n\nrownames(pca$x) &lt;- colnames(expr_stdd)\nrownames(pca$rotation) &lt;- rownames(expr_stdd)\n\nTo remind us what the PCA does, let’s check that the PC score matrix \\(X\\) (pca$x) can relly be obtained from the expression matrix \\(Y\\) (t(expr_stdd)) via the loadings matrix \\(R\\) (pca$rotation): \\(YR=X\\)\n\n( t(expr_stdd) %*% pca$rotation )[1:5,1:5]\n\n                        PC1        PC2         PC3        PC4        PC5\nAAACATACAACCAC-1 -4.4561722  0.5435771  0.18664296 -2.4192526 -0.1511151\nAAACATTGAGCTAC-1 -0.8250185  2.3765237  4.00707855  6.8221179  2.6804905\nAAACATTGATCAGC-1 -2.3312564 -1.3021276 -2.35138861 -2.1671548  3.3980910\nAAACCGTGCTTCCG-1 10.5114431  2.0959988 -0.09797461  0.2043448  0.3759040\nAAACCGTGTATGCG-1  1.6880213 -4.8213875 -6.75849700  4.1443049 -5.9821060\n\npca$x[1:5,1:5]\n\n                        PC1        PC2         PC3        PC4        PC5\nAAACATACAACCAC-1 -4.4561722  0.5435771  0.18664296 -2.4192526 -0.1511151\nAAACATTGAGCTAC-1 -0.8250185  2.3765237  4.00707855  6.8221179  2.6804905\nAAACATTGATCAGC-1 -2.3312564 -1.3021276 -2.35138861 -2.1671548  3.3980910\nAAACCGTGCTTCCG-1 10.5114431  2.0959988 -0.09797461  0.2043448  0.3759040\nAAACCGTGTATGCG-1  1.6880213 -4.8213875 -6.75849700  4.1443049 -5.9821060\n\n\nIf we rotate in the other direction, we can reconstruct the expression matrix: \\(\\hat Y=XR^\\top\\)\n\nt( ( pca$x %*% t(pca$rotation) ) )[1:5, 1:5 ]\n\n       AAACATACAACCAC-1 AAACATTGAGCTAC-1 AAACATTGATCAGC-1 AAACCGTGCTTCCG-1\nPPBP       -0.000254819       -0.1202796      -0.06299039       0.17825774\nFCRL2      -0.109199553        1.2709282      -0.09809186      -0.19768285\nCEP128      0.048676874        0.1927019      -0.01869790      -0.05543508\nDOK3       -0.305134607        0.1725547      -0.09066065       0.52251219\nARVCF      -0.192669191       -0.2390528       0.14138719      -0.26052343\n       AAACCGTGTATGCG-1\nPPBP         0.05361365\nFCRL2        0.07628163\nCEP128      -0.04273337\nDOK3        -0.02864379\nARVCF        0.20478180\n\nexpr_stdd[1:5,1:5]\n\n       AAACATACAACCAC-1 AAACATTGAGCTAC-1 AAACATTGATCAGC-1 AAACCGTGCTTCCG-1\nPPBP        -0.14298358      -0.14298358      -0.14298358       2.91652450\nFCRL2       -0.12311737       3.95087439      -0.12311737      -0.12311737\nCEP128      -0.05661789      -0.05661789      -0.05661789      -0.05661789\nDOK3        -0.15956960      -0.15956960      -0.15956960      -0.15956960\nARVCF       -0.03920291      -0.03920291      -0.03920291      -0.03920291\n       AAACCGTGTATGCG-1\nPPBP        -0.14298358\nFCRL2       -0.12311737\nCEP128      -0.05661789\nDOK3        -0.15956960\nARVCF       -0.03920291\n\n\nThis reconstruction is, unsurprisingly, quite imperfect. After all, we truncated \\(R\\) to only 20 PCs.\nLet’s compare epxression and reconstruction for a random cell:\n\ncell &lt;- 123\n\nplot( expr_centered[,cell], ( pca$x %*% t(pca$rotation) )[cell,], asp=1 )\n\n\n\n\nCould be better. But let’s undo standardization and centering:\n\nplot( \n  expr[hvg,cell], \n  ( pca$x %*% t(pca$rotation) )[cell,] * rowSds( expr_centered ) +  rowMeans( expr[hvg,] ), \n  asp=1 )\n\n\n\n\nMuch better…\nStill, the preceding plot is actually the best one can get in some sense, and this is the reason we use the PCA.\nMaybe, we should make a plot, comparing one gene over all cells\n\ngene &lt;- hvg[1]\n\nplot( \n  ifelse( expr[gene,]&gt;0, expr[gene,], runif( ncol(expr), -.3, 0 ) ),\n  ( pca$x %*% t(pca$rotation) )[,gene], main=gene, cex=.3 )\n\n\n\n\n\nPower methods\nAbove, we had called\npca &lt;- irlba::prcomp_irlba( t( expr_stdd ), 20 )\nto ask the IRLBA package to perform a PCA on t(expr_stdd).\nA PCA on a matrix \\(Y\\) is performed by getting the eigenvectors of \\(Y^\\top Y\\):\n\nyty &lt;- expr_stdd[hvg,] %*% t(expr_stdd[hvg,])\n\neig &lt;- irlba::partial_eigen( yty, n=20 )\n\nstr(eig)\n\nList of 2\n $ vectors: num [1:1000, 1:20] 0.03929 -0.00701 -0.00527 0.0286 -0.00111 ...\n $ values : num [1:20] 94450 50384 41570 28163 17629 ...\n\n\nThe eigenvectors make up the rotation matrix. To check, let’s compare one column of the rotation matrix (say, the 3rd) with the corresponding eigenvector.\n\nplot( pca$rotation[,3], eig$vectors[,3], asp=1 )\n\n\n\n\nThe irlba function did not compute a full eigendecomposition but only calculated the first 20 eigenvectors. How can such a partial eigendecomposition be done?\nMost algorithms for partial eigendecompositions are refinements of a basic idea, the power method. The power method itself tends to not be very numerically stable, which is why much more stable variants have been developed. The irlba package, for example, used Baglama and Reichel’s “augmented implictly restarted Lanczoc bidiagonalization algroithm” (IRLBA).\nInstead of going into the depth of IRLBA and related approaches, we will only demonstrate the simple power method in the folloing.\nLet’s assume, the eigenvectors of our matrix \\(M=Y^\\top Y\\) were \\(\\mathbf{r}_l\\) with eigenvalues \\(\\lambda_l\\), i.e., \\(M\\mathbf{r}_l=\\lambda_l\\).\nWe start with a random vector \\(\\mathbf{v}\\). If we already knew the eigendecomposition of \\(M\\), we could use it as basis to expand \\(\\mathbf{v}\\) in it: \\(\\mathbf{v}=\\sum_l v_l \\mathbf{r}_l\\).\nApplying \\(M\\) gives \\(m\\mathbf{v}=\\sum_l \\lambda_l v_l \\mathbf{r}_l\\) and applying \\(M\\) \\(n\\) times yields \\[ M^n\\mathbf{v}=\\sum_l \\lambda_l^nv_l\\mathbf{r}_l\\] As \\(\\lambda_1\\) is the largest eigenvalue, the first component of \\(M^n\\mathbf{v}\\) will grow faster with \\(n\\) than the other components, and with increasing \\(n\\), the vector \\(M^n\\mathbf{v}\\) will become more and more collinear with the first eigenvector.\nWe try this by starting with a random vector, and applying the matrix 5 times. To avoid numerical overflow, we normalize the vector to unit length after each operation. Then, we compare the vector with the actual first eigenvector (as calculated by irlba) with a scatter plot.\n\nv &lt;- rnorm( length(hvg) )\nfor( i in 1:10 ) {\n  v &lt;- as.vector( yty %*% v )\n  v &lt;- v / sqrt(sum(v^2))\n  plot( pca$rotation[,\"PC1\"], v, asp=1, pch=\".\" )\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nv1 &lt;- v\n\nTo get the second eigenvector, we do the same as before, but after each operation we subtract the vector’s projection onto the first eigenvector.\n\nv &lt;- rnorm( length(hvg) )\nfor( i in 1:10 ) {\n  v &lt;- as.vector( yty %*% v )\n  v &lt;- v - v1 * sum( v1 * v )\n  v &lt;- v / sqrt(sum(v^2))\n  plot( pca$rotation[,\"PC2\"], v, asp=1 )\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nv2 &lt;- v\n\nBy projecting out the first two eigenvectors, we can get the third eigenvector:\n\nv &lt;- rnorm( length(hvg) )\nfor( i in 1:10 ) {\n  v &lt;- as.vector( yty %*% v )\n  v &lt;- v - v1 * sum( v1 * v )\n  v &lt;- v - v2 * sum( v2 * v )\n  v &lt;- v / sqrt(sum(v^2))\n  plot( pca$rotation[,\"PC3\"], v, asp=1 )\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAs states, this simple method tends to become numerically unstable quickly. However, most partial eigendecomposition algorithms actually used build onto this basic idea."
  },
  {
    "objectID": "umap_vs_tsne.html",
    "href": "umap_vs_tsne.html",
    "title": "Comparing UMAP and t-SNE",
    "section": "",
    "text": "Here, we compare the two dimension reduction methods, t-SNE and UMAP, applied to our usual “IFAGRKO” example data.\n\nLoad the data\n\nsuppressPackageStartupMessages({\n  library( tidyverse )\n  library( Seurat ) })\n\nReadMtx( \"~/Downloads/ifnagrko/ifnagrko_raw_counts.mtx.gz\",\n         \"~/Downloads/ifnagrko/ifnagrko_obs.csv\",\n         \"~/Downloads/ifnagrko/ifnagrko_var.csv\",\n         cell.sep=\",\", feature.sep=\",\", skip.cell=1, skip.feature=1, \n         mtx.transpose=TRUE) -&gt; count_matrix\n\nRUn the standard Seurat pipeline. Note the we added one step, namely RunTSNE in addition to RunUMAP:\n\ncount_matrix %&gt;%\n  CreateSeuratObject() %&gt;%\n  NormalizeData() %&gt;%\n  FindVariableFeatures() %&gt;%\n  ScaleData() %&gt;%\n  RunPCA( npcs=20 ) %&gt;%\n  FindNeighbors( dims=1:20 ) %&gt;%\n  FindClusters( resolution=0.5 ) %&gt;%\n  RunTSNE( dims=1:20 ) %&gt;%\n  RunUMAP( dims=1:20 ) -&gt; seu\n\nWarning: Feature names cannot have underscores ('_'), replacing with dashes\n('-')\n\n\nNormalizing layer: counts\n\n\nFinding variable features for layer counts\n\n\nCentering and scaling data matrix\n\n\nPC_ 1 \nPositive:  Apoe, Aldoc, Sparcl1, Sdc4, Ptn, Cmtm5, Glul, Gpr37l1, Fxyd1, Atp1b2 \n       S100a1, Slc4a4, Slc1a3, Prxl2a, F3, Itm2b, Mt1, Rgcc, Prdx6, Sfxn5 \n       Sat1, Scrg1, Dbi, Hes5, Luzp2, Plaat3, Pla2g7, Sash1, Plpp3, Sparc \nNegative:  Tubb5, Sox11, Tubb3, Stmn1, Jpt1, Hmgb3, Ptma, Sox4, Dlx2, Cd24a \n       Igfbpl1, Dlx6os1, Map1b, Stmn2, Abracl, Tmsb4x, Lmnb1, Cdca7, Ccnd2, Elavl4 \n       Cdk4, Dcx, Arx, Uchl1, EYFP, Celf4, Dlx5, Nrxn3, H1fx, Hmgn2 \nPC_ 2 \nPositive:  Ctss, C1qc, Laptm5, Csf1r, Trem2, C1qa, Cx3cr1, C1qb, Tyrobp, Ly86 \n       Fcer1g, Siglech, Selplg, Fcrls, Tmem119, Fcgr3, Apbb1ip, Unc93b1, Cd53, Lpcat2 \n       Spi1, Pld4, Olfml3, Irf8, Ctsh, Aif1, Cd300c2, Fyb, Otulinl, Mylip \nNegative:  Rorb, Cldn10, Clu, Mt3, Ntsr2, Mfge8, S1pr1, Id4, Slc1a2, Acsl6 \n       Plpp3, Sox9, Ddah1, Bcan, Cxcl14, Btbd17, Mlc1, Cspg5, Fjx1, Aqp4 \n       Ntm, Acsl3, Gabrb1, Tspan7, Lsamp, Chst2, Mt2, Lhx2, Slc39a12, Glud1 \nPC_ 3 \nPositive:  Atp1a3, Camk2b, Snhg11, Syt1, Nrip3, Kcnj4, Scg2, Snap25, Dnm1, Pcp4 \n       Icam5, Ndrg4, Eef1a2, Eno2, Ano3, Ryr2, Arpp21, Ptk2b, Gng4, Kcna4 \n       Penk, Slc4a10, Snca, Gad1, Rprml, Grin2a, C1qtnf4, Shisa8, Camk2a, Kcnb2 \nNegative:  Hmgb2, Top2a, Pbk, Birc5, Mki67, Cdk1, Cdca8, Spc24, Cenpf, Spc25 \n       Prc1, Rrm2, Mdk, Nusap1, Tpx2, Cdca3, Knl1, Ckap2l, Esco2, Aurkb \n       Cenpm, Ccna2, Bub1, Cks2, Kif11, Hist1h3c, Hist1h1b, Hmmr, Pclaf, Fbxo5 \nPC_ 4 \nPositive:  C1qc, C1qa, Ctss, Trem2, Csf1r, C1qb, Cx3cr1, Laptm5, Fcer1g, Tyrobp \n       Ly86, Siglech, Selplg, Fcrls, Fcgr3, Hexb, Spi1, Cd53, Itgb5, Pld4 \n       Ptgs1, Cd300c2, Aif1, Irf8, Fyb, Itgam, Cyth4, Ltc4s, Otulinl, Cd37 \nNegative:  Frzb, Apod, Npy, Plp1, Vtn, Foxd3, Wnt6, Nr2f2, Edil3, Sox10 \n       Gsn, Matn4, Fbln2, Aspa, Aqp1, Igf1, Plat, Lpar1, Igfbp4, Erbb3 \n       Fabp7, Plppr4, Ptgds, Col23a1, Alx3, Hey2, Cd59a, Fam3c, Scd1, Mybpc1 \nPC_ 5 \nPositive:  Stmn2, Igfbpl1, Cd24a, Nrep, Sox4, Map1b, Stmn4, Tubb3, Shtn1, Dlx6os1 \n       Dcx, Ly6h, Sox11, Jpt1, Mpped2, Stmn1, Plxna4, Pbx3, Elavl4, Uchl1 \n       Runx1t1, Cald1, Foxp2, Dlx2, Gad2, Celf4, Pfn2, Dlx5, Sp8, Tubb5 \nNegative:  Top2a, Pbk, Birc5, Mki67, Spc25, Cdk1, Prc1, Nusap1, Spc24, Esco2 \n       Tpx2, Knl1, Aurkb, Cenpf, Cdca8, Ckap2l, Kif11, Cdca3, Hist1h3c, Hmmr \n       Ccna2, Bub1, Incenp, Hist1h2af, Ndc80, Cit, Fbxo5, Kif4, Sgo1, Kif22 \n\n\nComputing nearest neighbor graph\n\n\nComputing SNN\n\n\nModularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck\n\nNumber of nodes: 18302\nNumber of edges: 616069\n\nRunning Louvain algorithm...\nMaximum modularity in 10 random starts: 0.9191\nNumber of communities: 19\nElapsed time: 6 seconds\n\n\nWarning: The default method for RunUMAP has changed from calling Python UMAP via reticulate to the R-native UWOT using the cosine metric\nTo use Python UMAP via reticulate, set umap.method to 'umap-learn' and metric to 'correlation'\nThis message will be shown once per session\n\n\n10:21:09 UMAP embedding parameters a = 0.9922 b = 1.112\n\n\n10:21:09 Read 18302 rows and found 20 numeric columns\n\n\n10:21:09 Using Annoy for neighbor search, n_neighbors = 30\n\n\n10:21:09 Building Annoy index with metric = cosine, n_trees = 50\n\n\n0%   10   20   30   40   50   60   70   80   90   100%\n\n\n[----|----|----|----|----|----|----|----|----|----|\n\n\n**************************************************|\n10:21:12 Writing NN index file to temp file /tmp/RtmpdVbL43/file4b62e3ff433ba\n10:21:12 Searching Annoy index using 1 thread, search_k = 3000\n10:21:21 Annoy recall = 100%\n10:21:21 Commencing smooth kNN distance calibration using 1 thread with target n_neighbors = 30\n10:21:23 Initializing from normalized Laplacian + noise (using RSpectra)\n10:21:29 Commencing optimization for 200 epochs, with 776086 positive edges\n10:21:39 Optimization finished\n\n\nHere is the UMAP plot, that we’ve seen before:\n\nUMAPPlot( seu, label=TRUE ) + coord_equal()\n\n\n\n\nHere is the t-SNE reduction for the same data\n\nTSNEPlot( seu, label=TRUE ) + coord_equal()\n\n\n\n\nTo compare the two interactively with Sleepwalk, run the following command in an interactive R session:\nsleepwalk::sleepwalk(\n  list( Embeddings(seu,\"tsne\"), Embeddings(seu,\"umap\") ),\n  list( Embeddings(seu,\"pca\"), Embeddings(seu,\"pca\") ),\n  maxdists = c( 30, 30 ) )"
  },
  {
    "objectID": "index.html#dates-and-times",
    "href": "index.html#dates-and-times",
    "title": "Mathematics of Single-cell Omics",
    "section": "Dates and times",
    "text": "Dates and times\nLecture times/dates:\n\non Mondays, 10-12 am c.t.\non Wednesdays, 16-18 pm s.t.\nno lecture on Mon 29 Apr, Wed 1 May, Wed 12 Jun\n\nPlace:\n\nnormally: seminar room SR 042 in BioQuant (INF 267)\nexceptions:\n\nWed 05 Jun: SR 043\nWed 26 Jun: SR 041"
  },
  {
    "objectID": "index.html#material-and-video-recodings",
    "href": "index.html#material-and-video-recodings",
    "title": "Mathematics of Single-cell Omics",
    "section": "Material and Video Recodings",
    "text": "Material and Video Recodings\n\nLecture of 2024-04-22:\n\nVideo\nBiology Primer\nOverview High-throughput Sequencing\nA simple analysis with Seurat\nExample data: PBMC3k (available on 10X web site, and Moodle)\n\nExercise class of 2024-04-24\n\nVideo\nDoing the Seurat analysis “on foot”\n\nLecture of 2024-05-06\n\nVideo\nModularity clustering\nblackboard photo\n\nExercise class of 2024-05-08\n\nVideo\n\nImplementing modularity score in Python\nlouvain.py\n\nLecture of 2024-05-13\n\nVideo\nMathematics of PCA\nBlackboard photos: 1 2\n\nExercise class of 2024-05-15\n\nVideo:\nfitting pseudotimes and splines\nR code: pseudotime_1.R, splines_1.R\nexample data: cmss.rda (on Moodle)\n\nLecture of 2024-05-22\n\nVideo\nExpression dynamics along pseudotime trajectories\nSmoothing\nblackboard photo\n\nLecture of 2024-05-27\n\nVideo\nSmoothing with principal curves\n\nLecture of 2024-06-03\n\nVideo\nBlackboard photos: 1 2\nSpectra of graphs (Skript still missing)\nDiffusion on graphs\n\nLecture of 2024-06-10\n\nVideo\nLaplacian eigenmaps\n\nLecture of 2024-06-17\n\nVideo (not yet uploaded)\nComparison of t-SNE and UMAP for our example data\nMathematics of t-SNE and UMAP\nReimplementing UMAP in Python\n\nprepared for following lectures\n\nCell cycle regression"
  },
  {
    "objectID": "index.html#source-code",
    "href": "index.html#source-code",
    "title": "Mathematics of Single-cell Omics",
    "section": "Source code",
    "text": "Source code\nThe source code for the R/Markdown (Quarto) files used above can be found in the GitHub repository anders-biostat/sco24."
  }
]