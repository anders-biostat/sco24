[
  {
    "objectID": "smoothing.html",
    "href": "smoothing.html",
    "title": "Smoothing",
    "section": "",
    "text": "Some example data, and the problem setting\nThe following code produces a function whose graphs shows several ups and downs. Don’t pay to much attention on how the function works; just look at its graph.\n\nlibrary( splines )\n\nspline_coefs = c( .1, .1, .1, .3, 1.3, 1.3, -.1, -.1, -.1, .3, .3  )\nspline_knots = c( .1, .1, .32, .35, .36, .48, .7 )\n  \ntrue_function &lt;- function(x)\n   bs( x, knots=spline_knots, intercept=TRUE ) %*% spline_coefs\n\nxg &lt;- seq( 0, 1, length.out=1000 )\nplot( xg, true_function( xg ), type=\"l\" )\n\n\n\n\nLet’s assume, we have some complicated apparatus or some complex system, which responds to some input or stimulus with an output or response governed by this function. Unfortunately, the measurement of the response is very noisy, and we have measurements only for a limited number of stimulus values.\nHere’s the 100 stimulus values:\n\nn &lt;- 100\nset.seed( 13245769 )\nx &lt;- runif( n )\n\nAnd here’s the measured responses:\n\ny &lt;- true_function( x ) + rnorm( n, sd=.1 )\n\nThis is how our data looks like:\n\nplot( x, y )\n\n\n\n\nCan we reconstruct the original function from this noisy data?\n\n\nBinned means\nThe simplest idea would be to bin the x-values and calculate for each bin of x values an average of the y values, e.g. one average of the y values corresponding to the x-values x from 0 to 0.1, one average for x between .1 and .2, etc.\n\nsuppressPackageStartupMessages( library( tidyverse ) )\n\ntibble( x, y ) %&gt;%\nmutate( xbin = cut_width( x, .1, center=0.05 ) ) %&gt;%\ngroup_by( xbin ) %&gt;%\nsummarise_all( mean ) %&gt;%\nggplot() + geom_point( aes( xbin, y ) )\n\n\n\n\n\n\nKernel smoothing\nThe hard cuts might introduce artefacts. An alternative is the following:\nTo get a smooth \\(y\\) value for a given value \\(x_0\\), calculate a weighted mean of the \\(y\\) values, where the weight depends on the distance \\(x-x_0\\) and is 0 for distance larger than some “smoothing bandwidth” \\(h\\):\n\\[ f_\\text{sm}(x_0) = \\frac{ \\sum_i y_i w_i }{\\sum_i w_i}, \\] where the weights depend on some “kernel function” \\(f_\\text{K}\\) as \\[ w_i = f_\\text{K}\\left(\\frac{x-x_0}{h}\\right).\\]\nThere are many choices for kernel functions. Wikipedia lists the popular ones.\nA kernel function should be symmetric \\(f_\\text{K}(x)=f_\\text{K}(-x)\\), have a single mode at 0, be continuous, perhaps also differentiable, and small or even zero for \\(|x|&gt;0\\). We use the tricube kernel \\[ f_\\text{tc}(u) = \\left\\{ \\begin{align}\n\\frac{70}{81} \\left(1-|u|^3\\right)^3 \\qquad & \\text{for } |u| \\le 1\n\\\\\n0 \\qquad & \\text{otherwise}\n\\end{align} \\right.\\]\nThe prefactor merely ensures that the function has a unit integral. As we divide by the weight sum anyway, we don’t need it:\n\ntricube &lt;- function(u)\n  ifelse( abs(u) &lt; 1, ( 1 - abs(u)^3 )^3, 0 )\n\nHere’s the smoothing function \\(f_\\text{sm}\\) from above, now in R:\n\nkernel_smooth &lt;- function( x0, x, y, h ) {\n  w &lt;- tricube( ( x - x0 ) / h )\n  sum( w * y ) / sum( w )\n}\n\nWe use it to draw a smoothed plot:\n\nxg &lt;- seq( 0, 1, length.out = 300 )\n\nplot( \n  xg, \n  sapply( xg, kernel_smooth, x, y, h=.1), \n  type=\"l\", col=\"red\", ylim=c( -.1, 1.5 ) )\n\nlines( xg, true_function( xg ), col=\"blue\" )\npoints( x, y )\n\n\n\n\nFor comparison, we have added to the smoothing curve (red) the true function (blue), from which we had sampled our data.\n\nBandwidth choice\nExperiment a bit with values for \\(h\\), the kernel width (also called the “smoothing bandwidth”).\nHow to choose a good value? What’s the trade-off?\n\n\n\nLocal regression\n(also known as “LOESS smoothing” or “LOWESS smoothing”, for “locally estimated/weighted scatterplot smoothing”)\nIn the curves above, the smoothed line has difficulties following the steep decent in the middle. This is because a kernel smoother cannot “sense slope”.\nBefore, we have calculated a weighted average to get a smooth \\(y\\) value for a given point \\(x_0\\). Now, we will perform a weighted regression at this point.\nLet’s choose \\(x_0=0.4\\) and look at the weights by making a scatter plot\nusing points with weight-proportional area:\n\nx0 &lt;- .4\n\nw &lt;- tricube( ( x - x0 ) / .1 )\n\nplot( x, y, cex=w )\n\n\n\n\nLet’s fit a regression in line into with plot. We use the fact that the lm function accepts weights.\n\nfit &lt;- lm( y ~ x, weights=w )\n\nfit\n\n\nCall:\nlm(formula = y ~ x, weights = w)\n\nCoefficients:\n(Intercept)            x  \n      4.201       -9.521  \n\n\nHere, lm has now maximized the weighted sum of squared residuals,\n\\[ \\frac{\\sum_i w_i ( \\hat y_i - y )^2}{\\sum_i w_i}, \\qquad \\text{with } \\hat y_i = \\hat a + \\hat b x_i, \\] where \\(\\hat a\\) and \\(\\hat b\\) are the fitetd coefficients (intercept and slope), reported by\n\ncoef(fit)\n\n(Intercept)           x \n   4.200663   -9.521193 \n\n\nand \\(w_i\\) are the weights, calculated as above.\nLet’s put the regression line into our plot, in orange, together fith the fitted value at point \\(x_0\\) (in red) :\n\nplot( x, y, cex=w )\nabline( a=coef(fit)[1], b=coef(fit)[2], col=\"orange\" )\npoints( x0, coef(fit)[1] + x0*coef(fit)[2], col=\"red\" )\nlines( xg, true_function(xg), col=\"lightblue\" )\n\n\n\n\nHere is a function that does all these steps:\n\nlocal_regression_smooth &lt;- function( x0, x, y, h ) {\n  w &lt;- tricube( ( x - x0 ) / h )\n  fit &lt;- lm( y ~ x, weights=w )\n  coef(fit)[1] + x0 * coef(fit)[2]\n}\n\nIt’s not vectorized, so we have to wrap it in an sapply to get the whole smoothed curve (as before):\n\nplot( \n  xg, \n  sapply( xg, local_regression_smooth, x, y, h=.1), \n  type=\"l\", col=\"red\", ylim=c( -.1, 1.5 ) )\n\nlines( xg, true_function( xg ), col=\"blue\" )\n\n\n\n\nHere, switching from simple kernel smoothing to local regression did not make that much of a difference but sometimes, it helps a lot.\n\nHigher-order local regression\nOf course, instead of fitting a regression line, we could have fitted a parabola. This is quickly done, by adding a quadratic term to the regression\n\nlocal_quadratic_regression_smooth &lt;- function( x0, x, y, h ) {\n  w &lt;- tricube( ( x - x0 ) / h )\n  fit &lt;- lm( y ~ x + I(x^2), weights=w )\n  coef(fit)[1] + x0 * coef(fit)[2] + x0^2 * coef(fit)[3]\n}\n\n\nplot( \n  xg, \n  sapply( xg, local_quadratic_regression_smooth, x, y, h=.1), \n  type=\"l\", col=\"red\", ylim=c( -.1, 1.5 ) )\n\nlines( xg, true_function( xg ), col=\"blue\" )\n\n\n\n\nThis did, in fact, improve the fit.\n\n\nAdaptive bandwidth\nWhat if the x values are not uniformly dstributed?\nThis time, we draw our x values from a non-uniform distribution:\n\nset.seed( 13245768 )\n\nx &lt;- sample( c( rbeta( n/2, 3, 7 ), rbeta( n/2, 9, 1 ) ) )\ny &lt;- true_function( x ) + rnorm( n, sd=.1 )\n\nplot( x, y )\nlines( xg, sapply( xg, local_quadratic_regression_smooth, x, y, h=.1 ), col=\"red\" )\nlines( xg, true_function( xg ), col=\"blue\" )\n\n\n\n\nThe bandwidth is too large where the points are dense and too narrow where they are sparse.\nAdaptive bandwidth: Always choose \\(h\\) such that a fixed number of x values are within the kernel window.\n\nlocal_quadratic_regression_adaptive_smooth &lt;- function( x0, x, y, hn ) {\n  ds &lt;- sort( abs( x - x0 ) )\n  h &lt;- ds[hn]\n  w &lt;- tricube( ( x - x0 ) / h )\n  fit &lt;- lm( y ~ x + I(x^2), weights=w )\n  coef(fit)[1] + x0 * coef(fit)[2] + x0^2 * coef(fit)[3]\n}\n\nplot( x, y )\nlines( xg, sapply( xg, local_quadratic_regression_adaptive_smooth, x, y, hn=30 ), col=\"red\" )\nlines( xg, true_function( xg ), col=\"blue\" )\n\n\n\n\n\n\nLocfit\nIn R, all this, and more, is available via the loess function (part of base R) or the locfit package. Our implementation above is, of course, very simple and slow, so better use these functions.\n\nplot( x, y )\nlines( xg, sapply( xg, local_quadratic_regression_adaptive_smooth, x, y, hn=30 ), col=\"red\" )\nlines( xg, true_function( xg ), col=\"blue\" )\n\nfit &lt;- loess( y ~ x, degree=2, span = 30/length(x) )\nlines( xg, predict( fit, xg ), col=\"orange\", lty=\"dashed\" )\n\n\n\n\nHere, we specified in the loess call that we want local regression with quadratic polynomials, with an adaptive bandwidth as given by span (which specified the number of points put under the kernel as fraction of the total number of data points).\nIt seems that the “loess” function (orange line) gives a slightly better result than our simple implementation (red line). Maybe it knows an additional trick?\n\n\n\nUncertainty estimation\n\nBootstrapping\nUsually, we do not know the “true” function. So, how can we judge how good it is?\nBootstrapping offers a way.\nBootstrapping means to replace the data with new data which is obtained by drawing observations, i.e., \\((x,y)\\) pairs, from the data, with replacement. Doing this many times provides a distribution of possible alternative fits.\nFirst, let’s do this for simple kernel smoothing:\n\nplot( x, y, xlim=c(0,1), ylim=c(-.2,1.6) )\n\nfor( i in 1:100 ) {\n  bss &lt;- sample.int( length(x), replace=TRUE )\n  lines( xg, sapply( xg, kernel_smooth, x[bss], y[bss], h=.1 ), \n     col = adjustcolor( \"red\", alpha=.1 ) ) }\n\nlines( xg, true_function(xg), col=\"blue\" )\n\n\n\n\nNow the same for local quadratic regression with the loess function:\n\nplot( x, y, xlim=c(0,1), ylim=c(-.5,1.5) )\n\nfor( i in 1:100 ) {\n  bss &lt;- sample.int( length(x), replace=TRUE )\n  lines( xg, predict( loess( y[bss] ~ x[bss], degree=2, span = 30/length(x) ), xg ),\n     col = adjustcolor( \"red\", alpha=.1 ) ) }\n\nlines( xg, true_function(xg), col=\"blue\" )\n\n\n\n\n\n\nLeave-one-out cross-validation\nAnother possibility is to use LOO-CV:\nCalculate for each data point its y value, using the y values of its neighbours, but not using the point’s own y value.\n\nyhat_loo &lt;- sapply( 1:length(x), function(i)\n  kernel_smooth( x[i], x[-i], y[-i], h=.1 ) ) \n\nplot( x, y )\npoints( x, yhat_loo, col=\"red\" )\n\n\n\n\nNow we can calculate a mean squared error (MSE):\n\nmean( ( y - yhat_loo )^2 )  # Mean squared error\n\n[1] 0.01629228\n\n\nIs the MSE lower with a more advanced smoother?\n\nyhat_loo &lt;- sapply( 1:length(x), function(i)\n  predict( loess( y[-i] ~ x[-i] ), x[i] ) ) \n\nmean( ( y - yhat_loo )^2, na.rm=TRUE )\n\n[1] 0.08926885\n\n\n\n\nStandard errors from regression\nUsing the math of ordinary least squares (OLS) regression, we can also get standard errors from a LOESS fit.\nHere, we multiply by 1.96 to get a 95% confidence band.\n\npred &lt;- predict( loess( y ~ x, span=.1 ), xg, se=TRUE )\n\nplot( x, y, xlim=c(0,1), ylim=c(-.5,1.5) )\nlines( xg, pred$fit, col=\"red\" )\nrect( xg, pred$fit - 1.96 * pred$se.fit, \n      lead(xg), pred$fit + 1.96 * pred$se.fit, col=alpha(\"red\",.3), lty=\"blank\" )\nlines( xg, true_function(xg), col=\"blue\" )\n\n\n\n\n\n\n\nExample with Poisson noise\nAbove, the noise was Gaussian (normal). In our single-cell data, it is Poissonian. Furthermore, we would like to calculate the curve on the log level, while properly dealing with zeroes.\nWe construct example count data from our curved function.\nLet’s use a few more data points this time:\n\nn &lt;- 300\n\nLet’s sample predictors. We call them x, as before, even though t might be appropriate, too, as in out real-data example, the x axis was pseudotime.\n\nset.seed( 13245768 )\nx &lt;- runif(n)\n\nFirst, we need cell sizes (count totals per cell). We draw them from a log normal:\n\ns = round( exp( rnorm( n, log(1e3), .5 ) ) )\n\nhist( log10(s) )\n\n\n\n\nNext, we get true fractions from our true_function, which we exponentiate. We have to rescale and shift a bit to get realistic values:\n\ntrue_fraction &lt;- function(x) exp( true_function(x) * 4 - 8 )\n\nq &lt;- true_fraction(x)\n\nplot( x, q, log=\"y\")\n\n\n\n\nNow, we add the Poisson noise:\n\nk &lt;- rpois( n, q * s )\n\nplot( x, log( k/s * 1e4 + 1 ) )\n\n\n\n\n\n\nKernel smoothing\nLet’s first use a simple kernel smoother. However, for the average, we use this time not \\[ f_\\text{sm}(x_0) = \\frac{ \\sum_i y_i w_i }{\\sum_i w_i}, \\] as before, but \\[ f_\\text{Psm}(x_0) = \\log \\frac{ \\sum_i k_i w_i }{\\sum_i s_i w_i}, \\] We first try it, then see why this makes sense.\n\nkernel_smooth_Poisson &lt;- function( x0, x, k, s, h ) {\n  w &lt;- tricube( ( x - x0 ) / h )\n  sum( w * k ) / sum( w * s )\n}\n\nWe use it to draw a smoothed plot:\n\nxg &lt;- seq( 0, 1, length.out = 300 )\n\nplot( xg, sapply( xg, kernel_smooth_Poisson, x, k, s, h=.1 ), \n  type=\"l\", col=\"red\", log=\"y\", ylim=c(1e-4,1e-1) )\n\nlines( xg, true_fraction( xg ), col=\"blue\" )\n\n\n\n\nTo understand the change in the last two equations, we need a short detour:\n\nInverse-variance weighting\nGiven \\(n\\) independent random variables \\(X_i\\) with variances \\(v_i=\\operatorname{v_i}\\), we want to estimate the expectation of their mean, \\(\\operatorname{E}\\left(\\frac{1}{n}\\sum_{i=1}^n X_i\\right)\\), by way of estimating a weighted mean, \\[ \\hat\\mu = \\frac{\\sum_iw_iX_i}{\\sum_i w_i}. \\] How should the weights be chosen such that the estimator’s sampling variance, \\(\\operatorname{Var}\\hat\\mu\\), is minimized?\nIf all the estimated variances are the same, \\(v_i=v\\), then the weights should all be the same, too: \\(w_i\\propto 1\\).\nIn general, however, the weights might differ. Then, one should choose \\(w_i\\propto \\frac{1}{v_i}\\).\nThis is easily proven with Lagrange multipliers; the proof can be found on the Wikipedia page on inverse-variance weighting.\n\n\nApplication to Poisson variables\nLet us now assume that the random variables we want to average over are fractions derived from Poisson counts. We have cells, indexed by \\(i\\), with counts for our gene of interest, given by \\(K_i\\sim \\operatorname{Pois}(s_i q)\\), where \\(s_i\\) is the “size”, i.e., the total count sum for the cell. We wish to estimate the common expected fraction \\(q\\) via teh weighted average \\[ \\hat q = \\frac{\\sum_iw_i\\frac{K_i}{s_i}}{\\sum_i w_i}. \\] What weights \\(w_i\\) should we use? Using \\(\\operatorname{Var} K_i=s_i q\\) together with the preceding result, we get \\[ w_i \\propto \\frac{1}{\\operatorname{Var}\\frac{K_i}{s_i}}=\\frac{1}{\\frac{1}{s_i^2}\\operatorname{Var}K_i}=\\frac{1}{\\frac{1}{s_i^2}s_iq}=\\frac{s_i}{q} \\propto s_i \\] Hence:\n\\[ \\hat q = \\frac{\\sum_iw_i\\frac{K_i}{s_i}}{\\sum_i w_i} = \\frac{\\sum_i s_i\\frac{K_i}{s_i}}{\\sum_i s_i} = \\frac{\\sum_i K_i}{\\sum_i s_i}. \\] This justifies our switching from \\(\\frac{1}{n}\\sum_i(k_i/s_i)\\) to \\((\\sum_i k_i)/(\\sum_i s_i)\\) in our smoothing function.\n\n\n\nGeneralized linear models\nBefore proceding further, we need another detour, this time to introduce generalized linear models (GLMs) as a generalization of OLS linear models.\n\nExample: Radioactive decay\nWe have measurements of the number of clicks per minute for a radioactive sample. Let’s simulate this: We count every 10 minutes for 1 minute, up to 200 minutes. The activite at t=0 is 1000 clicks/min, the half-life is 130 min.\n\nt &lt;- seq( from=0, by=10, length.out=20 )\nexpected_counts_per_min &lt;- 100* 2^( - t / 20 )\n\nk &lt;- rpois( length(t), expected_counts_per_min )\n\nplot( t, k )\n\n\n\n\nA simple approach is to plot on a semi-log plot:\n\nplot( t, k, log=\"y\")\n\nWarning in xy.coords(x, y, xlabel, ylabel, log): 6 y values &lt;= 0 omitted from\nlogarithmic plot\n\n\n\n\n\nand fit a regression line. However, the zeroes mess this up.\nHere’s a better way:\nWe may assume that \\[ k_i \\sim \\operatorname{Pois}( \\alpha e^{\\kappa t_i})\\] The true values are \\(\\alpha = 100\\) (the initial click rate) and \\(\\kappa = \\ln 2 / 20\\approx .035\\) (using the half life, 20, from above).\nWe can find maximum-likelihood estimates for \\(\\alpha\\) and \\(\\kappa\\). Here is the log-likelihood for a pair of candidate values \\(\\alpha\\) and \\(kappa\\):\n\nll &lt;- function( alpha, kappa )\n  sum( dpois( k, alpha * exp( -kappa * t ), log=TRUE ) )\n\nWe can find the parameters that maximize this function, using some guessed initital values:\n\noptim( \n  c( 50, 0.1 ),\n  function( x ) -ll( x[1], x[2] ) )\n\n$par\n[1] 92.39194421  0.03427986\n\n$value\n[1] 40.2579\n\n$counts\nfunction gradient \n     117       NA \n\n$convergence\n[1] 0\n\n$message\nNULL\n\n\n\n\nGLMs\nRewriting our model a bit, we recover the form of a “generalized linear model” (GLM). A GLM always has three components:\n\nThe response (in our case, the counts \\(K_i\\)) follows a distribution from the so-called exponential family (which includes the normal, the Poisson, the binomial, the gamma-Poisson, and others). Here, we have:\n\n\\[ K_i \\sim \\operatorname{Pois}( \\mu_i ). \\] (ii) The mean parameter \\(\\mu_i\\) in that distribution is coupled with teh so-called “linear predictir$ _i$ by a function, the so-called “link function”. Here: \\[ \\eta_i = \\log \\mu_i. \\] (iii) The linear predictor is a linear combination of known predictors \\(x_ij\\) with unknown coefficients \\(\\beta_j\\). In general \\[ \\eta_i = \\beta_0 + \\sum_j \\beta_j x_{ij} + o_i\\] and here simply \\[ \\eta_i = \\beta_0 + \\beta_1 t_i, \\] i.e. we have, besides the intercept \\(\\beta_0\\), only one further coefficient, \\(\\beta_1\\).\nThere are also no offsets \\(o_i\\). (If the time we had waited at each time point to count would not always have been the same but differed from measurement to measurement, we would have included the length these waiting times as “exposure values” \\(o_i\\).)\nWe can clearly identify how the coefficients of the GLM correspond to our parameters: \\(\\beta_1=-\\kappa=-\\ln2/T_{1/2}\\) and \\(\\beta_0=\\ln\\alpha\\).\nIf the model has this shape, the general optimizer optim that we have used above can be replaced by a GLM solver:\n\nfit &lt;- glm( k ~ t, family = poisson(link=\"log\") )\nfit\n\n\nCall:  glm(formula = k ~ t, family = poisson(link = \"log\"))\n\nCoefficients:\n(Intercept)            t  \n    4.52600     -0.03428  \n\nDegrees of Freedom: 19 Total (i.e. Null);  18 Residual\nNull Deviance:      612.2 \nResidual Deviance: 21.62    AIC: 84.52\n\n\nWe get the same result as with optim. We see this directly for the coefficient for \\(t\\) (i.e., \\(\\kappa\\)), but for \\(\\alpha\\), we have to exponentiate:\n\nexp(coef(fit)[1])\n\n(Intercept) \n   92.38863 \n\n\n\n\nIRLS\nThe glm function is faster than optim and more stable, because it uses a special algorithm known as “iteratively reweighted least squares” (IRLS) fitting.\nI was too lazy to write up how this works, so I asked ChatGPT to do my work:\nhttps://chatgpt.com/share/38554552-182e-45cf-9ea9-556a3592d6df\n\n\n\nLocal regression with GLMs\nNow, that we know GLMs, we can come back to our count data to be smoothed:\n\nset.seed( 13245768 )\nx &lt;- runif(n)\ns &lt;- round( exp( rnorm( n, log(1e3), .5 ) ) )\nk &lt;- rpois( n, q * s )\n\nplot( x, log( k/s * 1e4 + 1 ) )\n\n\n\n\nInstead of a simple kernel smoother, let’s to local regression again, but now with the glm function instead of the lm function:\n\nlocal_quadratic_regression_smooth_Poisson &lt;- function( x0, x, k, s, h ) {\n  w &lt;- tricube( ( x - x0 ) / h )\n  fit &lt;- glm( k ~ x + I(x^2), weights=w, offset=log(s), family=poisson(\"log\") )\n  unname( coef(fit)[1] + x0 * coef(fit)[2] + x0^2 * coef(fit)[3] )\n}\n\nCan you see why we pass the totals \\(s\\) as offsets? Why logarithmized? Have a careful look at the formula with \\(o_i\\) above.\nHere is the result. Smoothed curve in red, noisy data in gray, original function in blue.\n\nsuppressWarnings(\n  yhat &lt;- sapply( xg, local_quadratic_regression_smooth_Poisson, x, k, s, .15 ) )\n\nplot( x, log( k/s + 1e-4 ), col=\"gray\" )\nlines( xg, yhat, col=\"red\" )\nlines( xg, log( true_fraction( xg ) ), col=\"blue\" ) \n\n\n\n\nWe get a lot of warnings aboutv failure of IRLS to converge for some values.\nInstead of trying to debug this, we use the locfit package, where we have a ready-made function for this purpose:\n\nlibrary( locfit )\n\nlocfit 1.5-9.9   2024-03-01\n\n\n\nAttaching package: 'locfit'\n\n\nThe following object is masked from 'package:purrr':\n\n    none\n\nfit &lt;- locfit( k ~ lp( x, h=.15), weights=s, family=\"poisson\" )\n\nplot( x, log( k/s + 1e-4 ), col=\"gray\" )\nlines( xg, log( predict( fit, xg ) ), col=\"red\" )\nlines( xg, log( true_fraction( xg ) ), col=\"blue\" ) \n\n\n\n\n\n\nSpline regression\n\nSpline basis: first look\nAnother possibility is construct a smoothing curve as a linear combination of suitable basis function.\nThe function bs from the splines package produces a popular choice for a bsis function known as “B splines”.\nWe ask bs to provide a 7-dimensional basis and evaluate the basis functions at the points xg (our sequence of 300 numbers between 0 and 1):\n\nlibrary( splines )\n\nhead( cbind( x=xg,  bs( xg, df=7, intercept=TRUE ) ) )\n\n               x         1          2            3            4 5 6 7\n[1,] 0.000000000 1.0000000 0.00000000 0.0000000000 0.000000e+00 0 0 0\n[2,] 0.003344482 0.9604007 0.03933261 0.0002662587 3.990388e-07 0 0 0\n[3,] 0.006688963 0.9218609 0.07707964 0.0010562558 3.192311e-06 0 0 0\n[4,] 0.010033445 0.8843662 0.11326622 0.0023568231 1.077405e-05 0 0 0\n[5,] 0.013377926 0.8479022 0.14791751 0.0041547923 2.553849e-05 0 0 0\n[6,] 0.016722408 0.8124545 0.18105863 0.0064369951 4.987985e-05 0 0 0\n\n\nHere’s a plot\n\nknots &lt;- seq( 0, 1, length.out=8 )\nmatplot( xg, bs( xg, intercept=TRUE, Boundary.knots=knots[c(1,8)], knots=knots[1:7] ), \n    type=\"l\", lty=\"solid\" ) \n\nabline( v=knots, col=\"gray\" )\n\n\n\n\nIn a spline basis, the domain of the basis (here, the unit interval), is split into intervals, as indicated above by the gray lines. The boundaries of the intervals are marked with gray lines above and called knots. As we specified 7 degrees of freedom, we have \\(7-1=6\\) knots. The knots can be places arbitrarily, but here, we have spaced them uniformly.\nA B-spline basis, comprising basis functions \\(b_s\\) (here, $s=1,,10) is constructed to have the following properties:\n\nEach spline is a piecewise-polynomial function, i.e, between any two knots, it is a polynomial.\nThe degree of the polynomial can be chosen; for bs, the default is 3.\nThe basis peritions the unit, i.e., for every \\(x\\) within the range of knots, \\(\\sum_s b_s(x)=1\\).\n\nFor a B-spline basis made of 3rd-degree polynomials, we further have:\n\nEach basis has support on at most 4 segments of the domain, as split by the knots.\nThe basis functions are twice differentiable, but the third derivative is discontinuous at the knots.\n\n\n\nUnpenalized spline regression\nTo deomstrate spline regression, we go back to our original example with Gaussian, rather than Poisson, noise:\n\nn &lt;- 100\nset.seed( 13245769 )\nx &lt;- runif( n )\ny &lt;- true_function( x ) + rnorm( n, sd=.1 )\n\nWe seek a smoothing curve \\(f(x)=\\sum_s \\beta_s b_s(x)\\) that minimizes \\(\\sum_i\\left(y_i-f(x_i)\\right)^2\\).\nWe can find this by OLS regression:\n\nmy_bs &lt;- function(x) bs( x, intercept=TRUE, Boundary.knots=c(0,1), knots=seq(0,1,length.out=8)[2:7] )\n\nfit &lt;- lm.fit( my_bs(x), y ) \nfit$coefficients\n\n          1           2           3           4           5           6 \n-0.12240714  0.47448971 -0.38182562  2.12293953 -0.38211725 -0.01883465 \n          7           8           9          10 \n-0.19319187  0.35809313  0.09608862  0.40257549 \n\nplot( x, y )\nlines( xg, true_function(xg), col=\"blue\")\nlines( xg, my_bs(xg) %*% fit$coefficients, col=\"red\" )\n\n\n\n\nIf we increase the number of knots, the fit becomes better but also too “wiggly”\n\nmy_bs &lt;- function(x) bs( x, intercept=TRUE, Boundary.knots=c(0,1), knots=seq(0,1,length.out=20)[2:19] )\n\nfit &lt;- lm.fit( my_bs(x), y ) \nfit$coefficients\n\n           1            2            3            4            5            6 \n 0.009946524  0.058586095  0.258893913  0.137215507  0.334851555  0.851169376 \n           7            8            9           10           11           12 \n 1.121144587  1.511286792  0.773391525 -0.504725373  0.058186800 -0.194688673 \n          13           14           15           16           17           18 \n-0.056442763 -0.181762284 -0.030007379 -0.142877982  0.247319611  0.072789257 \n          19           20           21           22 \n 0.270731686  0.213996241  0.171709657  0.481918972 \n\nplot( x, y )\nlines( xg, true_function(xg), col=\"blue\")\nlines( xg, my_bs(xg) %*% fit$coefficients, col=\"red\" )\n\n\n\n\n\n\nCurvature-penalized spline regression\nWe can solve this issue by adding a penalty term on curvature to our least-square sum: \\[\\sum_i\\left(y_i-f(x_i)\\right)^2 + \\lambda\\int_0^1(f''(x))^2\\text{d}x=\\text{min!}\\]\nThe function `\n\nfit &lt;- smooth.spline( x, y, nknots=20 )\n\nplot( x, y )\nlines( xg, true_function(xg), col=\"blue\")\nlines( xg, predict( fit, xg )$y, col=\"red\")\n\n\n\n\n\n\nConstruction for the B-spline basis\nIn an iterative construction (de Boor construction), we increase the polynomial degree in each iteration.\nWe start with a 0th-degree basis, where \\(b_{s,0}\\) is simply 1 between the \\(s\\)-th and the \\((s+1)\\)th knot and 0 elsewhere.\n\nm &lt;- 13\nknots &lt;- seq( 0, 1, length.out=m+1 )\n\nbs0 &lt;- sapply( 1:m, function(i) as.numeric( xg &gt;= knots[i] & xg &lt; knots[i+1] ) )\n\nmatplot( xg, bs0, type=\"l\", lty=\"solid\" )\nabline( v=knots, col=\"gray\" )\n\n\n\n\nThe, we construct the 1st-degree basis as follows: \\(b_{s,1}\\) has support between the knot \\(s\\) and knot \\(s+2\\). It is a linear interpolation between \\(b_{s,0}\\) and \\(b_{s+1,0}\\), where the “mixing ratio” between the two 0th-degree basis function linearly goes from 1:0 to 0:1 while going along the support.\nThis yields triangles:\n\nbs1 &lt;- sapply( 1:(m-2), function(s) \n  ( xg - knots[s]   ) / ( knots[s+1] - knots[s]   ) * bs0[,s] +\n  ( knots[s+2] - xg ) / ( knots[s+2] - knots[s+1] ) * bs0[,s+1]  )\n\nmatplot( xg, bs1, type=\"l\", lty=\"solid\" )\nabline( v=knots, col=\"gray\" )\nlines( xg, rowSums(bs1), col=\"#00000030\" )\n\n\n\n\nThe vertical gray lines indicate the knots, the horizontal one shows that the sum of all basis function adds up to 1 in all the interior segments.\nWe repeat the process, using the same code, with changes to the indices: Now, the interpolation runs with over two segments of each of the previous splines. As we perform linear interpolation over linear functions we get piecewise quadratic polynomials, i.e., the following functions are pieced together from parabolas.\n\nbs2 &lt;- sapply( 1:(m-3), function(s) \n  ( xg - knots[s]   ) / ( knots[s+2] - knots[s]   ) * bs1[,s] +\n  ( knots[s+3] - xg ) / ( knots[s+3] - knots[s+1] ) * bs1[,s+1]  )\n\nmatplot( xg, bs2, type=\"l\", lty=\"solid\", ylim=c(0,1) )\nabline( v=knots, col=\"gray\" )\nlines( xg, rowSums(bs2), col=\"#00000030\" )\n\n\n\n\nAs we interpolated between pieces that added to one, the result adds to one again, as indicated by the gray line. Again, this only holds in the inner segments.\nOne more iteration to get to third degree polynomical pieces:\n\nbs3 &lt;- sapply( 1:(m-4), function(s) \n  ( xg - knots[s]   ) / ( knots[s+3] - knots[s]   ) * bs2[,s] +\n  ( knots[s+4] - xg ) / ( knots[s+4] - knots[s+1] ) * bs2[,s+1]  )\n\nmatplot( xg, bs3, type=\"l\", lty=\"solid\", ylim=c(0,1) )\nabline( v=knots, col=\"gray\" )\nlines( xg, rowSums(bs3), col=\"#00000030\" )\n\n\n\n\nThe basis still adds up to 1 in the inner segments.\nWe refactor our code to use a recursive function, taking the argument, x, the index of the basis function, s, the basis degree k, and the knots vector:\n\nbsf &lt;- function( x, s, k, knots ) {\n  if( k == 0 )\n    as.numeric( x &gt;= knots[s] & x &lt; knots[s+1] )\n  else\n    ( x - knots[s]     ) / ( knots[s+k]   - knots[s]   ) * bsf( x, s,   k-1, knots ) +\n    ( knots[s+k+1] - x ) / ( knots[s+k+1] - knots[s+1] ) * bsf( x, s+1, k-1, knots )\n}\n\nThis function is known as the Cox-de Beer formula.\nWith it, we can reconstruct our last plot:\n\nm &lt;- 13\nknots &lt;- seq( 0, 1, length.out=m+1 )\n\nbs3 &lt;- sapply( 1:(m-4), function(s) bsf( xg, s, 3, knots ) )\n\nmatplot( xg, bs3, type=\"l\", lty=\"solid\", ylim=c(0,1) )\nabline( v=knots, col=\"gray\" )\nlines( xg, rowSums(bs3), col=\"#00000030\" )\n\n\n\n\nThe basis produced by bs also adds up to 1 in the outer segments. This is achieved by moving the outer knots where the sum is not 1 very close together.\nWe rerun the code to show this, changing only the knot vector\n\nm &lt;- 13\nknots &lt;- c( -.003, -.002, -.001, seq( 0, 1, length.out=m-6 ), 1.001, 1.002, 1.003, 1.004 )\n\nbs3 &lt;- sapply( 1:(m-4), function(s) bsf( xg, s, 3, knots ) )\n\nmatplot( xg, bs3, type=\"l\", lty=\"solid\", ylim=c(0,1) )\nabline( v=knots, col=\"gray\" )\nlines( xg, rowSums(bs3), col=\"#00000030\" )\n\n\n\n\nOf course, we should form the limit of moving the outer knots exactly to 0 and 1, but that would require us to think very carefully about where to put \\(&lt;\\) and where \\(\\le\\) in the \\(k=0\\) case, and that is cumbersome. Luckily for us, the authors of bs have done that for us.\n\nbs3 &lt;- bs( xg, df=m-4, intercept=TRUE )\nmatplot( xg, bs3, type=\"l\", lty=\"solid\", ylim=c(0,1) )\nabline( v=knots, col=\"gray\" )\nlines( xg, rowSums(bs3), col=\"#00000030\" )\n\n\n\n\n\n\nCurvature of the spline basis\nFor the curvature penalization mentioned earlier, we need the second derivative of the spline basis. As these are piece-wise 3rd-degree polynomials, we expect the second derivative to be piecewise linear. We can calculate explicitely the second derivative of the Cox-de Beer function, or we can rely on other people’s work and believe the formula given, e.g., in Wikipedia.\nStill, we can quickly calculate the second derivative via finite differences. For the orginal, we just get a repeat of a V-shaped curve:\n\nm &lt;- 13\nknots &lt;- seq( 0, 1, length.out=m+1 )\n\nbs3 &lt;- sapply( 1:(m-4), function(s) bsf( xg, s, 3, knots ) )\nmatplot( xg, bs3, type=\"l\", lty=\"solid\", ylim=c(0,1), main=\"degree-3 spline basis\" )\n\n\n\nnr &lt;- nrow(bs3)\nbs3xx &lt;- bs3[1:(nr-2),] - 2*bs3[2:(nr-1),] + bs3[3:nr,]\n\nmatplot( xg[2:(nr-1)], bs3xx, type=\"l\", lty=\"solid\", main=\"2nd derivative\" )\n\n\n\n\nFor the pulled-in outer knots, we get this:\n\nbs3 &lt;- bs( xg, df=m-4, intercept=TRUE )\nmatplot( xg, bs3, type=\"l\", lty=\"solid\", ylim=c(0,1), main=\"degree-3 spline basis\" )\n\n\n\nnr &lt;- nrow(bs3)\nbs3xx &lt;- bs3[1:(nr-2),] - 2*bs3[2:(nr-1),] + bs3[3:nr,]\n\nmatplot( xg[2:(nr-1)], bs3xx, type=\"l\", lty=\"solid\", main=\"2nd derivative\" )\n\n\n\n\nFor a given linear combination \\(f(x) = \\sum_s \\beta_s b_{s,3}(x)\\), it is easy and cheap to calculate the integral of its squared curvature: \\[\\begin{align}\n\\int_0^1 \\left(f(x)\\right)^2\\text{d}x &=\n\\int_0^1\\left(\\sum_{s}\\beta_sb_{s,3}\\right)\\left(\\sum_{s'}\\beta_sb_{s',3}\\right)\\text{d}x\\\\\n&=\\sum_{ss'} \\beta_s\\beta_{s'}\\underbrace{\\int_0^1b_{s,3}(x)b_{s',3}(x)\\mathrm{d}x}_{=P_{ss'}}=\n\\vec\\beta^\\top P \\vec \\beta\n\\end{align}\\] The matrix \\(P\\) can be easily calculated ahead of time and so, the objective of our minimization for curvature-penalized spline regression becomes:\n\\[\\begin{align}\nL=&\\sum_i\\left(y_i-f(x_i)\\right)^2 + \\lambda\\int_0^1(f''(x))^2\\text{d}x\\\\\n=&(\\vec{y}-X\\vec\\beta)^\\top(\\vec{y}-X\\vec\\beta) + \\lambda \\vec{β}^\\top P \\vec\\beta\\\\\n=&\\vec y^\\top\\vec y - 2 \\vec\\beta^\\top X^\\top\\vec y+\\vec\\beta^\\top\\left(\nX^\\top X + \\lambda P\\right)\\vec\\beta\n\\end{align}\\]\nHere, the matrix \\(X\\) has matrix elements \\(X_{is}=b_{s,3}(x_i)\\).\nTo minimize this, we take the gradient w.r.t. \\(\\vec\\beta\\): \\[ \\nabla_{\\vec\\beta}L=-2X^\\top\\vec{y} + 2 \\left(X^\\top X + \\lambda P\\right)\\vec\\beta\\] Setting the gradient to zero, we obtain the OLS normal equation with the added penalty: \\[\\left(X^\\top X + \\lambda P\\right)\\vec\\beta = X^\\top\\vec{y} \\] As this is an equation of the form \\(A\\vec x=\\vec b\\), it describes a system of linear equations that can be solved with QR decomposition (i.e., Gauß elimination) in order to find \\(\\vec\\beta\\).\nThis describes the math behind the smooth.spline function except for one point: a clever heuristic to find a suitable value for the penalty strength parameter \\(\\lambda\\), which we will skip over. (In brief: It turns out that a scale-free smoothing strength can be defined, which one then multiplies with \\(\\operatorname{tr}X^\\top X / \\operatorname{tr} P\\) to obtain \\(\\lambda\\).)\n\n\nP-Splines\nAn alternative to spline regression with curvature penality is P-spline smoothing.\nHere, one uses a basis with rather very many basis functions (large \\(m\\) in our notation), lets all the basis functions keep the same shape (no “pulling in” of the boundary knots), and replaced the curvature penalty with a penalty on the differences between the coefficients for adjacent splines:\n\\[ \\|\\vec y - X\\vec\\beta\\|^2 - \\lambda \\sum_{s=1}^{m-1}\\left(\\beta_{s+1}-\\beta_s\\right)^2\\]\nIt’s easy to see that this penalty can be implemented using the same normal equation as before when setting \\(P\\) to \\[P=\\left(\n\\begin{array}{r}\n1  & -1 &    &    &  \\\\\n-1 &  2 & -1 &    &  \\\\\n   & -1 &  2 & -1 &  \\\\\n   &    & -1 &  2 & -1 & \\\\\n   &    &    & ⋱ &  ⋱ & ⋱ & \\\\\n   &    &    &    & -1 &  2 & -1 & \\\\\n   &    &    &    &    & -1 &  2 & -1 & \\\\\n   &    &    &    &    &    & -1 &  1    \n\\end{array}\n\\right).\\]\nTo demonstrate,w e first make a really large basis, which extends far out of the domain\n\nknots &lt;- seq( -1, 2, length.out=100 )\nm &lt;- length(knots)-4\nbs3 &lt;- sapply( 1:m, function(s) bsf( xg, s, 3, knots ) )\nmatplot( xg, bs3, type=\"l\", lty=\"solid\", ylim=c(0,1), main=\"degree-3 spline basis\" )\n\n\n\n\nWe remove the knots that have no influence inside the domain [0;1]:\n\nknots &lt;- knots[\n  min( which( sapply( 1:length(knots), function(l) bsf( 0, 1, 3, knots[l:length(knots)] ) ) &gt; 0 ) ):\n  max( which( sapply( 1:length(knots), function(l) bsf( 1, l-4, 3, knots[1:l] ) ) &gt; 0 ) ) ]\n\nm &lt;- length(knots)-4\n\nknots\n\n [1] -0.09090909 -0.06060606 -0.03030303  0.00000000  0.03030303  0.06060606\n [7]  0.09090909  0.12121212  0.15151515  0.18181818  0.21212121  0.24242424\n[13]  0.27272727  0.30303030  0.33333333  0.36363636  0.39393939  0.42424242\n[19]  0.45454545  0.48484848  0.51515152  0.54545455  0.57575758  0.60606061\n[25]  0.63636364  0.66666667  0.69696970  0.72727273  0.75757576  0.78787879\n[31]  0.81818182  0.84848485  0.87878788  0.90909091  0.93939394  0.96969697\n[37]  1.00000000  1.03030303  1.06060606  1.09090909\n\n\nNow, we calculate the values of the spline basis at the x coordinates of the data points, and, for later use, also at our grid of equidistant points\n\nspx &lt;- sapply( 1:m, function(s) bsf( x, s, 3, knots ) )\nspxg &lt;- sapply( 1:m, function(s) bsf( xg, s, 3, knots ) )\n\nWe construct the penalty matrix \\(P\\)\n\npty &lt;- diag(2,m)\npty[ row(pty) == col(pty)+1 ] &lt;- -1\npty[ row(pty) == col(pty)-1 ] &lt;- -1\npty[1,1] &lt;- 1\npty[m,m] &lt;- 1\nimage( 1:m, 1:m, pty, asp=1 )\n\n\n\n\nNow, we solve the normal equations for \\(\\lambda=1\\):\n\nlambda &lt;- 1\nbeta &lt;- solve( t(spx) %*% spx + lambda * pty , t(spx) %*% y )\n\nHere is the plot\n\nplot( x, y )\nlines( xg, spxg %*% beta, col=\"red\" )\nlines( xg, true_function(xg), col=\"blue\" )\n\n\n\n\nHere, for a few more values of lambda:\n\nplot( x, y )\nfor( lambda in c( .01, .1, 1, 10, 100 ) ) {\n  beta &lt;- solve( t(spx) %*% spx + lambda * pty , t(spx) %*% y )\n  lines( xg, spxg %*% beta, col=\"red\" )\n}  \nlines( xg, true_function(xg), col=\"blue\" )"
  },
  {
    "objectID": "seurat.html",
    "href": "seurat.html",
    "title": "A simple analysis with Seurat",
    "section": "",
    "text": "Seurat\nTo get a first feel for single-cell RNA-Seq data, we will perform a simple standard analysis using Seurat, an R package offering comprehensive functionality to analyse such data. Seurat has been developed by Rahul Satija and his research group at New York University and is described in multiple publications. The package is named for French pointilist painter Georges Seurat. The web site for Seurat is here.\nWe load the package in R. We will also need the Matrix package and the magrittr package.\n\nsuppressPackageStartupMessages({\n  library( Seurat )\n  library( Matrix )\n  library( magrittr ) })\n\n\n\nFirst example data: PBMCs\nOur first example data set is a single-cell RNA-Seq data set produced by 10X (the manufacturer of the leading microfluidics platform for single-cell sequencing) to demonstrate their product.\nThey took a sample of peripheral blood (i.e., blood taken from a vein) of a human donor and removed all red blood cells and platelets (which both have no nucleus) and all white blood cells with multiple nuclei, leaving us only those types of white blood cells that have a single nucleus, i.e., with “peripheral-blood mononuclear cells”: PBMC.\nA count matrix has been obtained from the sequencing reads, using 10X’s “Cellranger” software. The matrix is available from teh 10X web site, here.\nThe matrix is provided in 10X’s own format. Seurat has a function to load this:\n\ncount_matrix &lt;- Read10X( \"data/pbmc3k/filtered_gene_bc_matrices/hg19/\" )\n\n\nFirst look at the count matrix\nThe matrix is provided as a sparse matrix (as defined in the Matrix package):\n\nclass( count_matrix )\n\n[1] \"dgCMatrix\"\nattr(,\"package\")\n[1] \"Matrix\"\n\n\nSpecifically, it is a column-sparse matrix (one of three standard storage formats for sparse matrices).\nLet’s have a look at the top left corner of the matrix\n\ncount_matrix[ 1:10, 1:10 ]\n\n10 x 10 sparse Matrix of class \"dgCMatrix\"\n\n\n  [[ suppressing 10 column names 'AAACATACAACCAC-1', 'AAACATTGAGCTAC-1', 'AAACATTGATCAGC-1' ... ]]\n\n\n                                 \nMIR1302-10    . . . . . . . . . .\nFAM138A       . . . . . . . . . .\nOR4F5         . . . . . . . . . .\nRP11-34P13.7  . . . . . . . . . .\nRP11-34P13.8  . . . . . . . . . .\nAL627309.1    . . . . . . . . . .\nRP11-34P13.14 . . . . . . . . . .\nRP11-34P13.9  . . . . . . . . . .\nAP006222.2    . . . . . . . . . .\nRP4-669L17.10 . . . . . . . . . .\n\n\nAll entiries are zero (denoted as dot).\nWe have rows for the genes and columns for the cell barcodes:\n\ndim( count_matrix )\n\n[1] 32738  2700\n\n\nThe rows are labelled with gene symbols:\n\nrownames(count_matrix) %&gt;% head(20)\n\n [1] \"MIR1302-10\"    \"FAM138A\"       \"OR4F5\"         \"RP11-34P13.7\" \n [5] \"RP11-34P13.8\"  \"AL627309.1\"    \"RP11-34P13.14\" \"RP11-34P13.9\" \n [9] \"AP006222.2\"    \"RP4-669L17.10\" \"OR4F29\"        \"RP4-669L17.2\" \n[13] \"RP5-857K21.15\" \"RP5-857K21.1\"  \"RP5-857K21.2\"  \"RP5-857K21.3\" \n[17] \"RP5-857K21.4\"  \"RP5-857K21.5\"  \"OR4F16\"        \"RP11-206L10.3\"\n\n\nThe columns are labelled with cell barcodes:\n\ncolnames(count_matrix) %&gt;% head(20)\n\n [1] \"AAACATACAACCAC-1\" \"AAACATTGAGCTAC-1\" \"AAACATTGATCAGC-1\" \"AAACCGTGCTTCCG-1\"\n [5] \"AAACCGTGTATGCG-1\" \"AAACGCACTGGTAC-1\" \"AAACGCTGACCAGT-1\" \"AAACGCTGGTTCTT-1\"\n [9] \"AAACGCTGTAGCCA-1\" \"AAACGCTGTTTCTG-1\" \"AAACTTGAAAAACG-1\" \"AAACTTGATCCAGA-1\"\n[13] \"AAAGAGACGAGATA-1\" \"AAAGAGACGCGAGA-1\" \"AAAGAGACGGACTT-1\" \"AAAGAGACGGCATT-1\"\n[17] \"AAAGATCTGGGCAA-1\" \"AAAGCAGAAGCCAT-1\" \"AAAGCAGATATCGG-1\" \"AAAGCCTGTATGCG-1\"\n\n\nThe column sums of the matrix tell us how many reads we got per cell:\n\ncolSums(count_matrix) %&gt;% head(20)\n\nAAACATACAACCAC-1 AAACATTGAGCTAC-1 AAACATTGATCAGC-1 AAACCGTGCTTCCG-1 \n            2421             4903             3149             2639 \nAAACCGTGTATGCG-1 AAACGCACTGGTAC-1 AAACGCTGACCAGT-1 AAACGCTGGTTCTT-1 \n             981             2164             2176             2260 \nAAACGCTGTAGCCA-1 AAACGCTGTTTCTG-1 AAACTTGAAAAACG-1 AAACTTGATCCAGA-1 \n            1276             1103             3918             2392 \nAAAGAGACGAGATA-1 AAAGAGACGCGAGA-1 AAAGAGACGGACTT-1 AAAGAGACGGCATT-1 \n            2412             3034             1152              792 \nAAAGATCTGGGCAA-1 AAAGCAGAAGCCAT-1 AAAGCAGATATCGG-1 AAAGCCTGTATGCG-1 \n            1348             1158             4586             2929 \n\n\nHere is a histogram of the total read counts per cell, on a log10 scale\n\ncolSums(count_matrix) %&gt;% log10() %&gt;% hist() \n\n\n\n\nLet’s pick an arbitrary cell and ask what genes were expressed in this cell:\n\ncell &lt;- 1423\ncount_matrix[ , cell ] %&gt;% sort(decreasing=TRUE) %&gt;% head(50)\n\n     B2M   MALAT1   TMSB4X    RPL11    RPS18    RPL13    RPL10   RPL18A \n      72       65       46       25       23       20       19       19 \n  RPL13A   MT-CO1    RPS12   RPL23A     RPL3    RPS14     RPS6  PTPRCAP \n      19       19       18       18       18       17       17       17 \n    RPS3     RPS2   RPS15A   EEF1A1     RPL7    RPL19    RPL28     RPL9 \n      17       17       17       16       16       16       16       15 \n   RPS27    RPL32    RPS23    RPL15 HLA-DPB1     RPL6    RPL21     ACTB \n      14       14       14       13       13       13       13       12 \n    NKG7     RPS8    HLA-C    RPL12    RPLP1   RPS27A    RPL31    RPL34 \n      12       11       11       11       11       10       10       10 \n   RPS3A    RPS20    RPLP2     CCL5    RPS15    RPL36   MT-CO2     RPS7 \n      10       10       10       10       10        9        9        8 \n  RPL35A    RPS4X \n       8        8 \n\n\nWe can also ask how often each value appears:\n\ntable( count_matrix[ , cell] )\n\n\n    0     1     2     3     4     5     6     7     8     9    10    11    12 \n31919   594    89    30    12    10    15    11    11     2     8     4     2 \n   13    14    15    16    17    18    19    20    23    25    46    65    72 \n    4     3     1     4     6     3     4     1     1     1     1     1     1 \n\n\nWhat are the most strongly expressed genes? Let’s average over all cells:\n\nrowMeans(count_matrix) %&gt;% sort(decreasing=TRUE) %&gt;% head(30)\n\n  MALAT1   TMSB4X      B2M    RPL10    RPL13   RPL13A      FTL     RPS2 \n59.88333 46.00370 44.94926 32.78407 28.55963 28.46037 27.66741 24.13148 \n    RPS6     FTH1    RPS18    RPL11    RPL32     RPS3    RPL19    RPS12 \n23.16519 21.23741 20.52333 19.12370 19.10815 18.89815 18.15852 17.87259 \n   RPLP1     ACTB     RPL3    RPS27    RPS19    RPS14   EEF1A1   RPL18A \n17.57407 17.54185 17.48593 16.70148 16.24370 16.04000 15.52000 15.17741 \n  MT-CO1    RPL28   TMSB10    RPS4X    RPLP2    RPL21 \n14.51519 14.30741 13.81704 13.76704 13.21630 12.96333 \n\n\nHow similar are two arbitrarily picked cells?\n\ncell1 &lt;- 1352\ncell2 &lt;- 762\n\nplot( \n  jitter( count_matrix[,cell1] + 1 ), \n  jitter( count_matrix[,cell2] + 1), \n  cex=.3, log=\"xy\" )\n\n\n\n\n\n\n\nAnalysis with Seurat\n\ncount_matrix %&gt;%\nCreateSeuratObject() %&gt;%\nNormalizeData() %&gt;%\nFindVariableFeatures() %&gt;%\nScaleData() %&gt;%\nRunPCA( npcs=20 ) %&gt;%\nFindNeighbors( dims=1:20 ) %&gt;%\nFindClusters( resolution=0.5 ) %&gt;%\nRunUMAP( dims=1:20 ) -&gt; seu\n\nWarning: Feature names cannot have underscores ('_'), replacing with dashes\n('-')\n\n\nNormalizing layer: counts\n\n\nFinding variable features for layer counts\n\n\nCentering and scaling data matrix\n\n\nPC_ 1 \nPositive:  CST3, TYROBP, LST1, AIF1, FTL, FCN1, LYZ, FTH1, S100A9, FCER1G \n       TYMP, CFD, LGALS1, S100A8, CTSS, LGALS2, SERPINA1, SPI1, IFITM3, PSAP \n       CFP, SAT1, IFI30, COTL1, S100A11, NPC2, LGALS3, GSTP1, PYCARD, NCF2 \nNegative:  MALAT1, LTB, IL32, CD2, ACAP1, STK17A, CTSW, CD247, CCL5, GIMAP5 \n       AQP3, GZMA, CST7, TRAF3IP3, MAL, HOPX, ITM2A, GZMK, MYC, GIMAP7 \n       BEX2, ETS1, LDLRAP1, ZAP70, LYAR, RIC3, TNFAIP8, NKG7, KLRG1, SAMD3 \nPC_ 2 \nPositive:  NKG7, PRF1, CST7, GZMA, GZMB, FGFBP2, CTSW, GNLY, GZMH, SPON2 \n       CCL4, FCGR3A, CCL5, CD247, XCL2, CLIC3, AKR1C3, SRGN, HOPX, CTSC \n       TTC38, S100A4, ANXA1, IL32, IGFBP7, ID2, ACTB, XCL1, APOBEC3G, SAMD3 \nNegative:  CD79A, MS4A1, TCL1A, HLA-DQA1, HLA-DRA, HLA-DQB1, LINC00926, CD79B, HLA-DRB1, CD74 \n       HLA-DPB1, HLA-DMA, HLA-DQA2, HLA-DRB5, HLA-DPA1, HLA-DMB, FCRLA, HVCN1, LTB, BLNK \n       KIAA0125, P2RX5, IRF8, IGLL5, SWAP70, ARHGAP24, SMIM14, PPP1R14A, FCRL2, C16orf74 \nPC_ 3 \nPositive:  PPBP, PF4, SDPR, SPARC, GNG11, NRGN, GP9, RGS18, TUBB1, CLU \n       HIST1H2AC, AP001189.4, ITGA2B, CD9, TMEM40, CA2, PTCRA, ACRBP, MMD, NGFRAP1 \n       TREML1, F13A1, RUFY1, SEPT5, MPP1, TSC22D1, CMTM5, RP11-367G6.3, MYL9, GP1BA \nNegative:  HLA-DQA1, CD79A, CD79B, HLA-DQB1, HLA-DPB1, CD74, HLA-DPA1, MS4A1, HLA-DRB1, HLA-DRB5 \n       HLA-DRA, HLA-DQA2, TCL1A, LINC00926, HLA-DMB, HLA-DMA, HVCN1, FCRLA, IRF8, BLNK \n       KIAA0125, SMIM14, PLD4, P2RX5, IGLL5, SWAP70, LAT2, TMSB10, IGJ, MZB1 \nPC_ 4 \nPositive:  HLA-DQA1, HIST1H2AC, PF4, CD79A, SDPR, CD79B, PPBP, GNG11, HLA-DQB1, SPARC \n       MS4A1, CD74, GP9, HLA-DPB1, RGS18, NRGN, PTCRA, CD9, HLA-DQA2, AP001189.4 \n       CLU, TUBB1, CA2, HLA-DRB1, HLA-DPA1, ITGA2B, HLA-DRA, TCL1A, TMEM40, ACRBP \nNegative:  VIM, S100A8, S100A6, S100A4, TMSB10, S100A9, IL32, GIMAP7, S100A10, LGALS2 \n       RBP7, MAL, FCN1, LYZ, CD2, S100A12, MS4A6A, FYB, S100A11, AQP3 \n       GIMAP4, FOLR3, ANXA1, MALAT1, AIF1, GIMAP5, IL8, IFI6, TRABD2A, ASGR1 \nPC_ 5 \nPositive:  GZMB, FGFBP2, NKG7, GNLY, PRF1, CCL4, CST7, SPON2, GZMA, GZMH \n       CLIC3, XCL2, CTSW, TTC38, AKR1C3, CCL5, IGFBP7, XCL1, S100A8, CCL3 \n       TYROBP, HOPX, CD160, HAVCR2, S100A9, FCER1G, PTGDR, LGALS2, RBP7, S100A12 \nNegative:  LTB, VIM, AQP3, PPA1, MAL, KIAA0101, CD2, CORO1B, CYTIP, FYB \n       IL32, TRADD, ANXA5, TUBA1B, HN1, PTGES3, TYMS, ITM2A, COTL1, GPR183 \n       ACTG1, TNFAIP8, ATP5C1, TRAF3IP3, GIMAP4, PRDX1, ZWINT, ABRACL, NGFRAP1, LDLRAP1 \n\n\nComputing nearest neighbor graph\n\n\nComputing SNN\n\n\nModularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck\n\nNumber of nodes: 2700\nNumber of edges: 120276\n\nRunning Louvain algorithm...\nMaximum modularity in 10 random starts: 0.8640\nNumber of communities: 8\nElapsed time: 0 seconds\n\n\nWarning: The default method for RunUMAP has changed from calling Python UMAP via reticulate to the R-native UWOT using the cosine metric\nTo use Python UMAP via reticulate, set umap.method to 'umap-learn' and metric to 'correlation'\nThis message will be shown once per session\n\n\n15:17:26 UMAP embedding parameters a = 0.9922 b = 1.112\n\n\n15:17:26 Read 2700 rows and found 20 numeric columns\n\n\n15:17:26 Using Annoy for neighbor search, n_neighbors = 30\n\n\n15:17:26 Building Annoy index with metric = cosine, n_trees = 50\n\n\n0%   10   20   30   40   50   60   70   80   90   100%\n\n\n[----|----|----|----|----|----|----|----|----|----|\n\n\n**************************************************|\n15:17:26 Writing NN index file to temp file /tmp/RtmpPldfRL/file6aee1ff81808\n15:17:26 Searching Annoy index using 1 thread, search_k = 3000\n15:17:27 Annoy recall = 100%\n15:17:27 Commencing smooth kNN distance calibration using 1 thread with target n_neighbors = 30\n15:17:28 Initializing from normalized Laplacian + noise (using RSpectra)\n15:17:28 Commencing optimization for 500 epochs, with 111204 positive edges\n15:17:31 Optimization finished\n\n\n\nUMAPPlot( seu ) + ggplot2::coord_equal()\n\n\n\n\nIn this plot, each cell is represented by a point in a so-called dimension-reduced embedding. This means that the points have been arranged such that cells that are similar appear close to each other while cells that are very different are put far apart from each other.\nWe will discuss soon in detail how such dimension reduction works and, importantly, what is meant by “similar”.\nSeurat has also run a “clustering” algorithm that assigns the cells to different “clusters” of cells that are similar to each other. Colours are used here to indicate cluster membership.\nWe observe that the cells fall into three big groups that each split into a number of smaller clusters.\n\nIdentifying cell types\nWe suspect that these represent different types of white blood cells. There should be B-cells, T-cells and perhaps monocytes.\nT cells are defined as white blood cells that show a the T-cell receptor as their surface, a protein complex made up of various proteins, one of which is called the T-cell receptor epsilon chain. This protein is described for the gene CD3E. We can ask Seurat to indicate the read counts for this gene in the UMAP plot:\n\nFeaturePlot( seu, \"CD3E\")\n\n\n\n\nWe conclede that clusters 0 and 3 are probably the T cells.\nWe can also colour for CD79A, a marker for B cells:\n\nFeaturePlot( seu, \"CD79A\")\n\n\n\n\nTo find out what the group to the left is, we can go another way. Let’s ask Seurat to find genes that are expressed much mroe strongly in clusters 1 and 4 than in clusters 0, 2, 3, 5:\n\nFindMarkers( seu, ident.1=c(1,4), ident.2=c(0,2,3,5), test.use=\"t\" ) -&gt; m\nhead( m, 50 )\n\n                 p_val avg_log2FC pct.1 pct.2     p_val_adj\nLST1      0.000000e+00  5.2602174 0.969 0.147  0.000000e+00\nCST3      0.000000e+00  5.6816322 0.994 0.193  0.000000e+00\nTYROBP    0.000000e+00  4.5599105 0.995 0.194  0.000000e+00\nFCER1G    0.000000e+00  3.9303734 0.953 0.153  0.000000e+00\nAIF1      0.000000e+00  4.8394973 0.968 0.171  0.000000e+00\nPTPRCAP   0.000000e+00 -4.3390790 0.123 0.820  0.000000e+00\nLGALS1    0.000000e+00  3.5888431 0.982 0.303  0.000000e+00\nCTSS      0.000000e+00  3.3704116 0.956 0.370  0.000000e+00\nIL32      0.000000e+00 -4.5060681 0.123 0.703  0.000000e+00\nS100A11   0.000000e+00  2.9021375 0.959 0.381  0.000000e+00\nLYZ       0.000000e+00  5.5523830 0.995 0.471  0.000000e+00\nSAT1      0.000000e+00  3.1880331 0.972 0.454  0.000000e+00\nCOTL1     0.000000e+00  2.9140976 0.974 0.505  0.000000e+00\nS100A6    0.000000e+00  2.4265040 0.992 0.712  0.000000e+00\nS100A4    0.000000e+00  2.1051825 1.000 0.752  0.000000e+00\nOAZ1      0.000000e+00  1.9165328 0.995 0.877  0.000000e+00\nFTL       0.000000e+00  3.6241681 1.000 0.983  0.000000e+00\nFTH1      0.000000e+00  3.1675076 1.000 0.984  0.000000e+00\nCD3D     4.886112e-319 -4.3674643 0.092 0.670 1.599615e-314\nTYMP     3.882155e-306  4.2566370 0.926 0.151 1.270940e-301\nS100A9   1.783818e-297  7.0670428 0.962 0.154 5.839865e-293\nPSAP     1.902707e-294  2.9956639 0.934 0.359 6.229083e-290\nFCN1     9.535250e-274  5.5804410 0.896 0.092 3.121650e-269\nCYBA     8.453508e-272  1.5333488 0.991 0.797 2.767510e-267\nMALAT1   1.181579e-262 -1.5311747 1.000 1.000 3.868252e-258\nLTB      4.335583e-260 -3.5012014 0.348 0.824 1.419383e-255\nNPC2     1.360721e-240  3.2405179 0.896 0.252 4.454729e-236\nCD3E     8.066458e-236 -3.7395374 0.104 0.612 2.640797e-231\nCFD      7.012340e-210  5.9290434 0.822 0.036 2.295700e-205\nS100A8   1.234624e-205  7.2702939 0.855 0.084 4.041912e-201\nHLA-DRA  9.958375e-200  0.9548420 0.945 0.423 3.260173e-195\nGABARAP  3.036143e-190  2.4215683 0.881 0.351 9.939724e-186\nCD7      2.761808e-188 -4.2406042 0.058 0.475 9.041608e-184\nGSTP1    8.906341e-186  2.9200924 0.877 0.315 2.915758e-181\nRPS27    6.463844e-178 -1.2827741 0.988 0.998 2.116133e-173\nCD68     5.216417e-175  5.1623519 0.757 0.039 1.707751e-170\nGPX1     2.638599e-174  3.1465728 0.853 0.267 8.638245e-170\nSERPINA1 5.945946e-174  4.6390651 0.770 0.069 1.946584e-169\nLCK      2.819845e-170 -3.6083579 0.058 0.464 9.231609e-166\nNEAT1    1.968831e-169  1.8285530 0.928 0.540 6.445560e-165\nRPL3     5.794248e-169 -1.1390928 0.994 0.999 1.896921e-164\nPYCARD   8.652551e-167  2.7349426 0.824 0.215 2.832672e-162\nLGALS2   4.290216e-165  6.6287302 0.743 0.029 1.404531e-160\nRPL13A   9.270560e-165 -0.8866787 1.000 1.000 3.034996e-160\nRPS27A   2.750106e-158 -1.7498987 0.911 0.996 9.003298e-154\nCD2      8.578003e-155 -4.2838412 0.052 0.407 2.808267e-150\nRAC1     1.921305e-154  2.2617174 0.845 0.294 6.289968e-150\nCXCR4    2.275604e-153 -2.6822981 0.285 0.701 7.449873e-149\nRPL23A   2.157301e-152 -1.2329204 0.980 0.997 7.062571e-148\nTKT      2.978425e-152  2.8123604 0.793 0.200 9.750769e-148\n\n\nFrom this list, an immunologist would quickly see that these cells are monocytes.\n\n\nBack to math\nWhat is happening inside Seurat.\nA few questions we might have:\n\nHow do we define “similarity” of cells?\nEach cell is represented by a vector of count values. Can we simply define a metric or distance measure in that space to quantify similarity?\nIt will turn out that this does not work, due to the counting noise. Why?\nHow can we make cells with differing total read count comparable?\nWe will overcome the count-noise issue by performing a principal component analysis (a matrix decomposition based on the eigendecomposition). Why does that work?\nThe cells seem to be living in a high-dimensional space. Can this really be faithfully shown by a two-dimensional plot? How do we check the faithfulness? Here, we will get into a rabbit hole involving multi-variate optimization, metrics in distribution spaces, interactive visualizations and maybe GPU programming.\nHow to suitable define “clusters” of similar cells? This will lead us to applications of graph theory.\n\n\n\nThe manifold hypothesis\nA teaser to the core idea in single-cell analysis:\nCells “live” in a “state space” that is spanned by all the possible configurations of the cells in the organism. When a cell reacts to a stimulus or changes its state for another reason, this will be a continuous (maybe even smooth?) move in this statespace.\nHowever, we cannot observe the state space directly – but we assume that each state is associated with a transcriptome, i.e., a measure or distribution in the space of read count vectors spanned by the genes (i.e., of possible columns in the count matrix).\nWe assume that the distribution of the cells in our sample lives on a manifold in state space, and we wish to learn first the topology of this manifold, then gain a metric and an atlas for it, then infer the distribution/measure on this manifold, from which our cells have been sampled. And finally, we have to translate this mathematical description into a biological insights."
  },
  {
    "objectID": "biology_primer.html",
    "href": "biology_primer.html",
    "title": "Biology Primer",
    "section": "",
    "text": "This document lists some basic facts on molecular biology for the non-biologists in the audience – even though you should remember these points from high school.\n\nDNA\n\nA cell’s genetic information is stored in its DNA (desoxyrobonucleic acids). DNA is a polymer, i.e., it is made as a long chain of repeating elements, the nucleotides, which are linked by phosphate bonds.\nThere are four nucleotides: adenine (A), cytosine (C), guanine (G) and thymine (T). The information stored in the DNA is represented by the sequence of these elements.\nDNA is a double-helix, comprising two strands running in opposite direction whose bases are paired up (base pairing). Adenine always pairs with thymine (AT), cytosine with guanine (CG.\nTherefore, the sequences of the two strands are related to each othe by the operation of reverse complementation, i.e., reversing the sequence, and replacing each base by its complementary base (i.e., swapping A↔︎Tv and G↔︎T). Example:\n\n&gt;&gt;&gt;&gt; AGGCTCAGT &gt;&gt;&gt;&gt;   (first strand, read from left to right)\n&lt;&lt;&lt;&lt; TCCGAGTCA &lt;&lt;&lt;&lt;   (second strand, read from right to left)\n\nEach base pair (bp) in the genome contains 2 bit of information.\nTo make copies of DNA, the cell uses enzymes called polymerases which seperate the two strands and use one of the strands as “template” to assemble a new strand by base-pairing.\nPolymerases are used to duplicate the DNA for cell division, and to make RNA (see below).\nIn eukaryotes (cells with proper cellular nucleus), DNA is organized in chromosomes: long linear chains. In procaryotes (bacteria and archae, which do not have a nucleus), DNA forms a loop. Eukaryotes also contain mitochondriae (abbreviated MT) which contain a DNA loop like prokaryotes.\nThe chromosomes are numbered (for humans: from 1 to 22) except for the sex chromosomes, which are denoted X and Y.\nA reference assembly is a set of sequences for a species’ chromosomes that is used to describe a “typical” or “average” individual’s DNA.\nThere are databases that describe which parts of the DNA sequence is the same in (nearly) all individuals and which parts tend to vary between individuals (polymorphisms).\n\n\n\nRNA\n\nIn order to “make use of”work” with DNA, the cell can make a copy of a defined stretch of the DNA. This copy is made as RNA, a chemical variant of DNA, and is single-stranded, i.e. not a double helix.\nIn RNA, the base thymine (T) is replaced by uracil (U).\nThe process of making an RNA copy of DNA is called transcription, the produced RNA is called a transcript.\nA region of DNA that is regularly transcribed to RNA is called a gene.\nAn important class of transcripts are those that conatin “blueprints” for proteins. The genes producing these are called protein-coding genes.\n\n\n\nDirections\n\nChromosomes have a special region in the middle called the centromer that divides the chromsome into two arms. By convention, the shorter arm (p arm) is on the left, and the base pairs are numbered from left to right, starting either with 1 or 0.\nIn RNA, sequences are written in the same order in which they are chained by the polymerase and read by the ribosome. The start is called the 5’ end, the end (in reading direction) is called the 3’ end.\n\n\n\nProteins\n\nProteins are polymeric macromolecules formed from chains of amino acids.\nProteins that catalyze chemical reactions are called enzymes. They are the molecular machines that make living cells possible.\nStructural proteins, in contrast, are building blocks for the cells structure.\nProteins are polymers of basic building blocks, the amino acids (AAs), that are connected via the so-called peptide bond.\nThere are 20 proteinogenic amino acids (+2 special ones).\nA protein is defined by the sequence of these amino acids.\nA special molecular machine, the ribosome, assembles proteins by chaining together individual amino acids. It reads of the requried sequence of the amino acids from an RNA transcript called a messenger RNA.\nThis process is called translation\nWhile the linear AA chain is assembled the nascent protein folds into a complicated 3D shape that is crucial for its function. This happens due to chemical attractions and repulsions between the amino acids in the chain and between an amino acid and the surrounding water molecules.\nThe amino acids all differ in their chemical properties, thus making a wide variety of such interactions possible.\n\n\n\nThe genetic code\n\nAn RNA transcript that can be processed by a ribosome to build a protein is called “messenger RNA” (mRNA).\nIt contains a sequence of groups of three bases each, called codons. Each of the \\(4^3\\) possible codons codes for an amino acid, except for the stop codon that instructs the ribosome to finish the translation and release the finished protein.\nAs there are 20 amino acids (and the stop signal), the code is redundant: For each meaning there are 2 to 4 codons.\nHere is the genetic code.\n\n\n\nTranscript types\nThere are several types of genes/transcripts:\n\nProtein-coding genes are transcribed to messenger RNA (mRNA), which are read by ribosomes and serve as “blueprint” for assembling proteins.\n\nAn mRNA transcript has three parts: The part in the middle is called the coding sequence (CDS), which contains the sequence of codons, always starting with AUG (the codon for methionine, that also serves as start signal).\nThe part before the transcription start signal is called the 5’ untranslated region (5’-UTR).\nThe part after the stop codon is called the 3’ untranslated region (3’ UTR).\nIn most cases, the 3’ UTR is followed by a multiple adenines, called the poly-A tail.\n\nOther transcripts are called non-coding. There are several:\n\nRibosomal genes are transcribed to ribosomal RNA (rRNA). These fold into a special shape that can catalyze reactions (a ribozyme) and form the core of the ribosome. The vast majority of a cell’s RNA is rRNA.\nTransfer RNA (tRNA) are short pieces of RNA that hold individual amino acids and supply them to the ribosomes.\nsmall nucleolar RNAs (snoRNAs) have a role in splicing (see below).\nmicro-RNAs (miRNAs) and long non-coding RNAs (lncRNAs) are various other RNA that have regulatory roles, e.g., they influence how often a messenger transcript gets translated before it gets degraded.\n\n\n\n\nSplicing and isoforms\n\nWhile a (protein coding or a long non-coding) gene is transcribed, a machinery called the spliceosome cuts out large parts of the produced transcripts, reducing the initial “pre-mRNA” to a much shorter “mature mRNA”. The removed parts are called introns, the remaining parts (that are chained together) are called exons. The places wher the RNA is cut are called splice sites.\nDepending on many factors, one gene can give rise to different transcripts (transcript isoforms) that differ in where the transcription starts, where is terminates (or: where the poly-A tail is attached) and which splice sites are used.\nA “gene model” is teh information what isoforms have been observed to be produced by a gene. A collection of models for all genes, togetehr with the transcript types (see above) is called a “gene annotation” for a reference assembly."
  },
  {
    "objectID": "overview_hts.html",
    "href": "overview_hts.html",
    "title": "Overview High-throughput Sequencing",
    "section": "",
    "text": "DNA Sequencing\n\nSanger sequencing\n\nWith Sanger’s invention of what is now called Sanger sequencing (1977) it became possible to read off the sequence of DNA molecules. Typically, one can read several hundreds of bases from one end towards the other end.\nFor Sanger sequence, one needs a huge amount of copies of the same DNA fragments.\nFortunately, it is easy to exponentially amplify DNA with the polymerase-chain reaction (PCR) which is able to duplicate DNA molecules and so doubles the number of molecules in each reaction cycle.\nAvailability of commercial Sanger sequencers (from 1984 on) with read-out via fluorescent light (in 4 colours) made it possible to sequence, e.g., the entire human genome (“completed” 2003).\nSanger sequencing works in solution. The liquid solution must contain copies of only one sequence; as one otherwise gets an unreadable mixture of sequencing signals from the different sequences.\n\n\n\nHigh-throughput sequencing\n\nIn the early 2000s, ideas came up to fix the DNA fragments to a surface and perfrom the DNA such that the copies attach to the surface in clsoe proximity.\nThus, one can spread many different DNA fragments over the surface and amplify each fragment into a “cluster” of copies. As the surface offers space for millions of spatially separated clusters, one can obtain the sequences of millions of different DNA fragments in parallel.\nSuch high-throughput sequencing (HTS) machines became available in the 2000s and have sense continuously improved in throughput and cost effectiveness.\nThe method described above has been commercialized by Solexa, which was then bought by Illumina. It was not the first, but one of the first HTS methods. Illumina is still market leader for HTS machines.\nNow, it is possible to obtain a human subject’s (nearly) complete genome within two days for a few hundred euro.\nThe approach is to obtain DNA from many cells and fragment it into many pieces of a few hundred base-pairs (bp) length.\nThe number of sequencing reads that overlap a give base pair in the genome is Poisson distributed.\nThe expected number of fragments (the “coverage” rate) depends on the total number of sequencing reads obtained.\nTherefore, a trade-off has to be made between cost-effectiveness and completeness.\n\n\n\nTranscriptomics / RNA sequencing\n\nAll cells of an individual have the same DNA, but they differ vastly in shape and function. (Compare a blood cell with a skin cell.)\nThis is because different cells express (i.e., transcribe) different genes, because they need different proteins.\nWhich genes a cell expresses and to what extent is regulated by complicated biochemical reactions.\nHence, a cell’s type and state is reflected to a good extent by its RNA content, also called its “transcriptome”.\nTherefore, a comparably simple way to get a large amount of information about what is goin on in a biological sample is to extract the RNA from all the cells and sequence it.\nRNA can be readily transformed into complimentary DNA (using a process called reverse transcription, that can easily performed in vitro), and this DNA is the sequenced using HTS.\n\n\n\nAnalysis of RNA-Seq data\n\nWhen performin RNA sequencing, one obtains a very long list with sequences of the RNA fragments (the “reads”), typically as text file in FASTQ format.\nOne then aligns the reads to the genome: A special program, called a short-read aligner is used to search for the sequence of each read in the genome (i.e., in a reference assembly). Of course, the aligner has to search through the chromosome sequences and their reverse complements.\nThe aligner should be splice-aware, i.e., expect that a read might strecth over an intron and hence align to two places with a gap in between.\nThe aligner produces a file (typically in SAM format) that give for each read the position in the genome where the sequence matched. Typically, the chromosome name is given, the position in the chromosome (as an integer) where the read’s match starts, the strand (“+” for match to the sequence as given, “-” for match to the reverse complement), followed by information on skipped parts (introns), descripancies between reference and read (mismatched bases) etc.\nA portion of the reads will stay “unmapped” (i.e., the aligner could not find their sequence in the genome), and some reads might match several loci (positions) in the genome.\nUsing a genome annotation file (which contains the genetic coordinates of all genes with their transcripts and exons), another software then determines for each read which gene it is from.\nIn the end, we get for each gene a count: a number telling us how many sequencing reads were seen that mapped to this gene.\n\n\n\nBulk RNA-Seq\n\nUsually one performs RNA-Seq in order to compare the transcriptome of differend types of samples.\nFor example, one might compare tumor samples with samples from adjacent normal tissues. In order to make sure that results are general and not specific to on subject, one needs sample pairs from several, or, ideally, many, patients. Genes whose expression is constistently stronger in the tumor samples than in the corresponding normal samples might be the genes that cause the tumour’s malignancy.\nOther useful comparisons might be\n\nCompare tissue samples from mice that have been treated with some drug with “control mice” which have received a placebo, to see how the drug influences the cells’ function.\nCompare samples from different tissues, to understand the difference between them.\nand many more\n\nIn most cases, the goal is to find differentiaklly expressed genes (DGEs), i.e., genes whose expression strength differs in a consistent (i.e., statistically significant) manner between the sample groups\n\n\n\nSingle-cell RNA-Seq\n\nTissues comprise many cell types.\nFor example, skin contain keratinocyte (which make up the skin’s sturdy outer layer), other epithelial cells (comprising e.g. the soft lower layer), cells making up the hair follicles, even muscle cells that can raise the hairs and, of course, the endothelial cells that line the blood capillaries and the various blood cells inside these, as well as receptor and nerve cells so that we can sense touch, heat, cold and pain etc.\nIf we find genes that are differentially expressed between, say, healthy skin and skin affected by a disease – which of these cell types is affected? Is the gene upregulated (i.e., expressed more strongly) in all cell types or only in some.\nWe would need to know which of the sequencing reads come from which cell.\n\nIn single-cell RNA-Seq we can tell whether two reads come from the same cell or from two different cells.\nThere are at least three possible ways to achieve this. - Plate-based methods: A microtiter plate is used (a grid-like arrangement of many miniature “test tubes” called “wells”) and a flow cytometer is used to place exactly one cell into each well. - Microfluidic methods: An emulsion of water droplets in oil is produced using microfluidics such that each water-in-oil droplet contains (ideally) at most one cell. - Combinatorial indexing: We skip the explanation for these.\nEach compartment (well or droplet) gets a “DNA barcode oligo”: a short piece of DNA with a random sequence that gets incorporated into the cDNA during reverse transcription. Thus, each sequenced fragment contains teh sequence of the RNA fragment, together with this “cell barcode” that identifies the compartment (and hence the cell) that the read came from.\nWe will get back to details on how this works.\n\n\nPreprocessing of single-cell RNA-Seq data\n\nAs before, each reads gets aligned to the genome. Afterwards, the gene that the read maps to is identified.\nAdditionally, the cell barcode is analysed. A list of all cell barcodes that appear in the sample is generated, and each read is assigned to one element in this list.\nThe final result is a count matrix:\n\nThe rows of the matrix correspond to genes.\nThe columns correspond to cell barcodes and hence cells.\nThe matrix entries tell how many reads have been found that mapped to this gene and seemed to originated from the cell with this barcode.\n\n\nThere are a number of complications that we will need to discuss: - A barcode may be corrupted by a read error, causing a read to be assigned to the wrong cell. - A compartment may not have contained a cell but still contained a few RNA molecules that were present in the solution, stemming from destroyed cells with broken cell membrane. Such barcode will have very few reads assigned to them, and we have to recognize them as not being cells. - A compartment might have contained more than one cell, and thus a mixture of RNA from several cells of possibly different type. This is called a “doublet”.\nThe main issue, however, is: The process is very lossy. A typical mammalian cell contains a several hundred thousands of mRNA molecules, but we usually only get a few thousand (microfluidics methods) or at best up to around 20,000 reads (plate-based methods).\nWhich molecules get sequenced is a random process, and we need to take care of the “counting noise” thus produced.\nMany genes are produced by the cells at very low copy numbers, and with the selection during sequencing, we will very frequently end up with a zero count. The count matrix is therefore very sparse (i.e., a large fraction of the matrix elements have the value 0)."
  },
  {
    "objectID": "pedestrian.html",
    "href": "pedestrian.html",
    "title": "Doing the Seurat analysis “on foot”",
    "section": "",
    "text": "We load our example data\n\nsuppressPackageStartupMessages( {\n  library( Seurat )\n  library( Matrix ) } )\n\n\ncount_matrix &lt;- Read10X( \"data/pbmc3k/filtered_gene_bc_matrices/hg19/\" )\n\nQu: Examine the sparse storage format of the matrix.\n\nNormalization\nThe total rad counts per cell (the column sums of the count matrix) differ noticeably.\nIn order to compare between cells, we should not look at the absolute counts but better at the fraction that each gene’s count contributes to the total. Hence, we divide the matrix by the column sum:\n\nfractions &lt;- t( t(count_matrix) / colSums(count_matrix) )\n\n\n\nVariance-mean dependence\nWe calculate for each gene mean and variance across all cells and plot them against each other:\n\nlibrary( sparseMatrixStats )\n\nLoading required package: MatrixGenerics\n\n\nLoading required package: matrixStats\n\n\n\nAttaching package: 'MatrixGenerics'\n\n\nThe following objects are masked from 'package:matrixStats':\n\n    colAlls, colAnyNAs, colAnys, colAvgsPerRowSet, colCollapse,\n    colCounts, colCummaxs, colCummins, colCumprods, colCumsums,\n    colDiffs, colIQRDiffs, colIQRs, colLogSumExps, colMadDiffs,\n    colMads, colMaxs, colMeans2, colMedians, colMins, colOrderStats,\n    colProds, colQuantiles, colRanges, colRanks, colSdDiffs, colSds,\n    colSums2, colTabulates, colVarDiffs, colVars, colWeightedMads,\n    colWeightedMeans, colWeightedMedians, colWeightedSds,\n    colWeightedVars, rowAlls, rowAnyNAs, rowAnys, rowAvgsPerColSet,\n    rowCollapse, rowCounts, rowCummaxs, rowCummins, rowCumprods,\n    rowCumsums, rowDiffs, rowIQRDiffs, rowIQRs, rowLogSumExps,\n    rowMadDiffs, rowMads, rowMaxs, rowMeans2, rowMedians, rowMins,\n    rowOrderStats, rowProds, rowQuantiles, rowRanges, rowRanks,\n    rowSdDiffs, rowSds, rowSums2, rowTabulates, rowVarDiffs, rowVars,\n    rowWeightedMads, rowWeightedMeans, rowWeightedMedians,\n    rowWeightedSds, rowWeightedVars\n\nplot( rowMeans(fractions), rowVars(fractions), cex=.3 )\n\n\n\n\nQu: The function rowVars is here taken from the “sparseMatrixStats”. How would you calculate the row variances of a matrix given in one of the sparse storage formats?\nIt is helpful to make the plot logarithmic\n\nplot( rowMeans(fractions), rowVars(fractions), cex=.3, log=\"xy\", col=scales::alpha( \"black\", .3 ) )\n\nWarning in xy.coords(x, y, xlabel, ylabel, log): 16104 x values &lt;= 0 omitted\nfrom logarithmic plot\n\n\nWarning in xy.coords(x, y, xlabel, ylabel, log): 16104 y values &lt;= 0 omitted\nfrom logarithmic plot\n\nsegments( 1e-6, 1e-10, 1e-2, 1e-6 )   # line with slope 1 on log-log plot   --&gt; v ∝ µ\nsegments( 1e-7, 1e-10, 1e-4, 1e-4 )   # line with slope 2 on log-log plot   --&gt; v ∝ µ²\n\n\n\n\nWe have a look at the squared coefficient of variation (CV²):\n\nplot( rowMeans(fractions), rowVars(fractions) / rowMeans(fractions), \n      cex=.3, log=\"xy\", col=scales::alpha( \"black\", .3 ) )\n\nWarning in xy.coords(x, y, xlabel, ylabel, log): 16104 x values &lt;= 0 omitted\nfrom logarithmic plot\n\nabline( h = mean( 1/colSums(count_matrix)), col=\"orange\")\n\n\n\n\nFor later use, we keep a list of the 1000 genes with the highest CV²:\n\nhvg &lt;- names( head( sort( rowVars(fractions) / rowMeans(fractions), decreasing=TRUE ), 1000 ) )\n\nWe call these the “highly variable genes” (HVG).\n\n\nLog-transformation\nFor the more strongly expressed (and hence more informative) genes, SD seems to be proportional to mean, i.e., we have multiplicative noise. TO make this homoskedastic, we should logarithmize our fractions.\nHowever, \\(\\log(0)=-\\infty\\). As a “hack” to avoid this, let us as a small value to each faction before taking the log. Seurat used \\(10^{-4}\\).\nSo, if \\(k_{ij}\\) is the read count for gene \\(i\\) in cell \\(j\\) and \\(s_j=\\sum_i k_{ij}\\) the total read count for cell \\(j\\), we might use \\(\\log_{10}\\left(\\frac{k_{ij}}{s_j}+10^{-4}\\right)\\). However, is seems convenient to use a transformation that maps 0 to 0. Therefore, Seurat (and many other work flows use):\n\\[ y_{ij} = \\log_{10}\\left(\\frac{k_{ij}}{s_j}\\cdot 10^4 + 1\\right)\\]\nThe ``+1’’ is often referred to as the “pseudocount”, because it is roughly one extra read count – if \\(s_j\\) is around \\(10^4\\).\n\nexpr &lt;- log1p( fractions * 1e4 + 1 )\n\nTask: Compare with Seurat and check whether it uses natural or decadic logarithm.\nNote: The function log1p preserves the matrix’s sparse storage format. Why does this not work with log( 1 + . )?\n\n\nDistances\nLet’s pick a random cell and check its distance to all other cells, using Euclidean distance on expr.\n\ncell &lt;- sample.int( ncol(expr), 1 )\n\nhist( sqrt( colSums( ( expr - expr[,cell] )^2 ) ), 100 )\n\n\n\n\nRemembering that the cells fall into three “clusters”, we might have hoped to get a bimodal distribution, with the cells from the chosen cell’s own cluster being closer and the other being farther. This is not the case, even if we try many cells.\nPCA will save us, however.\n\n\nPCA\nWe perform a principal component analysis (PCA) on the expr matrix. To save time, we - calculate only the top 20 PCs, and use a PCA function that can take advantage of this and of the fact that our matrix is sparse - use only the 1000 most variable genes (as seen above)\n\npca &lt;- irlba::prcomp_irlba( t( expr[hvg,] ), n=20, center=TRUE, scale.=TRUE )\n\nrownames(pca$rotation) &lt;- hvg\nrownames(pca$x) &lt;- colnames(expr)\n\n\n\nDistances again\nNow, let’s try again with the distances:\n\ncell &lt;- sample.int( ncol(pca$x), 1 )\n\nhist( sqrt( rowSums( ( pca$x - pca$x[cell,] )^2 ) ), 100 )\n\n\n\n\nNow, for at least some cells, we get a clearly bimodal distribution.\n\n\nNeighbor graph\nAs we only have a small data set, we can calculate the full distance matrix:\n\ndm &lt;- as.matrix( dist( pca$x ) )\n\nQu: Pick two cells, calculate the Euclidean distance of the their PCA scores “manually” and compare with the matrix entry. It should agree.\nFor a given cell, find its 20 nearest neighbors:\n\ncell &lt;- 134\norder( dm[134,] )[1:20]\n\n [1]  134  878  933  237  590 1198  787 1873 1506 1306 1743 1024  965 1124 1713\n[16] 1726 1084  610  515 2438\n\n\nDo so for all cells:\n\nt(sapply( 1:ncol(expr), function(cell) \n  order( dm[134,] )[1:20] )) -&gt; nn\n\nMake a graph out of this\n\nlibrary( igraph )\n\n\nAttaching package: 'igraph'\n\n\nThe following object is masked from 'package:Seurat':\n\n    components\n\n\nThe following objects are masked from 'package:stats':\n\n    decompose, spectrum\n\n\nThe following object is masked from 'package:base':\n\n    union\n\n# ...\n\nApply a clustering algorithm onto it\n…"
  },
  {
    "objectID": "pca.html",
    "href": "pca.html",
    "title": "Principal Component Analysis",
    "section": "",
    "text": "Load example data\n\nsuppressPackageStartupMessages( {\n  library( Seurat )\n  library( Matrix )\n  library( sparseMatrixStats ) \n  library( tidyverse ) } )\n\ncount_matrix &lt;- Read10X( \"data/pbmc3k/filtered_gene_bc_matrices/hg19/\" )\n\nLog-normalize\n\nfractions &lt;- t( t(count_matrix) / colSums(count_matrix) )\nexpr &lt;- log1p( fractions * 1e4 )\n\nHighly variable genes:\n\nhvg &lt;- names( head( sort( rowVars(fractions) / rowMeans(fractions), decreasing=TRUE ), 1000 ) )\n\nAs a preparation for PCA, subset expression to HVGs, then center:\n\nexpr_centered &lt;- as.matrix( expr[hvg,] - rowMeans( expr[hvg,] ) )\n\nCentering means that all genes now have mean 0:\n\nrowMeans( expr_centered ) %&gt;% head()\n\n         PPBP         FCRL2        CEP128          DOK3         ARVCF \n-8.115936e-18  5.247860e-18 -1.151342e-18  4.476872e-18 -1.214306e-19 \n        YPEL2 \n-7.072532e-18 \n\n\nOptionally, we can also standardize the genes (i.e., divide by the standard deviation) so that they all have the same chance to influence the PCA. This point is optional in the sense that it is not required for the validity of the points we make below.\n\nexpr_centered / rowSds( expr_centered ) -&gt; expr_stdd\n\nThe centered expression matrix is what we supply to the PCA:\n\npca &lt;- irlba::prcomp_irlba( t( expr_stdd ), 20, scale.=FALSE, center=FALSE )\n\nrownames(pca$x) &lt;- colnames(expr_stdd)\nrownames(pca$rotation) &lt;- rownames(expr_stdd)\n\nTo remind us what the PCA does, let’s check that the PC score matrix \\(X\\) (pca$x) can relly be obtained from the expression matrix \\(Y\\) (t(expr_stdd)) via the loadings matrix \\(R\\) (pca$rotation): \\(YR=X\\)\n\n( t(expr_stdd) %*% pca$rotation )[1:5,1:5]\n\n                        PC1        PC2         PC3        PC4        PC5\nAAACATACAACCAC-1 -4.4561722  0.5435771  0.18664296 -2.4192526 -0.1511151\nAAACATTGAGCTAC-1 -0.8250185  2.3765237  4.00707855  6.8221179  2.6804905\nAAACATTGATCAGC-1 -2.3312564 -1.3021276 -2.35138861 -2.1671548  3.3980910\nAAACCGTGCTTCCG-1 10.5114431  2.0959988 -0.09797461  0.2043448  0.3759040\nAAACCGTGTATGCG-1  1.6880213 -4.8213875 -6.75849700  4.1443049 -5.9821060\n\npca$x[1:5,1:5]\n\n                        PC1        PC2         PC3        PC4        PC5\nAAACATACAACCAC-1 -4.4561722  0.5435771  0.18664296 -2.4192526 -0.1511151\nAAACATTGAGCTAC-1 -0.8250185  2.3765237  4.00707855  6.8221179  2.6804905\nAAACATTGATCAGC-1 -2.3312564 -1.3021276 -2.35138861 -2.1671548  3.3980910\nAAACCGTGCTTCCG-1 10.5114431  2.0959988 -0.09797461  0.2043448  0.3759040\nAAACCGTGTATGCG-1  1.6880213 -4.8213875 -6.75849700  4.1443049 -5.9821060\n\n\nIf we rotate in the other direction, we can reconstruct the expression matrix: \\(\\hat Y=XR^\\top\\)\n\nt( ( pca$x %*% t(pca$rotation) ) )[1:5, 1:5 ]\n\n       AAACATACAACCAC-1 AAACATTGAGCTAC-1 AAACATTGATCAGC-1 AAACCGTGCTTCCG-1\nPPBP       -0.000254819       -0.1202796      -0.06299039       0.17825774\nFCRL2      -0.109199553        1.2709282      -0.09809186      -0.19768285\nCEP128      0.048676874        0.1927019      -0.01869790      -0.05543508\nDOK3       -0.305134607        0.1725547      -0.09066065       0.52251219\nARVCF      -0.192669191       -0.2390528       0.14138719      -0.26052343\n       AAACCGTGTATGCG-1\nPPBP         0.05361365\nFCRL2        0.07628163\nCEP128      -0.04273337\nDOK3        -0.02864379\nARVCF        0.20478180\n\nexpr_stdd[1:5,1:5]\n\n       AAACATACAACCAC-1 AAACATTGAGCTAC-1 AAACATTGATCAGC-1 AAACCGTGCTTCCG-1\nPPBP        -0.14298358      -0.14298358      -0.14298358       2.91652450\nFCRL2       -0.12311737       3.95087439      -0.12311737      -0.12311737\nCEP128      -0.05661789      -0.05661789      -0.05661789      -0.05661789\nDOK3        -0.15956960      -0.15956960      -0.15956960      -0.15956960\nARVCF       -0.03920291      -0.03920291      -0.03920291      -0.03920291\n       AAACCGTGTATGCG-1\nPPBP        -0.14298358\nFCRL2       -0.12311737\nCEP128      -0.05661789\nDOK3        -0.15956960\nARVCF       -0.03920291\n\n\nThis reconstruction is, unsurprisingly, quite imperfect. After all, we truncated \\(R\\) to only 20 PCs.\nLet’s compare epxression and reconstruction for a random cell:\n\ncell &lt;- 123\n\nplot( expr_centered[,cell], ( pca$x %*% t(pca$rotation) )[cell,], asp=1 )\n\n\n\n\nCould be better. But let’s undo standardization and centering:\n\nplot( \n  expr[hvg,cell], \n  ( pca$x %*% t(pca$rotation) )[cell,] * rowSds( expr_centered ) +  rowMeans( expr[hvg,] ), \n  asp=1 )\n\n\n\n\nMuch better…\nStill, the preceding plot is actually the best one can get in some sense, and this is the reason we use the PCA.\nMaybe, we should make a plot, comparing one gene over all cells\n\ngene &lt;- hvg[1]\n\nplot( \n  ifelse( expr[gene,]&gt;0, expr[gene,], runif( ncol(expr), -.3, 0 ) ),\n  ( pca$x %*% t(pca$rotation) )[,gene], main=gene, cex=.3 )\n\n\n\n\n\nPower methods\nAbove, we had called\npca &lt;- irlba::prcomp_irlba( t( expr_stdd ), 20 )\nto ask the IRLBA package to perform a PCA on t(expr_stdd).\nA PCA on a matrix \\(Y\\) is performed by getting the eigenvectors of \\(Y^\\top Y\\):\n\nyty &lt;- expr_stdd[hvg,] %*% t(expr_stdd[hvg,])\n\neig &lt;- irlba::partial_eigen( yty, n=20 )\n\nstr(eig)\n\nList of 2\n $ vectors: num [1:1000, 1:20] 0.03929 -0.00701 -0.00527 0.0286 -0.00111 ...\n $ values : num [1:20] 94450 50384 41570 28163 17629 ...\n\n\nThe eigenvectors make up the rotation matrix. To check, let’s compare one column of the rotation matrix (say, the 3rd) with the corresponding eigenvector.\n\nplot( pca$rotation[,3], eig$vectors[,3], asp=1 )\n\n\n\n\nThe irlba function did not compute a full eigendecomposition but only calculated the first 20 eigenvectors. How can such a partial eigendecomposition be done?\nMost algorithms for partial eigendecompositions are refinements of a basic idea, the power method. The power method itself tends to not be very numerically stable, which is why much more stable variants have been developed. The irlba package, for example, used Baglama and Reichel’s “augmented implictly restarted Lanczoc bidiagonalization algroithm” (IRLBA).\nInstead of going into the depth of IRLBA and related approaches, we will only demonstrate the simple power method in the folloing.\nLet’s assume, the eigenvectors of our matrix \\(M=Y^\\top Y\\) were \\(\\mathbf{r}_l\\) with eigenvalues \\(\\lambda_l\\), i.e., \\(M\\mathbf{r}_l=\\lambda_l\\).\nWe start with a random vector \\(\\mathbf{v}\\). If we already knew the eigendecomposition of \\(M\\), we could use it as basis to expand \\(\\mathbf{v}\\) in it: \\(\\mathbf{v}=\\sum_l v_l \\mathbf{r}_l\\).\nApplying \\(M\\) gives \\(m\\mathbf{v}=\\sum_l \\lambda_l v_l \\mathbf{r}_l\\) and applying \\(M\\) \\(n\\) times yields \\[ M^n\\mathbf{v}=\\sum_l \\lambda_l^nv_l\\mathbf{r}_l\\] As \\(\\lambda_1\\) is the largest eigenvalue, the first component of \\(M^n\\mathbf{v}\\) will grow faster with \\(n\\) than the other components, and with increasing \\(n\\), the vector \\(M^n\\mathbf{v}\\) will become more and more collinear with the first eigenvector.\nWe try this by starting with a random vector, and applying the matrix 5 times. To avoid numerical overflow, we normalize the vector to unit length after each operation. Then, we compare the vector with the actual first eigenvector (as calculated by irlba) with a scatter plot.\n\nv &lt;- rnorm( length(hvg) )\nfor( i in 1:10 ) {\n  v &lt;- as.vector( yty %*% v )\n  v &lt;- v / sqrt(sum(v^2))\n  plot( pca$rotation[,\"PC1\"], v, asp=1, pch=\".\" )\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nv1 &lt;- v\n\nTo get the second eigenvector, we do the same as before, but after each operation we subtract the vector’s projection onto the first eigenvector.\n\nv &lt;- rnorm( length(hvg) )\nfor( i in 1:10 ) {\n  v &lt;- as.vector( yty %*% v )\n  v &lt;- v - v1 * sum( v1 * v )\n  v &lt;- v / sqrt(sum(v^2))\n  plot( pca$rotation[,\"PC2\"], v, asp=1 )\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nv2 &lt;- v\n\nBy projecting out the first two eigenvectors, we can get the third eigenvector:\n\nv &lt;- rnorm( length(hvg) )\nfor( i in 1:10 ) {\n  v &lt;- as.vector( yty %*% v )\n  v &lt;- v - v1 * sum( v1 * v )\n  v &lt;- v - v2 * sum( v2 * v )\n  v &lt;- v / sqrt(sum(v^2))\n  plot( pca$rotation[,\"PC3\"], v, asp=1 )\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAs states, this simple method tends to become numerically unstable quickly. However, most partial eigendecomposition algorithms actually used build onto this basic idea."
  },
  {
    "objectID": "index.html#material-and-video-recodings",
    "href": "index.html#material-and-video-recodings",
    "title": "Mathematics of Single-cell Omics",
    "section": "Material and Video Recodings",
    "text": "Material and Video Recodings\n\nLecture of 2024-04-22:\n\nVideo\nOverview High-throughput Sequencing\nA simple analysis with Seurat\nExample data: PBMC3k (available on 10X web site, and Moodle)\n\nExercise class of 2024-04-24\n\nVideo\nDoing the Seurat analysis “on foot”\n\nLecture of 2024-05-06\n\nVideo\nModularity clustering\nblackboard photo\n\nExercise class of 2024-05-08\n\nVideo\n\nImplementing modularity score in Python\nlouvain.py\n\nLecture of 2024-05-13\n\nVideo\nMathematics of PCA\nBlackboard photos: 1 2\n\nExercise class of 2024-05-15\n\nVideo:\nfitting pseudotimes and splines\nR code: pseudotime_1.R, splines_1.R\nexample data: cmss.rda (on Moodle)\n\nLecture of 2024-05-23\n\nplanned content:\n\nExpression dynamics along pseudotime trajectories\nSmoothing\nPrincipal curves"
  },
  {
    "objectID": "index.html#dates-and-times",
    "href": "index.html#dates-and-times",
    "title": "Mathematics of Single-cell Omics",
    "section": "Dates and times",
    "text": "Dates and times\nLecture times/dates:\n\non Mondays, 10-12 am c.t.\non Wednesdays, 16-18 pm s.t.\nno lecture on Mon 29 Apr and Wed 1 May\n\nPlace:\n\nnormally: seminar room SR 042 in BioQuant (INF 267)\nexceptions:\n\nWed 05 Jun: SR 043\nWed 12 Jun: Greenier-Saal (7th floor)\nWed 26 Jun: SR 041"
  },
  {
    "objectID": "principal_curves.html",
    "href": "principal_curves.html",
    "title": "Principal Curves",
    "section": "",
    "text": "Motivation\nOften, objects in feature space form point clouds that are elongated in one direction, which, however, is typically not shaped. Think of a long, curved, banana, or a pool noodle bent into a complex shape: draw random points from its volume and you have an example for such a point cloud.\nOur aim is to find a curve that describes the “center line” through such a point cloud.\n\n\nExample data\nIn practice, the problem usually arises with high-dimensional data, but to discuss approaches to solve it, it might be better to use example data that lives in a 2D space, as this is easy to visualize.\nThe following code uses splines to construct a curve that will serve as example.\nWe first set a number of control points:\n\nknots &lt;- cbind(\n  x = c( 0.1, 1.0, 1.7, 2.5, 2.8, 2.4, 2.2, 3.2, 4.0, 5.2 ),\n  y = c( 1.0, 1.2, 1.7, 1.9, 1.5, 1.1, 0.2, 0.6, 1.1, 1.2 ) )\n\nplot( knots, type=\"b\", asp=1 )\n\n\n\n\nNext, we use these points as guides to get a smooth (continuous and differentiable) curve:\n\nspline_basis &lt;- splines::bs( seq( 0, 1, l=1000), df=nrow(knots), intercept=TRUE )\n\nplot( knots, asp=1 )\nlines( spline_basis %*% knots, col=\"blue\" )\n\n\n\n\nWe will skip over an explanation how the bs function is used in this example to construct x and y coordinates, as out goal is just to get some non-trivial curve.\nNow we select random points along this curve (sampling the curve uniformly), and add some Gaussian noise to the 2D coordinates.\n\nset.seed( 13245768 )\nt &lt;- runif( 1000 )\n\nx &lt;- splines::bs( t, df=nrow(knots), intercept=TRUE ) %*% knots +\n  matrix( rnorm( 2000, 0 , .1), ncol=2 )\n\nThis will be our data. We will use it instead of our usual PCA scores. Here’s a plot of the data, with the original curve as dahsed line.\n\nplot( x, col=\"gray\", asp=1 )\nlines( spline_basis %*% knots, col=\"blue\", lty=\"dashed\" )\n\n\n\n\n\n\nFirst try with princurve\nCan we reconstruct the curve from the data? Let’s try, using the “princurve” package, which implements the method we will discuss below:\n\nprc &lt;- princurve::principal_curve( x )\n\nHere’s the curve that we got (in brown):\n\nplot( x, col=\"gray\", asp=1 )\nlines( prc$s[ prc$ord, ], col=\"brown\" )\nlines( spline_basis %*% knots, col=\"blue\", lty=\"dashed\" )\n\n\n\n\nThe principal curve algorithm tries to find a curve \\(\\mathbf{f}:[0,1]\\rightarrow\\mathbb{R}^n\\)\n\nstart with an initial guess \\(\\mathbf{f}^{(0)}\\) for the curve. The standard heuristic here is to perform a PCA on the data, and take a line through the origin, in the direction of the first PC, as \\(\\mathbf{f}^{(0)}\\).\nRepeat until convergence, using \\(i\\) as iteration counter, starting with \\(i=0\\):\n\nExtend the curve by linear extrapolation at both ends.\nProject each data point \\(\\mathbf{x}_i\\) onto the curve, i.e. find the argument \\(t\\) for the curve point closest to the data point: \\[ t_k^{(i)} = \\operatorname{arg min}_t \\|\\mathbf{x}_k - \\mathbf{f}^{(i)}(t)\\| \\] This gives us an ordering of the data points.\nFit a new curve \\(\\mathbf{f}^{(i+1)}\\) by regresing each of the coodinates of the \\(\\mathbf{x}_k\\) onto the \\(t_k^{(i)}\\) using either spline regression or local regression.\n\n\nBy default, princurve uses spline regression (as provided by the R basis function stats::smooth.spline). (Again, we unfortunately don’t have the time to discuss spline regression.)\nTo get a better result than what we just saw, we should increase the number of degrees of freedom (i.e., number of knots) for the spline smoother:\n\nprc &lt;- princurve::principal_curve( x, df=10 )\n\nplot( x, col=\"gray\", asp=1 )\nlines( prc$s[ prc$ord, ], col=\"brown\" )\nlines( spline_basis %*% knots, col=\"blue\", lty=\"dashed\" )\n\n\n\n\n\n\nReimplementing princurve\nNow, let’s try to reimplement this by hand to understand what princurve does.\n\nInitialization\nWe first need an initial guess for an assignment of points to pseudotime values.\nTo this end, we perform a PCA on the data\n\npca &lt;- prcomp( x )\n\nHere’s the direction of the first PC:\n\nplot( x, col=\"gray\", asp=1 )\nabline( a = 1.5, b = pca$rotation[\"y\",\"PC1\"] / pca$rotation[\"x\",\"PC1\"] )\n\n\n\n  # abline draws a line with intercept a (here chosen arbitrarily ) and\n  #    slope b (here taken from principal component 1)\n\nThe scores along PC1 are the orthogonal projections of the data points onto thie line. This will be our initial guess for the pseudotime, i.e., serve as a first rough ordering of the data points:\n\npt &lt;- pca$x[,\"PC1\"]\n\n\nscale_colors &lt;- function(t) \n  rje::cubeHelix(130,r=4)[ ceiling( ( t - min(t) ) / ( max(t) - min(t) ) * 99 ) + 1 ]\n\nplot( x, col=scale_colors(pt), asp=1, cex=.5 )\n\n\n\n\n\n\nRegression step\nNow, consider each coordinate dimension \\(i\\) of the data separately, and perform a smoothing spline regression of the \\(i\\)-th component of the data vectors onto the pseudotime:\n\nfits &lt;- lapply( 1:2, function(i) smooth.spline( pt, x[,i], df=10 ) )\n\nHere’s a plot of the fits:\n\nfor( i in 1:2 ) {\n  plot( pt, x[,i], asp=1, cex=.2, main=i )\n  lines( fits[[i]], col=\"red\" )\n}\n\n\n\n\n\n\n\nWe construct a fine grid of equispace pseudotime values, that extends a bit outwards the interval covered by our current pseudotime values:\n\ntg &lt;- seq(\n  from = min(pt) - .3 * ( max(pt) - min(pt) ),\n  to   = max(pt) + .3 * ( max(pt) - min(pt) ),\n  length.out = 10000 )\n\nNow, we calculate the curve points at these pseudotime points\n\ncurve &lt;- sapply( fits, function(fit)\n  predict( fit, tg )$y )\n\nhead(curve)\n\n          [,1]      [,2]\n[1,] -1.578154 0.5461749\n[2,] -1.577285 0.5464051\n[3,] -1.576416 0.5466354\n[4,] -1.575548 0.5468657\n[5,] -1.574679 0.5470960\n[6,] -1.573810 0.5473263\n\n\nHere’s\n\nplot( x, col=\"gray\", asp=1, cex=.5 )\nlines( curve, col=\"red\" )\n\n\n\n\n\n\nProjection step\nNow, we project each data point onto the curve, i.e., we find the curve point closest to the data point.\nWe use the fast nearest neighbors (FNN) package for this. Its function get.knnx takes two matrices, denoted “data” and “query” and considers the rows of these matrices as data points. Then, it searches for each query point its nearest neighbors among the data points.\n\nnn &lt;- FNN::get.knnx( data=curve, query=x, k=1 )\n\nstr(nn)\n\nList of 2\n $ nn.index: int [1:1000, 1] 4235 3473 3464 4794 4058 3316 5389 5706 2973 5287 ...\n $ nn.dist : num [1:1000, 1] 0.3878 0.1768 0.0412 0.2738 0.1139 ...\n\n\nNow, each data point has an index into our 3000 curve points that shows us where it is projected to.\nTo find pseudotime, we need to find out how away far the data point’s projection image is along the curve. Hence, we calculate the distance from each curve point to the next:\n\ncurve_segment_lengths &lt;- sqrt( \n  rowSums( ( curve[ 2:nrow(curve), ] - curve[ 1:(nrow(curve)-1), ] )^2 ) )\n                               \nhead( curve_segment_lengths )\n\n[1] 0.0008986183 0.0008986183 0.0008986183 0.0008986183 0.0008986183\n[6] 0.0008986183\n\n\nThe cumulative sum of this vector gives us the distance of erach curve point to the start of the curve, measured along the curve:\n\ndistance_from_start &lt;- c( 0, cumsum(curve_segment_lengths) ) \n\nhead( distance_from_start )\n\n[1] 0.0000000000 0.0008986183 0.0017972366 0.0026958549 0.0035944733\n[6] 0.0044930916\n\n\nNow, we can assign a pseudotime to each data point\n\npt &lt;- distance_from_start[ nn$nn.index ]\n\nHere is now the result of this first iteration, with our fitted curve in red, the true curve in blue, and the data points coloured by pseudotime:\n\nplot( x, col=scale_colors(pt), asp=1, cex=.5 )\nlines( curve, col=\"red\" )\nlines( spline_basis %*% knots, col=\"blue\", lty=\"dashed\" )\n\n\n\n\n\n\nNext iteration\nWe rerun the two steps to get the next iteration\n\n### Regression step:\n\n# Spline smoothing of individual coordinates\nfits &lt;- lapply( 1:2, function(i) smooth.spline( pt, x[,i], df=10 ) )\n\nfor( i in 1:2 ) {\n  plot( pt, x[,i], asp=1, cex=.2, main=i )\n  lines( fits[[i]], col=\"red\" )\n}\n\n\n\n\n\n\n# Calculate curve along fine grid\ntg &lt;- seq(\n  from = min(pt) - .3 * ( max(pt) - min(pt) ),\n  to   = max(pt) + .3 * ( max(pt) - min(pt) ),\n  length.out = 10000 )\n\ncurve &lt;- sapply( fits, function(fit)\n  predict( fit, tg )$y )\n\n\n### Projection step\n\n# Project data points onto curve with nearest-neighbor search:\nnn &lt;- FNN::get.knnx( data=curve, query=x, k=1 )\n\n# Calculate distances along curve\ncurve_segment_lengths &lt;- sqrt( \n  rowSums( ( curve[ 2:nrow(curve), ] - curve[ 1:(nrow(curve)-1), ] )^2 ) )\n\ndistance_from_start &lt;- c( 0, cumsum(curve_segment_lengths) ) \n\n# Assign pseudotime\npt &lt;- distance_from_start[ nn$nn.index ]\n\n# New plot\nplot( x, col=scale_colors(pt), asp=1, cex=.5 )\nlines( curve, col=\"red\" )\nlines( spline_basis %*% knots, col=\"blue\", lty=\"dashed\" )\n\n\n\n\n\n\nPutting it all together\n\nprincipal_curve_iteration &lt;- function( x, pt=NULL, curve=NULL ) {\n  \n  if( is.null(pt) ) {\n     # initialization step\n     pt &lt;- pca$x[,\"PC1\"]\n  }\n  \n  # Spline smoothing of individual coordinates\n  fits &lt;- lapply( 1:2, function(i) smooth.spline( pt, x[,i], df=10 ) )\n\n  # Calculate curve along fine grid\n  tg &lt;- seq(\n    from = min(pt) - .3 * ( max(pt) - min(pt) ),\n    to   = max(pt) + .3 * ( max(pt) - min(pt) ),\n    length.out = 10*nrow(x) )\n\n  curve &lt;- sapply( fits, function(fit)\n    predict( fit, tg )$y )\n\n  # Project data points onto curve with nearest-neighbor search:\n  nn &lt;- FNN::get.knnx( data=curve, query=x, k=1 )\n\n  # Calculate distances along curve\n  curve_segment_lengths &lt;- sqrt( \n    rowSums( ( curve[ 2:nrow(curve), ] - curve[ 1:(nrow(curve)-1), ] )^2 ) )\n\n  distance_from_start &lt;- c( 0, cumsum(curve_segment_lengths) ) \n\n  # Assign pseudotime\n  pt &lt;- distance_from_start[ nn$nn.index ]\n\n  list( pt=pt, curve=curve )\n}\n\n\nl = list( pt=NULL, curve=NULL )\nfor( iter in 1:6 ) {\n  \n  l &lt;- principal_curve_iteration( x, l$pt, l$curve )\n  \n  plot( x, col=scale_colors(l$pt), asp=1, cex=.5, main=sprintf( \"Iteration %d\", iter ) )\n  lines( l$curve, col=\"red\" )\n  lines( spline_basis %*% knots, col=\"blue\", lty=\"dashed\" )\n  \n  \n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBetter projection\nOur projection step is wasteful, as we need to calculate a very fine grid in order to make sure that we don’t get discretization errors. If we stick to the idea of representing the curve as a chain of linear segments, it should be sufficient to only use as much segments that the angle between two adjacent segments does not deviate too much from straight. Instead of projecting only on segment boundaries, we should also consider projecting at inner points of segments.\nCan you come up with an approach to do so?\nOn the otehr hand: Is this worthwhile, given that computers are fast?\n\n\n\nVariants\nIn the regression steps, we can replace the spline regression with any other smoothing method. The princurve package, for example, gives the option to use both spline regression and local (LOESS) regression."
  }
]